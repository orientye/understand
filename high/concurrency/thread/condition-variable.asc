:toc:
:toclevels: 5
:hardbreaks-option:

=== condition variable

==== 概念
条件变量通常有wait和notify两个动作，wait用于阻塞挂起线程，直到另一个线程通过notify来唤醒。
例如在生产者和消费者问题中，消费者如何知道生成者是否生产出了可以消费的产品呢？通过while循环不停的去判断是否可消费是一种方式，但这种方式极其消耗CPU性能，这种情形需要使用条件变量来阻塞线程，降低CPU占用率。

条件变量总是与一个互斥锁(mutex)一起使用。

==== wait
Q: wait作了什么
当线程A调用 cv.wait(lk, predicate) 时，会发生以下原子性的步骤:
(1) 释放锁(unlock): 线程A立即释放它持有的互斥锁 lk。如果不释放锁，其它线程就无法获取锁来修改共享数据，从而使条件变为真，那么所有等待的线程都将永远休眠下去（死锁）。
(2) 阻塞等待: 线程A被挂起（进入睡眠状态），并被放入一个由操作系统内核管理的、与条件变量 cv 相关的等待队列中。此时，线程A不再消耗CPU资源。
(3) 被唤醒后重新获取锁(lock): 当另一个线程（比如线程B）调用 cv.notify_one() 或 cv.notify_all() 时，线程A会被标记为可运行状态。当它被OS调度器再次选中执行时，它在从 wait 函数返回之前，会重新获取之前释放的互斥锁。这个过程可能会再次阻塞，直到锁可用。

Q: 什么是虚假唤醒(spurious wakeup)
简单来说，虚假唤醒就是: “你被唤醒了，但可能不是因为你等的东西准备好了。”
睡眠中的线程会醒来，但却发现它等待的条件并未满足，因此不得不再次进入睡眠。它无缘无故地醒来了。
https://en.wikipedia.org/wiki/Spurious_wakeup

Q: 为什么会有虚假唤醒
将唤醒操作做得过于完美可能会牺牲性能，因此标准选择了性能，并将正确检查条件的责任交给了程序员。
https://devblogs.microsoft.com/oldnewthing/20180201-00/?p=97946

Q: 如何解决虚假唤醒
只要使用 condition_variable.wait()，就一定要在循环中检查等待条件。
while 循环模式非常普遍，以至于在很多语言中它被直接集成到了条件变量的 API 中:

    C++: wait 方法可以接受一个谓词（lambda 表达式或函数），它会自动在循环中检查。
    Java: Object.wait() 也必须在 while 循环中使用:
        synchronized (obj) {
            while (conditionIsNotMet) {
                obj.wait();
            }
            // ...
        }
    Python: threading.Condition.wait() 也应在循环中使用:
        with cv:
            while not predicate():
                cv.wait()
        # ...

==== signal
Q: signal作了什么

Q: signal与unlock的顺序
顺序(1): 先解锁，后通知 (unlock then notify)
    优点:
        性能更好: 由于锁已经被释放，被唤醒的线程不会立刻因为拿不到锁而被再次挂起，它与其它线程公平竞争，这避免了一次不必要的上下文切换。
        更公平: 所有线程（被唤醒的和其它就绪的）在同一时间点开始竞争锁，调度更公平。
顺序(2): 先通知，后解锁 (notify then unlock)
    缺点:
        性能损耗: 线程会被毫无意义地唤醒一次，仅仅是为了尝试获取它肯定拿不到的锁，然后立刻又被挂起。这次上下文切换是纯粹的开销，被称为"拖拽调度"或是一种轻微的"惊群"效应。

Q: 什么是wait morphing
在后来的实现中，对顺序(2)的情况，如果线程被唤醒但是不能锁住mutex, 则线程被转移(morphing)到互斥量mutex的等待队列中，这样避免了上下文的切换造成的开销。

Q: signal与unlock的顺序选择哪一种
推荐采用(1)的顺序，即先解锁，再通知。
在 http://en.wikipedia.org/wiki/Single_UNIX_Specification 的规范中(pthread)，指明了两种顺序不管采用哪种，其实现效果都是一样的。

Q: 为什么Java先signal()后unlock()
signal()只是将等待线程从条件队列移动到锁的等待队列，但并不会立即唤醒它（唤醒发生在调用 unlock() 之后）。
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html

参考:
https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one.html
https://en.cppreference.com/w/cpp/thread/condition_variable.html
https://github.com/isocpp/CppCoreGuidelines/issues/1272
https://embeddedartistry.com/blog/2022/01/10/remember-to-lock-around-all-stdcondition_variable-variables/

==== 注意事项
https://github.com/chenshuo/recipes/blob/master/thread/test/Waiter_test.cc

==== 实现
glibc: https://github.com/lattera/glibc/blob/master/nptl/pthread_cond_common.c

==== 参考
《The Linux Programming inTerface》30.2
https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_cond_wait.html