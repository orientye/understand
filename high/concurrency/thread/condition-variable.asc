:toc:
:toclevels: 5
:hardbreaks-option:

=== condition variable

==== 概念与原理
通常有wait和notify两个动作，wait用于阻塞挂起线程，直到另一个线程通过notify来唤醒。
例如在生产者和消费者问题中，消费者如何知道生成者是否生产出了可以消费的产品呢？通过while循环不停的去判断是否可消费是一种方式，但这种方式极其消耗CPU性能，这种情形需要使用条件变量来阻塞线程，降低CPU占用率。

==== wait
Q: wait作了什么

Q: 什么是虚假唤醒(spurious wakeup)
https://en.wikipedia.org/wiki/Spurious_wakeup
Q: 为什么会有虚假唤醒
https://stackoverflow.com/questions/8594591/why-does-pthread-cond-wait-have-spurious-wakeups
Q: 如何解决虚假唤醒
while 循环同时防范了两种问题: 既防范了语义上的干扰（多个消费者被唤醒但只有一个能拿到资源），以及最主要的，防范了虚假唤醒。


==== signal
Q: signal作了什么
Q: signal与unlock的顺序
Q: 什么是wait morphing

==== 注意事项
https://github.com/chenshuo/recipes/blob/master/thread/test/Waiter_test.cc

==== 实现
glibc: https://github.com/lattera/glibc/blob/master/nptl/pthread_cond_common.c