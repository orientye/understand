:toc:
:toclevels: 5
:hardbreaks-option:

=== volatile

==== c/c++
- 作用
volatile was specifically intended to be used when interfacing with memory-mapped hardware,signal handlers and the setjmp machine code instruction.This makes volatile directly applicable to systems-level programming rather than normal applications-level programming.

    in C, and consequently C++, the volatile keyword was intended to:
    • allow access to memory-mapped I/O devices
    • allow uses of variables between setjmp and longjmp
    • allow uses of sig_atomic_t variables in signal handlers.

- 原子性(Atomicity)、可见性(Visibility)、有序性(Ordering)
Q: c/c++的volatile呢？
Q: java的volatile呢？

- NOTE
volatile is (nearly) useless for platform-agnostic, multithreaded application programming. It does not provide any synchronization, it does not create memory fences, nor does it ensure the order of execution of operations. It does not make operations atomic. It does not make your code magically thread safe. volatile may be the single-most misunderstood facility in all of C++.

    Bjarne Stroustrup says as much in TCPPPL4E:
    • Do not use volatile except in low-level code that deals directly with hardware.
    • Do not assume volatile has special meaning in the memory model. It does not.
    It is not -- as in some later languages -- a synchronization mechanism.
    To get synchronization, use atomic, a mutex, or a condition_variable

- 本质
prevents the compiler from performing optimization on code involving volatile objects, thus ensuring that each volatile variable assignment and read has a corresponding memory access

- 参考
https://en.wikipedia.org/wiki/Volatile_(computer_programming)
https://stackoverflow.com/questions/4557979/when-to-use-volatile-with-multi-threading
https://github.com/spotify/linux/blob/master/Documentation/zh_CN/volatile-considered-harmful.txt

==== java
- 保证变量的可见性
线程读变量能读到它在内存中的最新的值，也就是说不同的线程看到的一个变量的值是相同的。CPU都是有行缓存的，volatile能让行缓存无效，因此能读到内存中最新的值。

- 保证赋值操作的原子性
有些变量的赋值本身就是原子性的，例如boolean，int，但是对于long或者double则不一定，例如32位的处理器，对于64位的变量的操作可能会被分解成为高32位和低32位，从而导致线程不安全。如果变量声明为volatile，那么虚拟机会保证赋值是原子的，是不可被打断的。

- 禁止指令重排
正常情况下，虚拟机会对指令进行重排，当然是在不影响程序结果的正确性的前提下。volatile能够在一定程度上禁止虚拟机进行指令重排。还有就是对于volatile变量的写操作，保证是在读操作之前完成，假设线程A来读变量，刚好线程B正在写变量，那么虚拟机会保证写在读之前完成。

[source, cpp]
.https://github.com/openjdk/jdk/blob/master/src/hotspot/os_cpu/linux_x86/orderAccess_linux_x86.hpp
----
// A compiler barrier, forcing the C++ compiler to invalidate all memory assumptions
static inline void compiler_barrier() {
  __asm__ volatile ("" : : : "memory");
}

inline void OrderAccess::loadload()   { compiler_barrier(); }
inline void OrderAccess::storestore() { compiler_barrier(); }
inline void OrderAccess::loadstore()  { compiler_barrier(); }
inline void OrderAccess::storeload()  { fence();            }

inline void OrderAccess::acquire()    { compiler_barrier(); }
inline void OrderAccess::release()    { compiler_barrier(); }

inline void OrderAccess::fence() {
   // always use locked addl since mfence is sometimes expensive
#ifdef AMD64
  __asm__ volatile ("lock; addl $0,0(%%rsp)" : : : "cc", "memory");
#else
  __asm__ volatile ("lock; addl $0,0(%%esp)" : : : "cc", "memory");
#endif
  compiler_barrier();
}

inline void OrderAccess::cross_modify_fence() {
  int idx = 0;
#ifdef AMD64
  __asm__ volatile ("cpuid " : "+a" (idx) : : "ebx", "ecx", "edx", "memory");
#else
  // On some x86 systems EBX is a reserved register that cannot be
  // clobbered, so we must protect it around the CPUID.
  __asm__ volatile ("xchg %%esi, %%ebx; cpuid; xchg %%esi, %%ebx " : "+a" (idx) : : "esi", "ecx", "edx", "memory");
#endif
}
----
