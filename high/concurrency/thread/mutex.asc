:toc:
:toclevels: 5
:hardbreaks-option:

=== mutex

==== vs-semaphore
[cols="1,2,2", options="header"]
|===
| 特性
| Mutex (互斥锁)
| 信号量 (Semaphore)

| 所有者
| 具有所有者概念
| 无所有者概念

| 计数机制
| 二进制 (0 或 1)
| 计数器 (非负整数)

| 主要用途
| 实现互斥，保护共享资源
| 实现同步，控制资源访问数量

| 操作归属
| `lock()` 和 `unlock()` 必须由**同一线程**执行
| `wait()` 和 `signal()` 可由**不同线程**执行
|===

==== implement
===== linux kernel
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc#%E4%BA%92%E6%96%A5%E9%94%81

===== glibc
https://github.com/bminor/glibc/blob/master/nptl/pthread_mutex_lock.c

- pthread_mutex_lock 流程
** 快速路径 (Fast Path)
    *** 线程尝试使用原子操作（如 compare-and-swap, CAS）将锁变量从 0 (Unlocked) 改为 1 (Locked, no waiters)。
    *** 如果成功: 说明没有竞争，线程立即获得锁，函数返回。整个过程都在用户态，速度极快。
** 慢速路径 (Slow Path)
    *** 如果上面的原子操作失败，说明锁已被其他线程持有。
    *** 线程可能会自旋(PTHREAD_MUTEX_ADAPTIVE属性)，希望能避免进入内核。如果还是失败，它就会调用 futex 系统调用，并告知内核: 想在锁的这个地址上睡眠，如果它的值不是 FUTEX_WAIT 的预期值，就不睡了。
    *** 内核会检查用户空间锁变量的值:
        **** 如果值已经改变（比如锁恰好被释放了），系统调用立即返回，线程会重新尝试获取锁。
        **** 如果值未改变，内核将当前线程标记为休眠状态，并将其加入到该锁对应的等待队列中。线程在此处被挂起，等待被唤醒。

===== gcc(libstdc++-v3)
https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_mutex.h
linux上pthread: https://github.com/gcc-mirror/gcc/blob/master/libgcc/gthr-posix.h

===== clang(libc++)
https://github.com/llvm/llvm-project/blob/master/libcxx/src/mutex.cpp 平台相关，例如linux通过pthread

==== management
===== c++
std::lock_guard vs. std::scoped_lock vs. std::unique_lock 等
参考:  https://en.cppreference.com/w/cpp/atomic.html#Generic_mutex_management

==== futex(fast userspace mutex)
在用户态进行无竞争的锁获取，只有在可能发生阻塞时才陷入内核
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc#futex

==== 参考
《The Linux Programming inTerface》30.1