:toc:
:toclevels: 5
:hardbreaks-option:

=== join and detach
==== join
If a thread is not detached, then we must join with it using pthread_join(). If we fail to do this, then, when the thread terminates, it produces the thread equivalent of a zombie process. Aside from wasting system resources, if enough thread zombies accumulate, we won’t be able to create additional threads.

可连接线程(Joinable / Non-Detached Thread):
    线程的默认属性（除非显式设置创建为分离的）。
    这种线程终止后，它的退出状态（返回值）和线程资源（如栈空间）不会立即被系统回收。
    必须由另一个线程调用 pthread_join() 来回收它。这个过程会获取线程的返回值并释放其所有资源。
    类比: 这就像进程中的 wait() 或 waitpid() 系统调用。如果一个可连接线程从未被 join，它就会变成一个僵尸线程，浪费系统资源。

==== detach
Detaching a thread doesn’t make it immune to a call to exit() in another thread or a return in the main thread. In such an event, all threads in the process are imme-diately terminated, regardless of whether they are joinable or detached. To put things another way, pthread_detach() simply controls what happens after a thread terminates, not how or when it terminates.

分离线程(Detached Thread):
    线程终止后，其资源和退出状态会由系统自动回收。
    其它线程无法对它使用 pthread_join() 来获取其返回值。

可以通过两种方式进行设置:
    在创建线程时，设置线程属性为 PTHREAD_CREATE_DETACHED。
    在线程创建后，调用 pthread_detach()。

==== cpp
https://en.cppreference.com/w/cpp/thread/thread/join.html
https://en.cppreference.com/w/cpp/thread/thread/detach.html

=== java
https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#join--

In Java, there's no explicit "detach" method like in some other languages, but there are several ways to achieve similar behavior.