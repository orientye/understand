:toc:
:toclevels: 5
:hardbreaks-option:

== lock

=== 概念
- Locks are bad:

    Taking too few locks
    Taking too many locks
    Taking the wrong locks
    Taking locks in the wrong order
    Error recovery
    Lost wakeups and erroneous retries
    But the fundamental shortcoming of lock-based programming
        is that locks and condition variables do not support modular programming.
    - 参考《Beautiful Code》- Beautiful Concurrency

- 可重入/递归

- busy wait/sleep wait

- 乐观锁(optimistic locking)与悲观锁(pessimistic locking)

    Q: 什么是乐观锁? 有哪些常见的乐观锁?
    https://en.wikipedia.org/wiki/Optimistic_concurrency_control
    Q: 乐观锁适合什么场景/优缺点
    乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高
    只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁
    Q: 乐观锁 vs. 悲观锁
    https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking

- non-blocking(lock-free)

    obstruction-free(无障碍)
    lock-free(无锁)
    wait-free(无等待)
    https://en.wikipedia.org/wiki/Non-blocking_algorithm

- 公平锁与非公平锁

- priority inversion

    https://en.wikipedia.org/wiki/Priority_inversion

=== dead lock
==== 概念
死锁通常是因为获取锁时形成了环路。

==== 死锁发生前
- 尽量不要使用共享

- 例如使用消息通讯，例如Erlang里的变量不变

- 尽量使用并发组件

    例如java.util.concurrent

- 尽量使用非递归锁(不可重入锁)

    例如pthread_mutex_t默认非递归

- 控制顺序

    thread 1: Lock(a), Lock(b)
    thread 2: Lock(b), Lock(a)
    转变为统一的顺序如Lock(a), Lock(b)
    运行期警告

- try_lock

- 把Lock（历史）形成一个graph，看是否存在回路

- 超时机制

    如带有timeout的wait, innodb_lock_wait_timeout等

- 工具测试

    例如Intel inspector, Valgrind-Helgrind(pthread)等

- PS. 银行家算法

    由Edsger Dijkstra爷爷为设计THE操作系统创建，其使用场景也有些局限性:
    比如需要知道进程请求资源的可能数量，以及假设进程数量是固定的等，因此基本不具有实用性。

==== 死锁发生后
- 堆栈查看

    pstack(其实就是gdb thread apply all bt)
    jstack, jconsole
    ps. CPU100%也可以通过这种方法

- 检测机制

    例如innodb的wait-for graph，形成环路（或者层次太深时也会认为死锁）时，
    此时会选择Undo量小的事务进行回滚。

==== vs. livelock
Livelock: A livelock is a special type of deadlock, where the processes are changing their states continuously but not making any progress.

Now, let's say in the above example we wish to resolve this deadlock. We put in a deadlock identifying setup which becomes aware of a deadlock when it happens. It orders the processes that are part of the deadlock, to release all their resources for some time and then come back and try proceeding again. If A, B, and C do this at the same time, they would keep oscillating in a loop of 1. Getting stuck in deadlock 2. Releasing the resource 3. Waiting for some time 4. Locking again the resource they were previously holding, thus recreating the deadlock.

Real life example would be when you make a phone call, but the person at the other end is trying to call you too. You both hang up and try again after the same time, which creates the same situation again. This can go on for eternity.

参考: https://en.wikipedia.org/wiki/Deadlock#Livelock

==== vs. starvation
https://www.codingninjas.com/studio/library/deadlock-vs-starvation

参考: https://www.geeksforgeeks.org/difference-between-deadlock-and-starvation-in-os/

=== lock lack
https://mp.weixin.qq.com/s?__biz=MzI5NDY2MDE0Nw==&mid=2247483665&idx=1&sn=272e38645d0e414c77e67ce8389fe3e1&chksm=ec5e304ddb29b95bf2d4052266fb37a1c828c24e6d4db51320ddcc60e1af90a8661e4e69874f&mpshare=1&scene=1&srcid=1008Spw64tFyuoQZegtgVytP&sharer_sharetime=

=== thread safety analysis
https://insights.sei.cmu.edu/blog/thread-safety-analysis-in-c-and-c/
https://github.com/facebook/infer
https://github.com/microsoft/infersharp

=== futex
- 主要思想: fast userspace mutex
- 实现: https://github.com/torvalds/linux/blob/master/kernel/futex.c

=== kernel中的锁
- https://www.kernel.org/doc/html/latest/locking/index.html
- https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html

=== 分布式锁
vs. 分布式事务
- 基于数据库来实现
- 基于缓存来实现
- 基于zookeeper来实现
- 基于consul来实现

=== 工程实践
- PTHREAD_MUTEX_ERRORCHECK
