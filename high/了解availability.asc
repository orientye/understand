= 了解availability
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com
<<<

== 概述
- 概念

    指系统无中断地执行其功能的能力
    
    平均故障时间MTBF(Mean Time Between Failure): 相邻两次故障之间的平均工作时间
    平均修复时间MTTR(Mean Time To Repair): 由故障状态转为工作状态所花费的修理时间的平均值
    可用性计算公式: 可用性 = MTBF / (MTBF + MTTR)
    
    vs. 可靠性 可维护性
    可靠性(reliability)是指定时间内, 产生预期输出的几率
    可维护性(serviceability)是指若系统发生故障, 需要多长时间检查和维修

- 指标

[format="csv", options="header", separator=#]
|===
Availability % # Downtime per year # Downtime per quarter # Downtime per month # Downtime per week # Downtime per day
90%	# 36.53 days	# 9.13 days	# 73.05 hours	# 16.80 hours	# 2.40 hours
99%	# 3.65 days	# 21.9 hours	# 7.31 hours	# 1.68 hours	# 14.40 minutes
99.9%	# 8.77 hours	# 2.19 hours	# 43.83 minutes	# 10.08 minutes	# 1.44 minutes
99.99%	# 52.60 minutes	# 13.15 minutes	# 4.38 minutes	# 1.01 minutes	# 8.64 seconds
99.999%	# 5.26 minutes	# 1.31 minutes	# 26.30 seconds	# 6.05 seconds	# 864.00 milliseconds
99.9999% # 31.56 seconds	# 7.89 seconds	# 2.63 seconds	# 604.80 milliseconds	# 86.40 milliseconds
99.99999%  # 3.16 seconds	# 0.79 seconds	# 262.98 milliseconds	# 60.48 milliseconds	# 8.64 milliseconds
99.999999% # 315.58 milliseconds	# 78.89 milliseconds	# 26.30 milliseconds	# 6.05 milliseconds	# 864.00 microseconds
99.9999999% # 31.56 milliseconds	# 7.89 milliseconds	# 2.63 milliseconds	# 604.80 microseconds	# 86.40 microseconds
|===

- 基本思想

    消除单点/冗余
    故障转移
    失败检测

== 负载均衡

=== 各层负载均衡
- 二层负载均衡
    
    如LVS DR模式

- 三层负载均衡

    如LVS TUN模式

- 四层负载均衡
    
    如LVS NAT模式

- 七层负载均衡
    
    如ngnix, HAProxy

=== 算法
- round-robin
- 加权/weight round-robin
- random
- 加权/weight random
- 通用hash
- 一致性/consistent hash
- least connection
- least time 最小平均响应时间(nginx商业版)
- locality aware
- 带状态的负载均衡(sticky connection)

== 超时
应用程序根据服务调度策略, 选择重试或请求转移到其他机器上。

== 幂等
服务调用失败后，调用方会将请求转发到其他服务器上，但是这个失败可能是虚假的失败。比如服务已经处理成功，但因为网络故障导致调用方没有收到应答，或等待超时。这种情况下，重新发起请求，可能会导致重复操作，如果这个操作是比较敏感的交易操作，就会产生严重后果。

服务重复调用时无法避免的，但是只要能从业务实现上保证，重复调用和一次调用的处理结果一致，则业务就没有问题，这就是幂等性设计。

有些服务的业务天然具有幂等性，比如将用户性别设为男性，不管执行多少次，结果是一致的。但有些复杂的业务，要想保证幂等性，就需要根据全局性的ID去进行有效性验证，验证通过才能继续执行。

== 雪崩
访问服务集群时绝大部分请求都超时，且在流量减少时仍无法恢复的现象
参考: https://github.com/apache/incubator-brpc/blob/master/docs/cn/avalanche.md

== 限流
为了保证系统在遭遇突发流量时，能够正常运行，需要限制流量，超出系统访问能力的请求将被丢弃。
常见的限流算法有：漏桶、令牌桶、滑动窗口计数
参考: https://github.com/apache/incubator-brpc/blob/master/docs/cn/auto_concurrency_limiter.md

== 排队
排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待很长时间。

== 降级
为了保证核心功能的正常运行, 系统将某些次要业务或者接口的功能降低, 停掉其部分功能甚至全部功能。

vs. 限流
降级是从系统功能优先级的角度考虑如何应对故障
限流则是从用户访问压力的角度来考虑如何应对故障

== 熔断
当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。例如Hytrix

== 隔离
线程隔离
进程隔离
集群隔离
机房隔离
应用隔离
读写隔离
资源隔离
热点隔离

== 热更新
例如脚本更新

== 热重启
例如nginx更新

== 回滚
事务回滚, 部署版本回滚, 数据库回滚/备份恢复, 代码回滚, 资源回滚等

== 灰度发布
灰度发布，是在生产环境稳定集群之外，额外部署一个小规模的灰度集群，并通过流量控制，引入部分流量到灰度集群，进行生产全量发布前的灰度验证。如果验证失败，可立刻将所有流量切回至稳定集群，取消灰度发布过程；如果验证成功，则将新版本进行全量发布升级至生产环境稳定集群，完成灰度发布过程。

== 高可用架构
=== 主备/主从/主主
- 主备
    
    备机只负责备份功能

- 主从

    从机承担读功能

- 主主

    主动模式(不推荐) 被动模式

=== 集群和分区
- 集群
- 分区

    ▪ 分区规则
        ⦁ 哈希
        ⦁ 范围
        ⦁ 地理
        
    ▪ 复制与备份
        ⦁ 集中
        ⦁ 独立
        ⦁ 相互

=== 异地多活
- 主要思想

    ▪ 异地多活架构的关键点就是异地、多活，其中异地指地理位置上不同的地方，多活指不同地理位置上的系统都能够提供业务服务。
    ▪ 异地多活虽然功能很强大，但也不是每个业务不管三七二十一都要上异地多。
    ▪ 如果业务规模很大，能够做异地多活的情况下尽量实现异地多活。
    ▪ 异地多活架构可以分为同城异区、跨城异地、跨国异地。

    ▪ vs. 两地三中心
    典型如国内外银行等高端用户多采用"两地三中心"(即生产数据中心、同城灾备中心、异地灾备中心)建设方案。
    这种模式下，多个数据中心是主备关系，即存在主次，业务部署优先级存在差别，针对灾难的响应与切换周期非常长。
    两地三中心本质上是一种通过简单资源堆砌提高可用性的模式，业务连续性及容灾备份没有实质性的跨越。

- 业务分级

    按照一定的标准将业务进行分级，挑选出核心的业务，只为核心业务设计异地多活，降低方案整体复杂度和实现成本。
    ▪ 访问量大的业务
    ▪ 核心业务
    ▪ 大量收入的业务

- 数据分类

    ▪ 数据量
    新增、修改、删除的数据就是可能要同步的数据，数据量越大，同步延迟的概率越高，同步方案需要考虑相应的解决方案。

    ▪ 唯一性
    如果数据要求必须唯一，要么只能一个中心点产生数据，要么需要设计一个数据唯一生成的算法。

    ▪ 实时性
    实时性指如果在A机房修改了数据，要求多长时间必须同步到B机房，实时性要求越高，对同步的要求越高，方案越复杂。

    ▪ 可丢失性
    可丢失性指数据是否可以丢失。
    例如，写入A机房的数据还没有同步到B机房，此时A机房机器宕机会导致数据丢失，那这部分丢失的数据是否对业务会产生重大影响。
    例如，登录过程中产生的session数据就是可丢失的，因为用户只要重新登录就可以生成新的session；
    而用户ID数据是不可丢失的，丢失后用户就会失去所有和用户ID相关的数据，例如用户的经济数据。

    ▪ 可恢复性
    可恢复性指数据丢失后，是否可以通过某种手段进行恢复
    如果数据可以恢复，至少说明对业务的影响不会那么大，这样可以相应地降低异地多活架构设计的复杂度。

- 数据同步

    ▪ 存储系统同步
    这是最常用也是最简单的同步方式。例如，使用MySQL的数据主从数据同步、主主数据同步。
    这类数据同步的优点是使用简单，因为几乎主流的存储系统都会有自己的同步方案；
    缺点是这类同步方案都是通用的，无法针对业务数据特点做定制化的控制。
    例如MySQL都只有一个同步通道。因为要保证事务性，一旦数据量比较大，或者网络有延迟，则同步延迟就会比较严重。

    ▪ 消息队列同步
    采用独立消息队列进行数据同步，常见的消息队列有Kafka、ActiveMQ、RocketMQ等。
    消息队列同步适合无事务性或无时序性要求的数据。
    例如，用户账号，两个用户先后注册了账号A和B，如果同步时先把B同步到异地机房，再同步A到异地机房，业务上是没有问题的。
    而如果是用户密码，用户先改了密码为m，然后改了密码为n，同步时必须先保证同步m到异地机房，再同步n到异地机房。
    因此，对于新注册的用户账号，我们可以采用消息队列同步了；而对于用户密码，就不能采用消息队列同步了。

    ▪ 重复生成
    数据不同步到异地机房，每个机房都可以生成数据，这个方案适合于可以重复生成的数据。
    例如，登录产生的cookie、session数据及缓存数据等。

- 异常处理

    无论数据同步方案如何设计，一旦出现极端异常的情况，总是会有部分数据出现异常的。例如，同步延迟、数据丢失、数据不一致等。
    异常处理就是假设在出现这些问题时，系统将采取什么措施来应对。异常处理主要有以下几个目的：
    ▪ 问题发生时，避免少量数据异常导致整体业务不可用。
    ▪ 问题恢复后，将异常的数据进行修正。
    ▪ 对用户进行安抚，弥补用户损失。

- 接口级的故障应对方案

    异地多活架构主要应对系统级的故障。例如，机器宕机、机房故障、网络故障等问题。
    这些系统级的故障虽然影响很大，但发生概率较小。
    实际业务运行过程中，还有另外一种故障影响可能没有系统级那么大，但发生的概率较高，这就是接口级的故障。

    解决接口级故障的核心思想和异地多活基本类似：优先保证核心业务，优先保证绝大部分用户。
    主要措施: 降级、熔断、限流、排队

参考: https://www.infoq.cn/article/gqyk1h46thu4mbqpardw