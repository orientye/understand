= stability
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com

<<<

== 代码层面
- 1. 对输入的边界的控制
确保输入是符合自己的预期的，而不只是文档上写的一些对输入边界的约束，例如最典型的故障是批量操作型的接口，由于批量操作的量超过了预期，直接内存溢出等。

- 2. 对使用到的API需要有深刻的理解（包括实现原理、代码细节）
只有这样，才能知道各种情况下的状况，从而在真正出故障的情况下能快速处理。

- 3. Fail fast
不管什么情况，以保障代码能正常运转是最重要的（最简单的标准是别把资源耗尽或Crash），在碰到意外情况下，尽快往外抛出错误是最好的，当然，这个主要是对在线型业务而言。

== 测试层面

== 设计层面
1. 强弱依赖识别，对弱依赖的地方，确保有各种降级策略；

2. 自身能力保护，一定要对自己系统的能力有清晰的认识，例如通常来说在线业务系统的指标通常是每秒处理的请求数，在超出能处理的请求数的情况下，需要尽快fail fast，在线业务做堆积是不好的，容易出问题，像Nginx之类的不一样，但也会对堆积程度有个边界控制；

3. 容灾能力，这个从集群化、到同城多活、再到异地多活，其实都有各种成熟的案例和相应的方案。

== 变更层面
1. 强制灰度，毕竟能灰度，相对来说就能更好的控制故障的影响范围（另外一个词是爆炸半径）；

2. 可监控以及可回滚，没有监控，就完全没办法知道变更后的情况，可回滚通常是变更一旦出问题，最好用的招，但确实也会难免碰到无法回滚的变更，那样类型的变更就要高度谨慎了；

3. 在故障出现时尽快恢复，而不是解决故障，在保留一定的现场的基础上，尽快的恢复问题比查问题重要的多，例如大家很多时候看到最有效的处理故障的方法可能是重启，有同城双活、异地多活的通常最有效的处理方法是切流量等。

== 运维层面

== 参考
https://www.zhihu.com/question/59182318
https://www.infoq.cn/profile/8CB9CFC9CE21C8/publish
https://mp.weixin.qq.com/s/n6LgMPzyWNx5EcCxp2CHDQ