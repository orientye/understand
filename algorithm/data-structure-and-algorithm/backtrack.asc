:toc:
:toclevels: 5
:hardbreaks-option:

== 回溯(backtrack)

=== 思想
回溯本质上是对决策树(多叉树)的遍历

==== 要素
- 路径: 已经做出的选择
- 选择: 下一步要做的选择
- 结束条件: 到达底部

==== 比较
- backtrack vs. DFS
回溯遍历树枝，DFS遍历节点
According to Donald Knuth, it's the same: https://arxiv.org/pdf/cs/0011047.pdf[Backtracking, also called depth-first search]
https://stackoverflow.com/questions/1294720/whats-the-difference-between-backtracking-and-depth-first-search

- backtrack vs. Brute Force
回溯其实就是一种暴力搜索，有时候可以通过剪支来优化

- backtrack vs. DP
DP不是暴力搜索。
DP属于分解问题的思路，其关注点在整棵「子树」。
回溯属于遍历的思路，其关注点在节点间的「树枝」。
https://stackoverflow.com/questions/3592943/difference-between-back-tracking-and-dynamic-programming/3593147

- backtrack vs. Branch and Bound
https://stackoverflow.com/questions/30025421/difference-between-backtracking-and-branch-and-bound

=== 框架

    backtrack(路径, ...)
        if 满足结束条件:
            添加到结果集
            return
        for i in 选择:
            做选择
            backtrack(路径, ...)
            撤销选择

    循环-横向遍历，递归-纵向遍历

=== 优化
通过剪支来优化

=== 应用
组合/排列/切割/子集/棋盘...
组合问题: N个数里面按一定规则找出k个数的集合
排列问题: N个数按一定规则全排列，有几种排列方式
切割问题: 一个字符串按一定规则有几种切割方式
子集问题: 一个N个数的集合里有多少符合条件的子集
棋盘问题: N皇后，解数独等等

=== 例题
https://leetcode.com/tag/backtracking/

==== 组合问题
lc77m: https://leetcode.com/problems/combinations/

==== 排列问题
- lc46m: https://leetcode.com/problems/permutations/
每层都是从0开始搜索而不是startIndex
需要used数组记录path里都放了哪些元素了
另外一种解法:
https://leetcode.com/problems/permutations/solutions/18247/my-elegant-recursive-c-solution-with-inline-explanation/
https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/

==== 切割问题

==== 子集问题

==== 棋盘问题
lc51h: https://leetcode.com/problems/n-queens/
lc52h: https://leetcode.com/problems/n-queens-ii/

=== 参考
https://github.com/youngyangyang04/leetcode-master#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95
https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/
https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-56e11/
https://www.geeksforgeeks.org/backtracking-algorithms/