:toc:
:toclevels: 4
:hardbreaks-option:

== 动态规划(dynamic programming)

=== 思想
- 最优子结构

    问题的最优解包含子问题的最优解。
    可以通过子问题的最优解，推导出问题的最优解。
    对应到动态规划问题模型上，可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

- 无后效性

    无后效性有两层含义:
    (1)推导后面阶段的状态的时候，只关心前面阶段的状态值，而不关心这个状态是怎么一步步推导出来的。
    (2)某阶段状态一旦确定，就不受之后阶段的决策影响。

- 重复子问题

    不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

一般用于:
- 最大值/最小值
- 是否可行
- 方案总数

=== 框架
根据最优子结构, 状态转移方程。
有了状态转移方程, 一般两种代码实现方法, 一种是递归+备忘录, 一种是迭代递推。

步骤:
(1) 确定DP数组以及下标的含义
(2) 确定递推公式
(3) DP数组的初始化
(4) 确定遍历顺序
(5) 举例推导DP数组

=== 优化
- 空间优化
滚动数组: 
https://leetcode.com/problems/unique-paths/discuss/22954/C%2B%2B-DP

- 时间优化
    通过变换状态优化
    通过决策单调优化
参考:《九章算法 动态规划十问十答》

=== 背包问题(knapsack problem)
==== 概要
给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，如何选择才能使得物品的总价格最高。

==== 01背包
01背包问题(01 knapsack problem): 一共有N件物品，第i(i从1开始)件物品的重量为w[i]，价值为v[i]。
在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

==== 完全背包
完全背包(unbounded knapsack problem)与01背包不同就是每种物品可以有无限多个: 一共有N种物品，每种物品有无限多个，第i(i从1开始)种物品的重量为w[i]，价值为v[i]。
在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

==== 多重背包
多重背包(bounded knapsack problem)与前面不同就是每种物品是有限个: 一共有N种物品，第i(i从1开始)种物品的数量为n[i]，重量为w[i]，价值为v[i]。
在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

=== 例题
- https://leetcode.com/tag/dynamic-programming/

=== 参考
https://www.zdaiot.com/DataStructureAlgorithm/40%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%EF%BC%9A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%81%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7%E5%92%8C%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/
https://github.com/youngyangyang04/leetcode-master#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92
https://github.com/tianyicui/pack/blob/master/V2.pdf[《背包问题九讲2.0 - 崔添翼》]
https://zhuanlan.zhihu.com/p/93857890
