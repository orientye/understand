:toc:
:toclevels: 5
:hardbreaks-option:

== 字符串

=== 匹配/查找

==== KMP
===== 实现思想
- 复杂度
O(m+n)
有一个字符串"BBC ABCDAB ABCDABCDABDE"，求是否包含字符串"ABCDABD"？

- 部分匹配表(Partial Match Table)/前缀表
前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。
"前缀"指除了最后一个字符以外，一个字符串的全部头部组合；
"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。

- 示例1

    ABCDABD的部分匹配表: [0,0,0,0,1,2,0]
    以ABCDABD为例:
    A的前缀和后缀都为空集，共有元素的长度为0
    AB的前缀为[A]，后缀为[B]，共有元素的长度为0
    ABC的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0
    ABCD的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0
    ABCDA的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1
    ABCDAB的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2
    ABCDABD的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0

- 示例2

    aabaaf [0,1,0,1,2,0]
    a: 0
    aa: [a]  [a]  1
    aab:  [a, aa]  [ab, b]  0
    aaba: [a, aa, aab]  [aba, ba, a]  1
    aabaa: [a, aa, aab, aaba]  [abaa, baa, aa, a]  2
    aabaaf: [a, aa, aab, aaba, aabaa]  [abaaf, baaf, aaf, af, f]  0

- 匹配过程
移动位数 = 已匹配的字符数 - 对应的部分匹配值

===== 例题
lc28: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/

===== 参考
https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md
http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/
https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/

==== Boyer-Moore算法
===== 参考
https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html

==== 参考
https://en.wikipedia.org/wiki/String-searching_algorithm

=== 参考
https://github.com/youngyangyang04/leetcode-master#%E5%AD%97%E7%AC%A6%E4%B8%B2