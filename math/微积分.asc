= 微积分(Calculus)
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:stem: latexmath
:homepage: http://orientye.com

<<<

== 极限
=== 基本思想
极限描述的是当自变量(如 x)无限接近某个值(如a)时，函数 f(x) 的取值趋近于某个确定的数值 L。
记作: limₓ→ₐf(x) = L

极限关注的是 x 接近 a 时的趋势，而非函数在 a 点的实际值(甚至函数在 a 点可以无定义)。
例如: limₓ→₀(sinx/x) = 1

=== 左、右与双侧极限
limₓ→ₐ⁺f(x) = L 且 limₓ→ₐ⁻f(x) = L 等价于 limₓ→ₐf(x) = L
如果左右极限不相等，则极限不存在。

=== 何时极限不存在
左右极限不相等: 分段函数在分段点
函数趋向于无穷大: limₓ→₀(1/x)
函数无限振荡: limₓ→₀sin(1/x)
无定义且趋势不一致: limₓ→₀(1/x)sin(1/x)

=== 在正无穷、负无穷处的极限
+∞ 处的极限: 考察 x 无限增大时 f(x) 的趋势
−∞ 处的极限: 考察 x 无限减小时 f(x) 的趋势
两者相同: 可以合并为 limx→∞f(x)
两者不同: 极限 limx→∞f(x) 不存在

=== 无穷小量(infinitesimal)
若函数 f(x) 满足：limₓ→ₐf(x) = 0 则称 f(x) 为 x→a 时的无穷小量。

运算性质:
有限个无穷小量的和、差、积仍是无穷小量。
无穷小量与有界量的乘积是无穷小量(如 xsin(1/x)当x→0)。
无穷小量除以非零极限量仍为无穷小量。

=== 求解多项式的极限问题
- x → a 时的有理函数
- x → a 时的涉及平方根的函数
- x → ∞ 时的有理函数
- x → ∞ 时的类多项式(或多项式型) 函数的比
- x → -∞ 时的有理函数/多项式型函数
- 涉及绝对值的函数

== 连续(continuity)
=== 连续性三要素
函数f(x)在点x=a处连续，当且仅当以下三个条件同时满足:
1. 函数在a点有定义
2. 极限 limₓ→ₐf(x) 存在 
3. 极限值等于函数值

=== 意义
几何意义: 连续函数的图像是一条"不断开"的曲线，可以用笔一笔画成(无抬笔)。
物理意义: 如时间-位移函数若连续，表示物体运动轨迹无瞬间跳跃。

=== 介值定理(Intermediate Value Theorem)
设函数 f 在闭区间 [a, b] 上连续，且 u 是介于 f(a) 和 f(b) 之间的任意实数（即 f(a)≤u≤f(b) 或 f(b)≤u≤f(a)），则存在至少一点 c∈[a,b]，使得f(c)=u.

经典应用:
证明方程解的存在性

=== 最大值与最小值定理(Extreme Value Theorem)
设函数 f 在[a, b] 上连续, 那么f 在[a, b] 上至少有一个最大值和一个最小值.

与介值定理的关系:
介值定理：连续函数在区间内会经过所有中间值。
最值定理：连续函数在闭区间上一定有最大值和最小值。
两者共同刻画了连续函数在闭区间上的良好性质。

经典应用:
求函数的最值(最值必然在两端点以及极值点中取值)

总结:
✅ 适用条件：闭区间 + 连续函数。
✅ 结论：函数在该区间上必能取到最大值和最小值。
❌ 不适用：开区间、无限区间、不连续函数。

=== 李普希茨连续性(Lipschitz continuity)
- 概念
李普希茨连续性是数学中描述函数"平滑性"或"可控变化"的一种强于一致连续性但弱于可微性的条件。它由德国数学家鲁道夫·李普希茨(Rudolf Lipschitz)提出，在分析学、微分方程、优化理论等领域有广泛应用。
李普希茨连续性通过限制函数变化的速度，为分析函数的稳定性、唯一性和收敛性提供了有力工具。它填补了可微性与一致连续性之间的空白，是许多数学理论和算法的基础条件。

- 定义
设函数 f:X→Y（通常 X⊆Rⁿ, Y⊆Rᵐ），若存在常数 L≥0（称为李普希茨常数），使得对所有 x₁,x₂ ∈ X，有: ∥f(x₁)−f(x₂)∥≤L∥x₁−x₂∥ 则称 f 满足李普希茨连续。若 L<1，则称 f 为压缩映射。

- 几何意义
限制函数的变化速率，确保函数图像不会"无限陡峭"或"剧烈震荡"。

- 应用场景
    ** 微分方程的解的唯一性
        皮卡-林德勒夫定理（Picard-Lindelöf）要求右端函数满足李普希茨条件，以保证解的唯一性。
    ** 优化理论
        梯度下降法的收敛性分析中，目标函数的梯度若满足李普希茨连续，可确定步长范围。
    ** 机器学习
        模型正则化或稳定性分析中，李普希茨连续性用于控制函数的敏感度。

- 示例
线性函数: f(x)=ax+b 是李普希茨连续的，常数L=∣a∣。
f(x)=sqrt(x) 在[1, +∞)上李普希茨连续，在[0, 1]上不是。
f(x)=x² 在 R 上不是李普希茨连续（导数无界），但在有限区间内是。
f(x)=∣x∣ 是李普希茨连续的（L=1），尽管在 x=0 处不可微。

- 参考
https://en.wikipedia.org/wiki/Lipschitz_continuity

== 导数(derivative)
=== 概念
- 导数
函数 f(x) 在点 x=a 处可导，当且仅当以下极限存在且有限:
f′(a) = limₕ→₀(f(a+h)-f(h))/h
如果该极限存在，则称 f(x) 在 x=a 处可导，且极限值 f′(a) 为函数在该点的导数。

- 意义
导数可以被解释为函数相对于其变量的瞬时变化率，它也是函数曲线的切线的斜率。
几何意义:
    可导意味着函数图像在 x=a 处存在唯一的切线，且切线斜率有限(即曲线在该点"光滑")。
    反例：尖点(如 f(x)=∣x∣ 在 x=0 处)无唯一切线，故不可导。
物理意义:
    可导对应物理量的瞬时变化率(如速度是位移的导数)，不可导则可能表示突变(如瞬时冲击力)。

- 可导 vs. 连续
可导必连续
连续不一定可导
例如 f(x)=∣x∣ 在 x=0 处连续但不可导
可导不仅要求连续，还要求函数在局部是"光滑"的(无尖角、震荡或垂直切线)。

- 导数(derivative) vs. 微分(differential)
f′(x) 读作"f prime of x"或者"f撇x"(f′′(x)读作"f double prime of x"或者"f两撇x")
dy=f′(x)dx
导数是微分的系数(即变化的比例因子)。
微分是导数与自变量微小变化的乘积。
https://zhuanlan.zhihu.com/p/145620564
https://www.zhihu.com/question/39940688

- 可微
指函数在某点的增量可以表示为线性部分与高阶无穷小之和: Δy = f′(a)Δx + o(Δx)
其中 o(Δx) 是比 Δx 高阶的无穷小。
对一元函数，可微与可导完全等价。

- 可导(differentiable/derivable) vs. 可微(differentiable)
一元函数: 可导 ⇔ 可微。
多元函数: 可微 ⇒ 可导(偏导数存在)，但反之不成立。可微还要求函数在点的附近足够"光滑"。
多元函数: 可微比可偏导更强，要求函数能用线性映射良好近似。
可导性只关注沿坐标轴方向的变化率(偏导数)。
可微性要求函数在所有方向的变化率一致(即整体光滑)。
可微性的本质: 是用线性映射局部逼近函数时的误差为高阶无穷小。

- 光滑函数(smooth function)
光滑函数是指在其定义域内无限可微(infinitely differentiable)的函数，即该函数的各阶导数(一阶导、二阶导、三阶导...)在所有点都存在且连续。

- 高阶导数
函数 y=f(x) 的 n 阶导数，是指对 f(x) 连续求导 n 次后得到的导函数，记作: f⁽ⁿ⁾(x) 或 dⁿy/dxⁿ 或 Dⁿf(x)

=== 运算性质
- 线性性
- 乘法法则
- 除法法则
- 链式法则

=== 四则运算

=== 复合函数

=== 链式法则(chain rule)
==== 概念
链式法则可以用来微分复合函数。

链式法则是微积分中的核心规则，用于计算复合函数的导数。它通过将复杂函数的求导问题分解为多个简单函数的导数乘积，大幅简化了梯度计算过程。

在神经网络中，链式法则是反向传播算法(backpropagation)的数学基础，使得模型能够高效地更新权重。

==== 链式求导法则
链式求导法则(版本1):
如果 h(x) = f(g(x)); 那么 h'(x) = f'(g(x))g'(x)

链式求导法则(版本2):
如果 y 是 u 的函数, 并且 u 是 x 的函数, 那么dy/dx = (dy/du)(du/dx)

==== 单变量函数的链式法则
若 `y = f(g(x))` 由 `y = f(u)` 和 `u = g(x)` 复合而成，则导数为：

ifndef::env-github[]
[stem]
++++
\frac{dy}{dx} = \frac{dy}{du} \cdot \frac{du}{dx}
++++
endif::[]

ifdef::env-github[]
```math
\frac{dy}{dx} = \frac{dy}{du} \cdot \frac{du}{dx}
```
endif::[]

*步骤*：
ifndef::env-github[]
1. 计算外层函数 stem:[f(u)] 对 stem:[u] 的导数 stem:[\frac{df}{du}]。
2. 计算内层函数 stem:[g(x)] 对 stem:[x] 的导数 stem:[\frac{dg}{dx}]。
endif::[]
ifdef::env-github[]
1. 计算外层函数 $f(u)$ 对 $u$ 的导数 $\frac{df}{du}$。
2. 计算内层函数 $g(x)$ 对 $x$ 的导数 $\frac{dg}{dx}$。
endif::[]
3. 将两者相乘。

*示例*：
ifndef::env-github[]
设 stem:[y = \sin(2x)]，令 stem:[u = 2x]，则 stem:[y = \sin(u)]：
[stem]
++++
\frac{dy}{dx} = \cos(u) \cdot 2 = 2\cos(2x)
++++
endif::[]
ifdef::env-github[]
设 $y = \sin(2x)$，令 $u = 2x$，则 $y = \sin(u)$：
```math
\frac{dy}{dx} = \cos(u) \cdot 2 = 2\cos(2x)
```
endif::[]

==== 多元函数的链式法则
===== 全导数(单路径依赖)
ifndef::env-github[]
若 stem:[z = f(x(t), y(t))]，则 stem:[z] 对 stem:[t] 的全导数为：
[stem]
++++
\frac{dz}{dt} = \frac{\partial f}{\partial x} \cdot \frac{dx}{dt} + \frac{\partial f}{\partial y} \cdot \frac{dy}{dt}
++++
*含义*: stem:[z] 通过所有中间变量（stem:[x] 和 stem:[y]）依赖于 stem:[t]，需将所有路径的导数相加。
endif::[]
ifdef::env-github[]
若 $z = f(x(t), y(t))$，则 $z$ 对 $t$ 的全导数为：
```math
\frac{dz}{dt} = \frac{\partial f}{\partial x} \cdot \frac{dx}{dt} + \frac{\partial f}{\partial y} \cdot \frac{dy}{dt}
```
*含义*: $z$ 通过所有中间变量 $x$ 和 $y$ 依赖于 $t$，需将所有路径的导数相加。
endif::[]

===== 偏导数(多变量依赖)
ifndef::env-github[]
若 stem:[z = f(x(u,v), y(u,v))]，则对 stem:[u] 的偏导数为：
[stem]
++++
\frac{\partial z}{\partial u} = \frac{\partial f}{\partial x} \cdot \frac{\partial x}{\partial u} + \frac{\partial f}{\partial y} \cdot \frac{\partial y}{\partial u}
++++

*示例*：
设 stem:[z = x^2 y]，其中 stem:[x = t^2]，stem:[y = t^3]，则：
[stem]
++++
\frac{dz}{dt} = 2xy \cdot (2t) + x^2 \cdot (3t^2) = 4t^5 + 3t^6
++++
endif::[]

ifdef::env-github[]
若 $z = f(x(u,v), y(u,v))$，则对 $u$ 的偏导数为：
```math
\frac{\partial z}{\partial u} = \frac{\partial f}{\partial x} \cdot \frac{\partial x}{\partial u} + \frac{\partial f}{\partial y} \cdot \frac{\partial y}{\partial u}
```

*示例*：
设 $z = x^2 y$，其中 $x = t^2$, $y = t^3$，则：
```math
\frac{dz}{dt} = 2xy \cdot (2t) + x^2 \cdot (3t^2) = 4t^5 + 3t^6
```
endif::[]

==== 注意事项
- *变量区分*：明确偏导数∂与全导数d的使用场景。
- *依赖路径*：确保不遗漏任何中间变量的贡献。
- *高阶导数*：重复应用链式法则时需保持一致性。

==== 证明
《普林斯顿微积分读本》附录A.6.5

==== 标量向量矩阵
- 标量函数链式法则
- 向量函数的链式法则(Jacobian 形式)
- 标量对矩阵的链式法则
- 矩阵对矩阵的链式法则

=== 高阶导数

=== 导数的应用
==== 单调性
f′(x) > 0 时，f 单调递增；
f′(x) < 0 时，f 单调递减。

==== 极值点(extreme point)
若 f′(a) = 0 且 f′在 a 点变号，则 a 为极值点。

==== 凹凸性(convexity and concavity)
f′′(x) > 0 时，f 为凸函数；
f′′(x) < 0 时，f 为凹函数。

==== 驻点(critical point)
可导函数在某一点处取得极值的必要条件是一阶导数或者梯度为0，这个点即函数的驻点。

对于一元函数 y=f(x): 驻点是指函数的一阶导数等于零的点，即 f′(x)=0。
几何意义: 函数图像在该点的切线水平(斜率为零)。

对于多元函数 z=f(x,y): 驻点是所有偏导数同时为零(即梯度为零)的点，即 ∂f/∂x=0 且 ∂f/∂y=0
对应的是曲面上的"平坦"点(可能为极值或鞍点)。

驻点是函数导数为零的点，可能对应极值或鞍点，需结合高阶导数或其它方法进一步判断。

==== 拐点(inflection point)
f′′(a) = 0 且二阶导数在 a 点变号。
拐点是函数图像上曲率发生方向性变化的点，即函数从凹(Concave Up)变为凸(Concave Down)，或反之。
例如: f(x) = x³ 在 x = 0

==== 鞍点(saddle point)
鞍点是多元函数中的临界点(梯度为零)，但既非局部极小值也非局部极大值。
在二维情况下，鞍点沿某一方向是极小值，沿另一方向是极大值(形如马鞍)。
例如: f(x,y) = x²−y² 在 (0,0)，再例如 f(x,y) = xy 在 (0,0)

=== 常见函数的导数

=== 特殊函数的导数

=== 不可导的情况

=== 隐函数求导和相关变化率
- 隐函数(implicit function)
隐函数是指由方程 F(x,y)=0 定义的函数关系，其中 y 不能显式表示为 x 的解析式 y=f(x)，但仍然可以（在某些条件下）确定 y 是 x 的函数。

== 微分(differential calculus)

=== 微分中值定理和Talor展式
==== Roll定理
条件：
函数f(x)在闭区间[a, b]上连续
在开区间(a, b)内可导
区间端点函数值相等：f(a) = f(b)

结论：
存在至少一点ξ∈(a, b)，使得f'(ξ)=0

几何意义：
在满足条件的函数曲线上，至少存在一条水平切线。

==== Lagrange定理
条件：
函数f(x)在闭区间[a, b]上连续
在开区间(a, b)内可导

结论：
存在至少一点ξ∈(a, b)，使得：
f'(ξ) = [f(b) - f(a)]/(b - a)

几何意义：
曲线上至少存在一点，其切线与连接两端点的割线平行。

==== Cauchy定理
条件：
函数f(x)和g(x)在[a, b]上连续
在(a, b)内可导
g'(x)在(a, b)内不为零

结论：
存在ξ∈(a, b)，使得：
[f(b)-f(a)]/[g(b)-g(a)] = f'(ξ)/g'(ξ)

特殊情形：
当g(x)=x时，柯西定理退化为拉格朗日定理。

==== 参考
https://www.zhihu.com/tardis/zm/art/47436090?source_id=1003

=== 极值、零点、不等式
函数的微分与函数的单调性和凹凸性，乃至极值、零点和不等式有着紧密的联系。

==== 极值
===== 拉格朗日乘数法(Lagrange Multipliers)
- 概念
拉格朗日乘数法是一种用于求解多元函数在约束条件下的极值的方法。它将约束优化问题转化为无约束优化问题，通过引入拉格朗日乘子(Lagrange multiplier)来构造新的方程组，从而找到可能的极值点。

- 核心思想
在约束 g(x,y)=0 下，求函数 f(x,y) 的极值时，极值点处 ∇f 和 ∇g 共线(即梯度方向相同或相反)。因此存在标量 λ(拉格朗日乘子)，使得：∇f=λ∇g
结合约束条件 g(x,y)=0，即可解出极值点。

- 几何解释
在极值点处，目标函数 f 的等高线与约束曲线 g=0 相切，此时两者的法向量(即梯度 ∇f 和 ∇g)平行。

- 注意事项
** 拉格朗日乘数法仅给出必要条件，需进一步验证是否为极值。
** 若约束条件为不等式(如g(x,y)≤0)，需结合KKT条件(Karush-Kuhn-Tucker)推广。

== 多元函数
=== 基本概念
=== 连续函数
=== 多元函数的导数及微分
==== 偏导数(partial derivative)及偏微分(partial differential)
多元函数在某一方向上的变化率:
∂f/∂x 表示函数在 x 方向上的变化率（即曲面在 x 方向的切线斜率）。
∂f/∂y 表示函数在 y 方向上的变化率（即曲面在 y 方向的切线斜率）。
https://zh.wikipedia.org/wiki/%E5%81%8F%E5%AF%BC%E6%95%B0

==== 梯度(gradient)
===== 概念
梯度是微积分中的一个重要概念，它用于描述函数在某一点处沿各方向的变化率。

梯度是一个向量，其分量是多变量函数相对于其所有变量的偏导数。

===== 定义
对于多变量函数f(x, y, z)，其梯度是一个向量，由函数关于各变量的偏导数组成。具体地，梯度grad f = (∂f/∂x, ∂f/∂y, ∂f/∂z)，其中∂f/∂x、∂f/∂y、∂f/∂z分别表示函数f关于x、y、z的偏导数。

在二维空间中，梯度是一个二维向量，通常用∇f(x,y) = ∂f/∂x, ∂f/∂y表示。例如，对于二元函数f(x, y)，其梯度为(∂f/∂x, ∂f/∂y)。

===== 含义
https://en.wikipedia.org/wiki/Gradient#Motivation

===== Q&A
Q: 梯度的方向为什么是函数值增加最快的方向？
A: https://zhuanlan.zhihu.com/p/38525412

===== 方向导数(directional derivative)
====== 定义
ifndef::env-github[]
设 stem:[f: \mathbb{R}^n \to \mathbb{R}] 是多元函数，stem:[\mathbf{x}_0 \in \mathbb{R}^n] 是某点，stem:[\mathbf{v} \in \mathbb{R}^n] 是非零方向向量。
函数 stem:[f] 在 stem:[\mathbf{x}_0] 沿方向 stem:[\mathbf{v}] 的**方向导数**定义为：
[stem]
++++
D_{\mathbf{v}} f(\mathbf{x}_0) = \lim_{h \to 0} \frac{f(\mathbf{x}_0 + h \mathbf{v}) - f(\mathbf{x}_0)}{h}
++++
若极限存在，则称 stem:[f] 沿 stem:[\mathbf{v}] 方向可导。
endif::[]
ifdef::env-github[]
```math
设 f: \mathbb{R}^n \to \mathbb{R} 是多元函数，\mathbf{x}_0 \in \mathbb{R}^n 是某点，\mathbf{v} \in \mathbb{R}^n 是非零方向向量。函数 f 在 \mathbf{x}_0 沿方向 \mathbf{v} 的方向导数定义为：
```
```math
D_{\mathbf{v}} f(\mathbf{x}_0) = \lim_{h \to 0} \frac{f(\mathbf{x}_0 + h \mathbf{v}) - f(\mathbf{x}_0)}{h}
```
若极限存在，则称 $f$ 沿 $\mathbf{v}$ 方向可导。
endif::[]

====== 几何意义
方向导数表示函数在某点沿特定方向的瞬时变化率:

* 二维时: 沿斜线方向的变化率。
* 三维时: 沿空间任意方向的变化率。

====== 示例
====== 与梯度的关系

=== 高阶导数及微分
=== 极值 最大值及最小值

== 积分(integral calculus)
=== 不定积分

=== 定积分

=== 曲线积分 斯蒂尔切斯积分

=== 二重积分

=== 曲面面积 曲面积分

=== 三重积分及多重积分

=== 积分变换(integral transform)
==== 傅里叶变换(fourier transform)
http://www.dspguide.com/pdfbook.htm
https://www.cnblogs.com/v-July-v/archive/2011/02/20/1983676.html
https://tracholar.github.io/math/2017/03/12/fourier-transform.html
https://github.com/Jezzamonn/fourier

== 级数(series)
=== 概念
https://en.wikipedia.org/wiki/Series_(mathematics)

=== 泰勒多项式(Taylor Polynomial)与泰勒级数(Taylor series)
==== 概念
泰勒多项式与泰勒级数使用多项式(有限项或无限项)来逼近复杂的函数(如三角函数、指数函数、对数函数等)。
泰勒展开(Taylor expansion)是将一个函数在某一点附近用多项式逼近的方法。

麦克劳林级数(Maclaurin series):
a = 0 时的泰勒展开

余项(Remainder)代表多项式与真实函数值之间的误差。
余项的形式: 拉格朗日余项(Lagrange Remainder)、佩亚诺余项(Peano Remainder)
ifndef::env-github[]
佩亚诺余项 latexmath:[o((x-a)^n)] 是局部概念，适合微积分（极限）。
拉格朗日余项 latexmath:[\frac{f^{(n+1)}(\xi)}{(n+1)!} (x-a)^{n+1}] 是区间概念，适合数值分析和级数理论。
endif::[]
ifdef::env-github[]
佩亚诺余项 $o((x-a)^n)$ 是局部概念，适合微积分（极限）。
拉格朗日余项 $\frac{f^{(n+1)}(\xi)}{(n+1)!} (x-a)^{n+1}$ 是区间概念，适合数值分析和级数理论。
endif::[]

Q: 为什么选多项式？
因为多项式是人类最容易处理的函数：只需要加、减、乘三种运算，计算机也只会算这个。求导和积分也是机械化的操作。

Q: 近似的标准是什么？ 如果在某一点（比如x=0），希望近似的多项式和原来的函数：
1、值相等： f(0)≈P(0)。
2、变化趋势相同（一阶导数相等）：在 0 点附近，函数是上升还是下降？速度要一样。 f′(0)≈P′(0)。
3、弯曲程度相同（二阶导数相等）：如果一阶导数相同，但弯曲方向不同（一个凸一个凹），它们很快就会分道扬镳。 f′′(0)≈P′′(0)。
4、加速度的变化率也相同（三阶导数相等）……以此类推。

Q: 什么函数能用泰勒级数表示，什么函数不能
能展开成泰勒级数的函数，必须是实解析函数。它要求函数不仅是无限光滑的，而且其局部信息（各阶导数）必须强到足以唯一确定其邻域内的全局行为。
不能展开成泰勒级数的函数，主要是那些无限光滑但非解析的函数。它们揭示了“无限可导”这一光滑性条件，比“能由幂级数表示”这一解析性条件要弱得多。光滑性是一个“局部逐点”性质，而解析性是一个“局部整体”性质。

==== 泰勒展开式的推导
===== 概念
待定系数法：
侧重于假设多项式形式，利用导数在 x=a 处的值匹配来确定系数。它直接给出了级数的形式，但无法直接解释余项为什么是那个样子。

积分法：
侧重于通过反复应用微积分基本定理，自然地推导出泰勒多项式和积分形式的余项。虽然计算稍复杂，但揭示了泰勒公式与微积分基本定理之间深刻的联系，并且能更严谨地处理余项估计问题。

===== 待定系数法
设 f(x) 在 x = a 处有任意阶导数。我们想求一个多项式 P_n(x) 来逼近它：
ifndef::env-github[]
[stem]
++++
P_n(x) = c_0 + c_1(x-a) + c_2(x-a)^2 + c_3(x-a)^3 + \dots + c_n(x-a)^n
++++
endif::[]
ifdef::env-github[]
```math
P_n(x) = c_0 + c_1(x-a) + c_2(x-a)^2 + c_3(x-a)^3 + \dots + c_n(x-a)^n
```
endif::[]
这里的 c_0, c_1, ..., c_n 就是我们要确定的系数。

我们希望 P_n(x) 和 f(x) 在 x = a 处的函数值以及直到 n 阶的导数值都相等：
ifndef::env-github[]
[stem]
++++
P_n(a) = f(a), \quad P_n'(a) = f'(a), \quad P_n''(a) = f''(a), \dots, \quad P_n^{(n)}(a) = f^{(n)}(a)
++++
endif::[]
ifdef::env-github[]
```math
P_n(a) = f(a), \quad P_n'(a) = f'(a), \quad P_n''(a) = f''(a), \dots, \quad P_n^{(n)}(a) = f^{(n)}(a)
```
endif::[]

求 c_0: 令 x = a 代入 P_n(x)：
ifndef::env-github[]
[stem]
++++
P_n(a) = c_0 = f(a) \quad \Rightarrow \quad c_0 = f(a)
++++
endif::[]
ifdef::env-github[]
```math
P_n(a) = c_0 = f(a) \quad \Rightarrow \quad c_0 = f(a)
```
endif::[]

求 c_1: 对 P_n(x) 求一阶导：
ifndef::env-github[]
[stem]
++++
P_n'(x) = c_1 + 2c_2(x-a) + 3c_3(x-a)^2 + \dots
++++
endif::[]
ifdef::env-github[]
```math
P_n'(x) = c_1 + 2c_2(x-a) + 3c_3(x-a)^2 + \dots
```
endif::[]

令 x = a：
ifndef::env-github[]
[stem]
++++
P_n'(a) = c_1 = f'(a) \quad \Rightarrow \quad c_1 = f'(a)
++++
endif::[]
ifdef::env-github[]
```math
P_n'(a) = c_1 = f'(a) \quad \Rightarrow \quad c_1 = f'(a)
```
endif::[]

求 c_2: 对 P_n(x) 求二阶导：
ifndef::env-github[]
[stem]
++++
P_n''(x) = 2c_2 + 3\cdot2\cdot c_3(x-a) + \dots
++++
endif::[]
ifdef::env-github[]
```math
P_n''(x) = 2c_2 + 3\cdot2\cdot c_3(x-a) + \dots
```
endif::[]
令 x = a：
ifndef::env-github[]
[stem]
++++
P_n''(a) = 2c_2 = f''(a) \quad \Rightarrow \quad c_2 = \frac{f''(a)}{2}
++++
endif::[]
ifdef::env-github[]
```math
P_n''(a) = 2c_2 = f''(a) \quad \Rightarrow \quad c_2 = \frac{f''(a)}{2}
```
endif::[]

求 c_3: 对 P_n(x) 求三阶导：
ifndef::env-github[]
[stem]
++++
P_n'''(x) = 3\cdot2\cdot1\cdot c_3 + \dots
++++
endif::[]
ifdef::env-github[]
```math
P_n'''(x) = 3\cdot2\cdot1\cdot c_3 + \dots
```
endif::[]
令 x = a：
ifndef::env-github[]
[stem]
++++
P_n'''(a) = 3! \cdot c_3 = f'''(a) \quad \Rightarrow \quad c_3 = \frac{f'''(a)}{3!}
++++
endif::[]
ifdef::env-github[]
```math
P_n'''(a) = 3! \cdot c_3 = f'''(a) \quad \Rightarrow \quad c_3 = \frac{f'''(a)}{3!}
```
endif::[]

归纳出通项公式：
对于第 k 项 c_k (x-a)^k，每求一次导数，系数就会乘以下标，直到求完 k 阶导后，该项变为常数 k!·c_k。因此：
ifndef::env-github[]
[stem]
++++
P_n^{(k)}(a) = k! \cdot c_k = f^{(k)}(a) \quad \Rightarrow \quad c_k = \frac{f^{(k)}(a)}{k!}
++++
endif::[]
ifdef::env-github[]
```math
P_n^{(k)}(a) = k! \cdot c_k = f^{(k)}(a) \quad \Rightarrow \quad c_k = \frac{f^{(k)}(a)}{k!}
```
endif::[]

将系数代回原式，得到：
ifndef::env-github[]
[stem]
++++
f(x) \approx P_n(x) = f(a) + f'(a)(x-a) + \frac{f''(a)}{2!}(x-a)^2 + \frac{f'''(a)}{3!}(x-a)^3 + \dots + \frac{f^{(n)}(a)}{n!}(x-a)^n
++++
endif::[]
ifdef::env-github[]
```math
f(x) \approx P_n(x) = f(a) + f'(a)(x-a) + \frac{f''(a)}{2!}(x-a)^2 + \frac{f'''(a)}{3!}(x-a)^3 + \dots + \frac{f^{(n)}(a)}{n!}(x-a)^n
```
endif::[]

当 n → ∞，如果级数收敛，我们就得到了泰勒级数：
ifndef::env-github[]
[stem]
++++
f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n!} (x-a)^n
++++
endif::[]
ifdef::env-github[]
```math
f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(a)}{n!} (x-a)^n
```
endif::[]
其中特别地，如果 a = 0，则称为麦克劳林级数。

===== 积分法
从微积分基本定理出发：
ifndef::env-github[]
[stem]
++++
f(x) = f(a) + \int_a^x f'(t) dt
++++
endif::[]
ifdef::env-github[]
```math
f(x) = f(a) + \int_a^x f'(t)dt
```
endif::[]

对被积函数 f'(t) 再次使用该定理
设 t 为积分变量，对 f'(t) 应用同样的公式（从 a 到 t）：
ifndef::env-github[]
[stem]
++++
f'(t) = f'(a) + \int_a^t f''(u)du
++++
endif::[]
ifdef::env-github[]
```math
f'(t) = f'(a) + \int_a^t f''(u)du
```
endif::[]

将 f'(t) 代入第 1 步的积分中：
ifndef::env-github[]
[stem]
++++
f(x) = f(a) + \int_a^x \left[ f'(a) + \int_a^t f''(u)du \right] dt
++++
endif::[]
ifdef::env-github[]
```math
f(x) = f(a) + \int_a^x \left[ f'(a) + \int_a^t f''(u)du \right] dt
```
endif::[]

交换积分顺序并计算：注意 f'(a) 是常数。
ifndef::env-github[]
[stem]
++++
f(x) = f(a) + f'(a) \int_a^x dt + \int_a^x \int_a^t f''(u)dudt
++++
endif::[]
ifdef::env-github[]
```math
f(x) = f(a) + f'(a) \int_a^x dt + \int_a^x \int_a^t f''(u)dudt
```
endif::[]

计算第一项积分：
ifndef::env-github[]
[stem]
++++
\int_a^x dt = (x - a)
++++
endif::[]
ifdef::env-github[]
```math
\int_a^x dt = (x - a)
```
endif::[]

第二项是一个二重积分。积分区域是 a ≤ u ≤ t ≤ x。交换积分顺序：
先对 t 积分（从 u 到 x），再对 u 积分（从 a 到 x）：

ifndef::env-github[]
[stem]
++++
\int_a^x \int_a^t f''(u) du dt = \int_a^x \int_u^x f''(u) dt du = \int_a^x f''(u) \cdot (x-u) du
++++
endif::[]
ifdef::env-github[]
```math
\int_a^x \int_a^t f''(u) du dt = \int_a^x \int_u^x f''(u) dt du = \int_a^x f''(u) \cdot (x-u) du
```
endif::[]

所以目前有：
ifndef::env-github[]
[stem]
++++
f(x) = f(a) + f'(a)(x-a) + \int_a^x (x-u) f''(u) du
++++
endif::[]
ifdef::env-github[]
```math
f(x) = f(a) + f'(a)(x-a) + \int_a^x (x-u) f''(u) du
```
endif::[]

重复该过程
令 R_2 = ∫_a^x (x-u) f''(u) du。对被积函数中的 f''(u) 再次使用微积分基本定理：
ifndef::env-github[]
[stem]
++++
f''(u) = f''(a) + \int_a^u f'''(v) dv
++++
endif::[]
ifdef::env-github[]
```math
f''(u) = f''(a) + \int_a^u f'''(v) dv
```
endif::[]

代入：

ifndef::env-github[]
[stem]
++++
R_2 = \int_a^x (x-u) \left[ f''(a) + \int_a^u f'''(v) dv \right] du
++++
endif::[]
ifdef::env-github[]
```math
R_2 = \int_a^x (x-u) \left[ f''(a) + \int_a^u f'''(v) dv \right] du
```
endif::[]

ifndef::env-github[]
[stem]
++++
R_2 = f''(a) \int_a^x (x-u) du + \int_a^x \int_a^u (x-u) f'''(v) dv du
++++
endif::[]
ifdef::env-github[]
```math
R_2 = f''(a) \int_a^x (x-u) du + \int_a^x \int_a^u (x-u) f'''(v) dv du
```
endif::[]

计算第一项积分：
ifndef::env-github[]
[stem]
++++
\int_a^x (x-u) du = \frac{(x-a)^2}{2}
++++
endif::[]
ifdef::env-github[]
```math
\int_a^x (x-u) du = \frac{(x-a)^2}{2}
```
endif::[]

所以该项为 f''(a)(x-a)^2/2。

第二项二重积分区域为 a ≤ v ≤ u ≤ x，交换顺序：
ifndef::env-github[]
[stem]
++++
\int_a^x \int_a^u (x-u) f'''(v) dv du = \int_a^x \int_v^x (x-u) f'''(v) du dv
++++
endif::[]
ifdef::env-github[]
```math
\int_a^x \int_a^u (x-u) f'''(v) dv du = \int_a^x \int_v^x (x-u) f'''(v) du dv
```
endif::[]

先对 u 积分：
ifndef::env-github[]
[stem]
++++
\int_v^x (x-u) du = \left[ xu - \frac{u^2}{2} \right]_v^x = \frac{(x-v)^2}{2}
++++
endif::[]
ifdef::env-github[]
```math
\int_v^x (x-u) du = \left[ xu - \frac{u^2}{2} \right]_v^x = \frac{(x-v)^2}{2}
```
endif::[]

因此：
ifndef::env-github[]
[stem]
++++
f(x) = f(a) + f'(a)(x-a) + \frac{f''(a)}{2!}(x-a)^2 + \int_a^x \frac{(x-v)^2}{2!} f'''(v) dv
++++
endif::[]
ifdef::env-github[]
```math
f(x) = f(a) + f'(a)(x-a) + \frac{f''(a)}{2!}(x-a)^2 + \int_a^x \frac{(x-v)^2}{2!} f'''(v) dv
```
endif::[]

归纳得到余项形式：
继续这个过程 n 次，我们会得到：
ifndef::env-github[]
[stem]
++++
f(x) = \sum_{k=0}^{n} \frac{f^{(k)}(a)}{k!}(x-a)^k + R_{n+1}(x)
++++
endif::[]
ifdef::env-github[]
```math
f(x) = \sum_{k=0}^{n} \frac{f^{(k)}(a)}{k!}(x-a)^k + R_{n+1}(x)
```
endif::[]

其中余项 R_{n+1}(x) 为：

ifndef::env-github[]
[stem]
++++
R_{n+1}(x) = \int_a^x \frac{(x-t)^n}{n!} f^{(n+1)}(t) \, dt
++++
endif::[]
ifdef::env-github[]
```math
R_{n+1}(x) = \int_a^x \frac{(x-t)^n}{n!} f^{(n+1)}(t) \, dt
```
endif::[]

这个形式的余项叫做 积分型余项。

==== 佩亚诺余项(Peano Remainder)
如果函数 f 在点 a 处具有 n 阶导数，那么在 a 的邻域内，泰勒公式可以写成：
ifndef::env-github[]
[stem]
++++
f(x) = \sum_{k=0}^{n} \frac{f^{(k)}(a)}{k!} (x-a)^k + o\left((x-a)^n\right) \quad (x \to a)
++++
endif::[]
ifdef::env-github[]
```math
f(x) = \sum_{k=0}^{n} \frac{f^{(k)}(a)}{k!} (x-a)^k + o\left((x-a)^n\right) \quad (x \to a)
```
endif::[]
这里的 o((x-a)^n) 就是佩亚诺余项。

数学含义：
符号 o((x-a)^n) 读作 "小欧"，它表示一个比 (x-a)^n 更高阶的无穷小。具体来说，它满足：
ifndef::env-github[]
[stem]
++++
\lim_{x \to a} \frac{R_n(x)}{(x-a)^n} = 0
++++
endif::[]
ifdef::env-github[]
```math
\lim_{x \to a} \frac{R_n(x)}{(x-a)^n} = 0
```
endif::[]

物理意义：
当 x 无限接近 a 时，误差 R_n(x) 趋近于 0 的速度，比 (x-a)^n 趋近于 0 的速度还要快。
优点：条件弱（只需要 f 在 a 点有 n 阶导数即可），形式简单。
缺点：只能知道误差在 a 点附近很小，但无法具体估算当 x 离 a 有一定距离（比如 x=1）时，误差到底是多少。

适用场景：
主要用于求极限。例如，求 lim_{x→0} (sin x - x)/x^3 时，将 sin x = x - x^3/3! + o(x^3) 代入，o(x^3) 直接忽略即可。

==== 拉格朗日余项(Lagrange Remainder)

==== 多元函数的展开

==== 参考
https://en.wikipedia.org/wiki/Taylor_series

=== 幂级数

=== 三角级数
==== 周期函数
==== 谐振的叠加
==== 复数表示法
==== 傅立叶级数
==== 傅立叶级数的例
==== 收敛性的进一步讨论
==== 三角多项式和有理多项式的近似法
==== 参考
《微积分和数学分析引论》第一卷第8章

== 微分方程(differential equation)

== 应用
https://www.cnblogs.com/edward-bian/p/5237962.html

== 工具
=== 等高线地图-可视化多元函数
https://zh.khanacademy.org/math/multivariable-calculus/thinking-about-multivariable-function/ways-to-represent-multivariable-functions/a/contour-maps
https://zhuanlan.zhihu.com/p/40520573

== 参考
《微积分五讲》龚昇
《The Calculus Lifesaver》中文: 普林斯顿微积分读本(修订版)
《Calculus 8th》James Stewart
《Thomas Calculus, 14e》Geroge B Thomas 中: 托马斯微积分
《Calculus, 11e》Ron Larson
《微积分入门（修订版）》小平邦彦
《微积分学教程》第8版共3卷 菲赫金哥尔茨
《简明微积分》第4版 龚昇
《微积分进阶》楼红卫
《微积分和数学分析引论》共2卷 英: Introduction to Calculus and Analysis
《南开讲义》陈省身
《Vector Calculus, Linear Algebra, and Differential Forms 5th》John H·Hubbard
