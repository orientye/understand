:toc:
:toclevels: 4
:hardbreaks-option:

== 一致性

=== 一致性模型
==== 强一致性模型
===== 线性一致性(Linearizable Consistency)/严格一致性(Strict Consistency)/原子一致性(Atomic Consistency)

    条件:
    1. 任何一次读都能读取到某个数据最近的一次写的数据。
    2. 所有进程看到的操作顺序都跟全局时钟下的顺序一致。

===== 顺序一致性(Sequential Consistency)

    顺序一致性是Lamport在解决多处理器系统共享存储器时首次提出来的
    条件:
    1. 任何一次读写操作都是按照某种特定的顺序。
    2. 所有进程看到的读写操作顺序都保持一致。

==== 弱一致性模型
===== 因果一致性(Causal Consistency)

    是一种弱化的顺序一致性模型
    因果关系: 如果事件B是由事件A引起的或者受事件A的影响, 那么这两个事件就具有因果关系。
    举个分布式数据库的示例, 假设进程P1对数据项x进行了写操作, 然后进程P2先读取了x, 然后对y进行了写操作, 
    那么对x的读操作和对 y的写操作就具有潜在的因果关系, 因为y的计算可能依赖于P2读取到x的值(也就是P1写的值)。
    另一方面, 如果两个进程同时对两个不同的数据项进行写操作, 那么这两个事件就不具备因果关系。
    条件：
    1. 所有进程必须以相同的顺序看到具有因果关系的读写操作。
    2. 不同进程可以以不同的顺序看到并发的读写操作。

    Q: 为什么说因果一致性是一种弱化的顺序一致性模型? 
    A: 顺序一致性虽然不保证事件发生的顺序跟实际发生的保持一致, 但是它能够保证所有进程看到的读写操作顺序是一样的。
    而因果一致性更进一步弱化了顺序一致性中对读写操作顺序的约束, 仅保证有因果关系的读写操作有序, 没有因果关系的读写操作(并发事件)则不做保证。
    也就是说如果是无因果关系的数据操作不同进程看到的值是有可能是不一样, 而有因果关系的数据操作不同进程看到的值保证是一样的。

===== 最终一致性(Eventual Consistency)

    是更加弱化的一致性模型
    因果一致性起码还保证了有因果关系的数据不同进程读取到的值保证是一样的, 而最终一致性只保证所有副本的数据最终在某个时刻会保持一致。
    1. "最终"到底是多久？通常来说, 实际运行的系统需要能够保证提供一个有下限的时间范围。
    2. 多副本之间对数据更新采用什么样的策略？一段时间内可能数据可能多次更新, 到底以哪个数据为准？一个常用的策略以时间戳最新的数据为准。

    由于最终一致性对数据一致性的要求比较低, 在对性能要求高的场景中是经常使用的一致性模型。

===== 以客户端为中心的一致性(Client-centric Consistency)

前面我们讨论的一致性模型都是针对数据存储的多副本之间如何做到一致性, 考虑这么一种场景：在最终一致性的模型中, 如果客户端在数据不同步的时间窗口内访问不同的副本的同一个数据, 会出现读取同一个数据却得到不同的值的情况。为了解决这个问题, 有人提出了以客户端为中心的一致性模型。以客户端为中心的一致性为单一客户端提供一致性保证, 保证该客户端对数据存储的访问的一致性, 但是它不为不同客户端的并发访问提供任何一致性保证。
举个例子：客户端A在副本M上读取x的最新值为1, 假设副本M挂了, 客户端A连接到副本N上, 此时副本 N上面的x值为旧版本的0, 那么一致性模型会保证客户端A读取到的x的值为1, 而不是旧版本的0。一种可行的方案就是给数据x加版本标记, 同时客户端A会缓存x的值, 通过比较版本来识别数据的新旧, 保证客户端不会读取到旧的值。

以客户端为中心的一致性包含了四种子模型:

    1. 单调读一致性(Monotonic-read Consistency)

        如果一个进程读取数据项x的值, 那么该进程对于x后续的所有读操作要么读取到第一次读取的值要么读取到更新的值。
        即保证客户端不会读取到旧值。

    2. 单调写一致性(Monotonic-write Consistency)

        一个进程对数据项 x 的写操作必须在该进程对x执行任何后续写操作之前完成。
        即保证客户端的写操作是串行的。

    3. 读写一致性(Read-your-writes Consistency)

        一个进程对数据项 x 执行一次写操作的结果总是会被该进程对 x 执行的后续读操作看见。
        即保证客户端能读到自己最新写入的值。
        
    4. 写读一致性(Writes-follow-reads Consistency)
    
        同一个进程对数据项 x 执行的读操作之后的写操作, 保证发生在与 x 读取值相同或比之更新的值上。
        即保证客户端对一个数据项的写操作是基于该客户端最新读取的值。

参考: https://en.wikipedia.org/wiki/Consistency_model
参考: https://developer.aliyun.com/article/693187

=== 一致性与共识
一致性(Consistency)通常指指分布式系统中多个副本对外呈现的数据的状态。
共识(Consensus)则描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。

一致性描述的是结果状态，共识则是一种手段。
达成某种共识并不意味着就保障了(强)一致性。只能说共识机制，能够实现某种程度上的一致性。

一致性的实现，核心过程往往需要通过共识算法来达成。
但整个系统的一致性不仅仅取决于共识算法, 例如可能还依赖客户端策略。

共识的应用:
逻辑时间的共识, 用于决定时间发生的顺序
互斥性的共识, 用于决定谁正拥有访问的资源
协调者的共识, 用于决定谁是当前的leader

=== 共识算法
==== 2PC
2PC: Two-Phase Commit

===== 过程

    Coordinator                                         Participant
                             QUERY TO COMMIT
                    -------------------------------->
                               VOTE YES/NO             prepare/abort
                    <--------------------------------
    commit/abort             COMMIT/ROLLBACK
                    -------------------------------->
                              ACKNOWLEDGMENT            commit/abort
                    <--------------------------------  
    end
    
    1 准备阶段(prepare phase):
    事务管理器(协调者)给每个参与者发送prepare消息, 每个参与者在本地执行事务, 并写本地的undo和redo日志, 此时事务并未提交。
    undo日志是记录修改前的数据, 用于回滚
    redo日志是记录修改后的数据, 用于提交事务后写入数据文件
    参与者会锁定资源。

    2 提交阶段(commit phase):
    如果事务管理器(协调者)收到了参与者的执行失败或者超时消息时, 直接给每个参与者发送回滚消息;
    否则, 发送提交消息。
    参与者根据指令执行提交或回滚操作, 并释放事务处理过程中使用的锁资源。

===== 特点
- 优点: 原理简单, 实现方便
- 缺点: 阻塞, 单点, 数据不一致
- 应用: 数据库, JTA(Java Transaction API)等, Google Percolator

Q: 如何理解阻塞?
A: 参与者需要等待两个阶段都结束了, 才会释放资源锁, 这也是2PC性能较差的原因。

Q: 如何理解单点？
A: 事务管理器(协调者)存在单点。

Q: 如何理解数据不一致?
A: 协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个系统便出现了数据不一致性的现象。

===== 解决方案
- XA方案

    2PC的传统方案是在数据库层面实现的, MySQL, Oracle等都支持2PC协议, 为了统一标准, 国际开放标准组织Open Group定义了分布式事务处理模型DTP(Distributed Transaction Processing Reference Model).
    DTP模型定义TM(事务管理器)和RM(资源管理器, 即参与者)之间的接口规范叫XA, 可以简单的理解为数据库提供的2PC接口协议。
    基于数据库的XA协议来实现2PC称为XA方案。

- Seata方案

    http://seata.io/zh-cn/docs/dev/mode/xa-mode.html

- MySQL中2PC的运用
- Google Percolator作了哪些改进?
- TiDB中Percolator的运用

参考:
https://zhuanlan.zhihu.com/p/35616810
https://database.51cto.com/art/202101/640577.htm
https://www.cnblogs.com/hustcat/p/3577584.html

==== 3PC
3PC: Three-Phase Commit
- 优点: 降低了阻塞问题
- 缺点: 同样存在很多问题

==== PBFT
PBFT: Practical Byzantine Fault Tolerance
分布式系统中有两种Fault: Crash Fault 与 Byzantine Fault

参考: https://cloud.tencent.com/developer/news/202455

==== Gossip
Gossip protocol也叫Epidemic Protocol(流行病协议)

Gossip过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。

使用Gossip的典型系统: bitcoin(bitcoin除了gossip还依赖pow共识)

- 优点:

    扩展性性好
        网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。
    容错性强
        网络中任何节点的宕机和重启都不会影响Gossip消息的传播，Gossip协议具有天然的分布式系统容错特性。
    去中心化
        Gossip协议不要求任何中心节点，所有节点都可以是对等的
        任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。
    一致性收敛
        Gossip协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播
        因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了logN
    简单
        实现Gossip十分简单

- 缺点:

    消息延迟
        节点随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网，不可避免的造成消息延迟。
    消息冗余
        节点定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤
        因此不可避免地引起同一节点多次接收同一消息，增加消息处理的压力。
        一次通信会对网路带宽、CUP资源造成很大的负载，而这些负载又受限于通信频率，该频率又影响着算法收敛的速度。
    拜占庭问题
        如果有一个恶意传播消息的节点，Gossip协议的分布式系统就会出问题。

参考: https://zhuanlan.zhihu.com/p/41228196

==== Paxos

==== Raft
Raft和Paxos最大的不同之处就在于Raft的强领导特性：Raft使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在Paxos中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。

像Raft一样，VR和ZooKeeper也是基于领导人的，因此他们也拥有一些Raft的优点。但是，Raft比VR和ZooKeeper拥有更少的机制因为 Raft尽可能的减少了非领导人的功能。例如，Raft中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目RPC是向外发送的。在VR中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据ZooKeeper公开的资料看，它的日志条目也是双向传输的，但是它的实现更像Raft。

Q: Raft的实现?
Q: Raft实现的正确性?

参考: http://thesecretlivesofdata.com/raft/
参考: https://raft.github.io/raft.pdf
参考: https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md

==== Quorum NWR

==== ZAB