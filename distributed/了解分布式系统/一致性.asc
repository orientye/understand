== 一致性
:hardbreaks-option:

=== 一致性模型
==== 强一致性模型
⦁ 线性一致性(Linearizable Consistency)/严格一致性(Strict Consistency)或者原子一致性(Atomic Consistency)

    条件:
    1. 任何一次读都能读取到某个数据最近的一次写的数据。
    2. 所有进程看到的操作顺序都跟全局时钟下的顺序一致。

⦁ 顺序一致性(Sequential Consistency)

    顺序一致性是Lamport在解决多处理器系统共享存储器时首次提出来的
    条件:
    1. 任何一次读写操作都是按照某种特定的顺序。
    2. 所有进程看到的读写操作顺序都保持一致。

==== 弱一致性模型
⦁ 因果一致性(Causal Consistency)

    是一种弱化的顺序一致性模型
    因果关系: 如果事件B是由事件A引起的或者受事件A的影响, 那么这两个事件就具有因果关系。
    举个分布式数据库的示例, 假设进程P1对数据项x进行了写操作, 然后进程P2先读取了x, 然后对y进行了写操作, 
    那么对x的读操作和对 y的写操作就具有潜在的因果关系, 因为y的计算可能依赖于P2读取到x的值(也就是 P1写的值)。
    另一方面, 如果两个进程同时对两个不同的数据项进行写操作, 那么这两个事件就不具备因果关系。
    条件：
    1. 所有进程必须以相同的顺序看到具有因果关系的读写操作。
    2. 不同进程可以以不同的顺序看到并发的读写操作。

    Q: 为什么说因果一致性是一种弱化的顺序一致性模型? 
    A: 顺序一致性虽然不保证事件发生的顺序跟实际发生的保持一致, 但是它能够保证所有进程看到的读写操作顺序是一样的。
    而因果一致性更进一步弱化了顺序一致性中对读写操作顺序的约束, 仅保证有因果关系的读写操作有序, 没有因果关系的读写操作(并发事件）则不做保证。
    也就是说如果是无因果关系的数据操作不同进程看到的值是有可能是不一样, 而有因果关系的数据操作不同进程看到的值保证是一样的。

⦁ 最终一致性(Eventual Consistency)

    是更加弱化的一致性模型
    因果一致性起码还保证了有因果关系的数据不同进程读取到的值保证是一样的, 而最终一致性只保证所有副本的数据最终在某个时刻会保持一致。
    1. "最终"到底是多久？通常来说, 实际运行的系统需要能够保证提供一个有下限的时间范围。
    2. 多副本之间对数据更新采用什么样的策略？一段时间内可能数据可能多次更新, 到底以哪个数据为准？一个常用的数据更新策略就是以时间戳最新的数据为准。

    由于最终一致性对数据一致性的要求比较低, 在对性能要求高的场景中是经常使用的一致性模型。

⦁ 以客户端为中心的一致性(Client-centric Consistency)

前面我们讨论的一致性模型都是针对数据存储的多副本之间如何做到一致性, 考虑这么一种场景：在最终一致性的模型中, 如果客户端在数据不同步的时间窗口内访问不同的副本的同一个数据, 会出现读取同一个数据却得到不同的值的情况。为了解决这个问题, 有人提出了以客户端为中心的一致性模型。以客户端为中心的一致性为单一客户端提供一致性保证, 保证该客户端对数据存储的访问的一致性, 但是它不为不同客户端的并发访问提供任何一致性保证。
举个例子：客户端A在副本M上读取x的最新值为1, 假设副本M挂了, 客户端A连接到副本N上, 此时副本 N上面的x值为旧版本的0, 那么一致性模型会保证客户端A读取到的x的值为1, 而不是旧版本的0。一种可行的方案就是给数据x加版本标记, 同时客户端A会缓存x的值, 通过比较版本来识别数据的新旧, 保证客户端不会读取到旧的值。

以客户端为中心的一致性包含了四种子模型:

    1. 单调读一致性(Monotonic-read Consistency)

        如果一个进程读取数据项x的值, 那么该进程对于x后续的所有读操作要么读取到第一次读取的值要么读取到更新的值。
        即保证客户端不会读取到旧值。

    2. 单调写一致性(Monotonic-write Consistency)

        一个进程对数据项 x 的写操作必须在该进程对x执行任何后续写操作之前完成。
        即保证客户端的写操作是串行的。

    3. 读写一致性(Read-your-writes Consistency)

        一个进程对数据项 x 执行一次写操作的结果总是会被该进程对 x 执行的后续读操作看见。
        即保证客户端能读到自己最新写入的值。
        
    4. 写读一致性(Writes-follow-reads Consistency)
    
        同一个进程对数据项 x 执行的读操作之后的写操作, 保证发生在与 x 读取值相同或比之更新的值上。
        即保证客户端对一个数据项的写操作是基于该客户端最新读取的值。

参考: https://en.wikipedia.org/wiki/Consistency_model
参考: https://developer.aliyun.com/article/693187

=== 一致性与共识
一致性(Consistency)通常指指分布式系统中多个副本对外呈现的数据的状态。
共识(Consensus)则描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。

一致性描述的是结果状态，共识则是一种手段。
达成某种共识并不意味着就保障了(强)一致性。只能说共识机制，能够实现某种程度上的一致性。

一致性的实现，核心过程往往需要通过共识算法来达成。
但整个系统的一致性不仅仅取决于共识算法, 例如可能还依赖客户端策略。

=== 共识算法
==== 2PC

==== 3PC

==== BFT

==== PBFT

==== Gossip

==== Paxos

==== Raft
参考: https://raft.github.io/raft.pdf
参考: https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md

==== ZAB