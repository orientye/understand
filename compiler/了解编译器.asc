= 了解编译器
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com
<<<

== 概览

=== 概念
▪  符号表(symbol table)

    符号表是一种供编译器保存有关源程序构造的各种信息的数据结构。
    通常由语法分析器来创建，有些情况下词法分析器在碰到组成一个词素的字符串时也可以立即建立一个符号表条目。

▪  CPS(Continuation-Passing Style)

    https://en.wikipedia.org/wiki/Continuation-passing_style

== 词法分析
词法分析(lexical analysis)也称扫描(scanning)。

=== 作用
▪ 词法分析将输入的程序按照构词规则分解成一系列token(词法单元)符号。

▪ token通常分为以下类型:
(1) 关键字 是由程序语言定义的具有固定意义的标识符
(2) 标识符 用来表示各种名字，如变量名、数组名、函数名等
(3) 常数 常数的类型一般有整型、实型、布尔型、字符串类型等
(4) 运算符 如+、-、*、/等
(5) 界符 如逗号、分号、括号等

▪ 输出:
通常表示为二元式列表：[<token-name, attribute-value>]

▪ 词法分析是编译过程中的一个阶段，可以在语法分析前进行独自作为一遍，也可以和语法分析结合在一起作为一遍。

=== 词法单元的规约
正则表达式是一种用来描述词素模式的重要表示方法。
虽然正则表达式不能表达出所有可能的模式，但是可以高效地描述在处理词法单元时要用到的模式类型。

=== 词法单元的识别
状态转换图(transition diagram)

=== 词法分析器生成工具Lex

=== 有穷自动机
FA: Finite Automaton 有穷自动机
DFA: Deterministic Finite Automaton 确定的有穷自动机
NFA: Nondeterministic Finite Automaton 非确定的有穷自动机

有穷自动机可以看作是状态转换图的形式化表示。
与状态转换图不同，有穷自动机既可以在输入字符上执行转换，也可以在空输入上执行转换。

=== 从正则表达式到自动机
可以将任意一个正则表达式转换为一个大小基本相同的NFA；
任何NFA可以转换为一个代表相同模式的DFA，虽然最坏的情况下自动机的大小会以指数级增长，但在常见的程序设计语言中尚未碰到这些情况；
可以将任意一个NFA或DFA会转化为一个正则表达式。

=== 词法分析器生成工具的设计

=== 基于DFA的模式匹配器的优化

== 语法分析

=== 概念
▪ 语法分析(syntax analysis)也称解析(parsing)。

▪ 输出：语法树(syntax tree)

▪ 上下文无关文法(Context-Free Grammar, CFG):
也简称文法，是一种用于描述程序设计语言语法的表示方法。
https://en.wikipedia.org/wiki/Context-free_grammar
https://www.zhihu.com/question/21833944
上下文有关文法(Context-Sensitive Grammar, CSG):
也是一种形式文法，其中任何产生式规则的左手端和右手端都可以被终结符和非终结符构成的上下文所围绕。
https://en.wikipedia.org/wiki/Context-sensitive_grammar

▪ 逆波兰表达式(Reverse Polish Notation):
去掉括号后表达式无歧义
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。
https://www.zhihu.com/question/41103160

▪ 方法分类:
处理文法的语法分析器大致可以分为三种类型: 通用型，自顶向下型，自底向上型。
像Cocke-Younger-Kasami算法和Earley算法可以对任意文法进行语法分析，但这些通用方法效率比较低，不能用于编译器产品。
自顶向下: LL(1)
自底向上: LR(0), SLR(1), LALR(1), LR(1)
https://blog.csdn.net/misskanagi/article/details/29852901
https://softwareengineering.stackexchange.com/questions/19541/what-are-the-main-advantages-and-disadvantages-of-ll-and-lr-parsing

=== 上下文无关文法
一个上下文无关文法由四个元素组成:
(1) 一个终结符号集合，有时也称为词法单元
(2) 一个非终结符号集合，有时也称为语法变量。每个非终结符号表示一个终结符号串的集合。
(3) 一个产生式集合
(4) 指定一个非终结符号为开始符号

例如:
stmt -> if (expr) stmt else stmt
其中:
箭头可以读作“可以具有如下形式”，这样的规则称为产生式(production)；
if和括号这样的词法元素称为终结符号(terminal)；
expr和stmt这样的变量表示终结符号的序列，则称为非终结符号(nonterminal)。

=== 设计文法
文法能够描述程序设计语言的大部分(但不是全部)语法，例如，标识符必须先声明后使用，但这个要求不能通过一个上下文无关文法来描述。

- vs. 正则表达式
正则表达式适合用来词法分析/扫描，但它不够强大，无法处理任意深度嵌套的表达式。
任何能够使用正则表达式描述的，都可以使用文法描述。但正则表达式规则更简单和易于理解，同时，将一个语言的语法结构分为词法和非词法两部分更容易将编译器前端块化。

- 消除二义性


=== 自顶向下的语法分析
LL(1)文法

=== 自底向上的语法分析

=== LR语法分析
LR文法的优点:

LR文法的缺点:
手工构造LR分析器的工作量非常大，因此一般会使用工具例如yacc。

=== 二义性文法

=== 语法分析器生成工具

== 语义分析

=== 概念
语义分析(semantic analyzer)使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息，并把这些信息放在语法树或符号表中，以便在之后的中间代码生成过程中使用。

== 中间代码生成
=== 概念
中间代码的主要两种形式：抽象语法树与三地址指令。

== 中间代码优化

== 目标代码生成

== 目标代码优化

== 工具
=== AST
https://astexplorer.net/
https://esprima.org/demo/parse.html

=== flex and bison
lex/yacc发展为flex/bison

示例:
https://pandolia.net/tinyc/ch8_flex.html
https://pandolia.net/tinyc/ch13_bison.html

示例:
https://github.com/stardust95/TinyCompiler

https://github.com/westes/flex
https://github.com/akimd/bison

=== antlr
https://www.antlr.org/
https://github.com/antlr/antlr4

== project
=== PeachCompiler
C编译器，C语言编写
https://www.bilibili.com/video/BV1Jy4y1d7nq/
https://github.com/nibblebits/PeachCompiler

=== Tiny C Compiler
Fabrice Bellard: https://bellard.org/tcc/

=== Writing a C Compiler
OCaml语言编写
https://norasandler.com/archive/
https://github.com/nlsandler/nqcc

== 参考
《Compilers, Principles, Techniques and Tools》2nd
《计算机程序的构造和解释》（SICP）
《Essentials of Programming Languages》 (EOPL) 
http://web.stanford.edu/class/cs143/
Stanford CS143: https://www.bilibili.com/video/BV17K4y147Bz
Harvard CS153: https://www.bilibili.com/video/BV1cT4y197hW