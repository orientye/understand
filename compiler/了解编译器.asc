= 了解编译器
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com
<<<

== 概览

=== 概念
• 用途

    编程语言
    DSL: 例如SQL, Google Protocol Buffers等
    https://en.wikipedia.org/wiki/Domain-specific_language

• 主要数据结构

    Tokens
    The Syntax Tree
    The Symbol Table: 标识符，变量，函数等
    The Literal Table: 常量，字符串等
    Intermediate Code
    Temporary Files

• 符号表(symbol table)

    符号表是一种供编译器保存有关源程序构造的各种信息的数据结构。
    通常由语法分析器来创建，有些情况下词法分析器在碰到组成一个词素的字符串时也可以立即建立一个符号表条目。

• 自举(bootstraping)

    编译器用自身语言编写(self-compiling)，这是语言迈向成熟的标志。
    当然，在起始阶段，通常还是要借助别的语言来编写。
    https://en.wikipedia.org/wiki/Bootstrapping_(compilers)

== 词法分析

=== 概念与作用
▪ 词法分析(lexical analysis)也称扫描(scanning)。

▪ 词法分析将输入的程序按照构词规则分解成一系列token(词法单元)符号。

▪ token通常分为以下类型:

    (1) 关键字 是由程序语言定义的具有固定意义的标识符
    (2) 标识符 用来表示各种名字，如变量名、数组名、函数名等
    (3) 常数 常数的类型一般有整型、实型、布尔型、字符串类型等
    (4) 运算符 如+、-、*、/等
    (5) 界符 如逗号、分号、括号等

▪ 输出:
通常表示为二元式列表：[<token-name, attribute-value>]

▪ 词法分析是编译过程中的一个阶段，可以在语法分析前进行独自作为一遍，也可以和语法分析结合在一起作为一遍。

=== 正则表达式
==== 概念
正则表达式(regular expression)是一种用来描述词素模式的重要表示方法。
虽然正则表达式不能表达出所有可能的模式，但是可以高效地描述在处理词法单元时要用到的模式类型。

==== 用法
https://github.com/cdoco/learn-regex-zh
https://en.wikipedia.org/wiki/Regular_expression

==== 示例
• 保留字(reserved)

    reserved = if|while|do|...

• 标识符(identifier)

    letter = [a-zA-Z]
    digit = [0-9]
    identifier = letter(letter|digit)*

• 数字(number)

    nat = [0-9]+
    signedNat = (+|-)? nat
    number = signedNat("." nat)?(E signedNat)?

• 注释(comment)

    词法分析会忽略注释，但需要识别注释。
    
    单个界符(delimiter)的注释用正则表达式比较简单，例如:
        {this is a Pascal commment} 其正则表达式: {(~})*}
        -- this is Ada comment 其正则表达式: --(~newline)*
    多个界符的则困难些，例如:
        /* this is a C commment */
        此时即便用正则表达式写对了，也很难具有好的可读性
        因此这种情况下一般会封装一个函数使用状态机

• Ambiguity, White Space and Lookahead


Q: 正则表达式如何匹配3的倍数？
https://www.zhihu.com/question/24824487

=== 词法单元的识别
状态转换图(transition diagram)

=== 词法分析器生成工具Lex

=== 有穷自动机
FA: Finite Automaton 有穷自动机/有限自动机

DFA:

    Deterministic Finite Automaton 确定的有穷自动机    
    在任何一个状态，基于输入的字符串，都能做一个确定的转换。

NFA:

    Nondeterministic Finite Automaton 非确定的有穷自动机
    存在某些状态，针对某些输入，不能做一个确定的转换。
    可以细分成两种情况:
        对于一个输入，它有两个状态可以转换；
        存在ε转换，也就是没有任何输入的情况下，也可以从一个状态迁移到另一个状态。

NFA示例:
https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA#%E4%BE%8B%E5%AD%90

NFA与DFA在表达力上是等价的。任何DFA都是某个NFA的一个特例。

有穷自动机可以看作是状态转换图的形式化表示。
与状态转换图不同，有穷自动机既可以在输入字符上执行转换，也可以在空输入上执行转换。

有限自动机是比较简单的一种自动机，对应于正则文法，也叫做3型文法。
再强大的是下推自动机，对应于上下文无关文法，也叫做2型文法。
更强大的是线性有界自动机，对应于上下文相关文法，也叫1型文法。
图灵机的范围更大，对应0型文法。任何能用产生式写出来的文法规则，都属于0型文法。

=== 正则表达式与自动机
可以将任意一个正则表达式转换为一个大小基本相同的NFA；
任何NFA可以转换为一个代表相同模式的DFA，虽然最坏的情况下自动机的大小会以指数级增长，但在常见的程序设计语言中尚未碰到这些情况；

可以将任意一个NFA或DFA会转化为一个正则表达式。

Q: 如何用DFA描述identifier, 即identifier = letter(letter|digit)*
Q: 如何用DFA描述number

给定一个正则表达式(RE)，可以痛殴下列步骤导出一个最小的DFA:
1 使用Thompson构造法构建一个识别该RE的NFA
2 使用子集构造法导出一个能够模拟该NFA的DFA
3 使用Hopcroft算法来识别该DFA中等价的状态，来构建一个最小DFA

参考:
https://time.geekbang.org/column/article/137286

=== 词法分析器生成工具的设计

=== 基于DFA的模式匹配器的优化

== 语法分析

=== 概念
- 语法分析(syntax analysis)也称解析(parsing)。

- 输出：语法树(syntax tree)

- 上下文无关文法(Context-Free Grammar, CFG):
也简称文法，是一种用于描述程序设计语言语法的表示方法。
如何理解上下文无关文法？
上下文无关的意思是，无论在任何情况下，文法的推导规则都是一样的。
例如，在变量声明语句中可能要用到一个算术表达式来做变量初始化，在其他地方可能也会用到算术表达式。但不管在什么地方，算术表达式的语法都一样，都允许用加法和乘法，计算优先级也不变。
大多数计算机语言，都能用上下文无关文法来表达其语法。
https://en.wikipedia.org/wiki/Context-free_grammar
https://www.zhihu.com/question/21833944

- 上下文有关文法(Context-Sensitive Grammar, CSG):
也是一种形式文法，其中任何产生式规则的左手端和右手端都可以被终结符和非终结符构成的上下文所围绕。
https://en.wikipedia.org/wiki/Context-sensitive_grammar

- PEG文法
解析表达文法(Parsing Expression Grammar, PEG)
https://en.wikipedia.org/wiki/Parsing_expression_grammar
https://alexandermisel.github.io/blog/post/lpeg-and-peg-practices.html
http://www.inf.puc-rio.br/~roberto/docs/peg.pdf

- 逆波兰表达式(Reverse Polish Notation):
去掉括号后表达式无歧义
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。
https://www.zhihu.com/question/41103160

- 方法分类:
处理文法的语法分析器大致可以分为三种类型: 通用型，自顶向下型，自底向上型。
像Cocke-Younger-Kasami算法和Earley算法可以对任意文法进行语法分析，但这些通用方法效率比较低，不能用于编译器产品。
自顶向下: LL(1)
自底向上: LR(0), SLR(1), LALR(1), LR(1)
https://blog.csdn.net/misskanagi/article/details/29852901
https://softwareengineering.stackexchange.com/questions/19541/what-are-the-main-advantages-and-disadvantages-of-ll-and-lr-parsing

- BNF与EBNF:
https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form
https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form

=== 上下文无关文法
一个上下文无关文法由四个元素组成:
(1) 一个终结符号集合，有时也称为词法单元
(2) 一个非终结符号集合，有时也称为语法变量。每个非终结符号表示一个终结符号串的集合。
(3) 一个产生式集合
(4) 指定一个非终结符号为开始符号

例如:
stmt -> if (expr) stmt else stmt
其中:
箭头可以读作“可以具有如下形式”，这样的规则称为产生式(production)；
if和括号这样的词法元素称为终结符号(terminal)；
expr和stmt这样的变量表示终结符号的序列，则称为非终结符号(nonterminal)。

=== 设计文法
文法能够描述程序设计语言的大部分(但不是全部)语法，例如，标识符必须先声明后使用，但这个要求不能通过一个上下文无关文法来描述。

- vs. 正则表达式
正则表达式适合用来词法分析/扫描，但它不够强大，无法处理任意深度嵌套的表达式。
任何能够使用正则表达式描述的，都可以使用文法描述。但正则表达式规则更简单和易于理解，同时，将一个语言的语法结构分为词法和非词法两部分更容易将编译器前端块化。
正则文法是上下文无关文法的一个子集。上下文无关文法允许递归调用，而正则文法不允许。

- 什么是二义性问题？

- 如何解决二义性问题？

- 什么是左递归问题？

    multiplicativeExpression
        :   IntLiteral
        |   multiplicativeExpression Star IntLiteral
        ;

- 如何解决左递归问题？
左递归可以通过改写语法规则来避免，而改写后的语法又可以表达成简洁的EBNF格式，从而说明可以使用循环代替右递归。

    multiplicativeExpression
        :   IntLiteral
        |   IntLiteral Star multiplicativeExpression
        ;

=== 自顶向下的语法分析
- LL(1)文法
LL分析法比较简单，主要思想就是可以向前读入一个(常用的LL(1))词素来决定选择哪个语法推导规则。

- 优点:
    
    容易手工实现

- 缺点:

    限制较多

=== 自底向上的语法分析

=== LR语法分析
LR文法的优点:

    LR语法比LL普适

LR文法的缺点:

    手工构造LR分析器的工作量非常大，因此一般会使用工具例如yacc。

SLR(1): simple LR(1)
LALR(1): look ahead LR(1)

=== 二义性文法

=== 语法分析器生成工具

== 语义分析

=== 概念
语义分析(semantic analyzer)使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时也收集类型信息，并把这些信息放在语法树或符号表中，以便在之后的中间代码生成过程中使用。

== 中间代码生成
=== 概念
中间代码的主要两种形式：抽象语法树与三地址指令。

== 中间代码优化

== 目标代码生成

== 目标代码优化

== 工具
=== antlr
vs. flex and bison
https://tomassetti.me/why-you-should-not-use-flex-yacc-and-bison/
https://stackoverflow.com/questions/212900/advantages-of-antlr-versus-say-lex-yacc-bison#:~:text=The%20most%20significant%20difference%20between,more%20difficult%20and%20vice%20versa.

https://www.antlr.org/
https://github.com/antlr/antlr4
https://github.com/antlr/grammars-v4

=== flex and bison
lex/yacc发展为flex/bison

示例:
flex:  https://pandolia.net/tinyc/ch8_flex.html
bison: https://pandolia.net/tinyc/ch13_bison.html

示例:
https://github.com/stardust95/TinyCompiler

源码:
flex:  https://github.com/westes/flex
bison: https://github.com/akimd/bison

参考:
https://epaperpress.com/lexandyacc/download/flex.pdf
https://www.gnu.org/software/bison/manual/bison.pdf
https://web.iitd.ac.in/~sumeet/flex__bison.pdf

=== AST
clang -ast-dump: https://clang.llvm.org/docs/IntroductionToTheClangAST.html
https://astexplorer.net/
https://esprima.org/demo/parse.html

=== LLVM
https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html

=== 参考
https://en.wikipedia.org/wiki/Comparison_of_parser_generators

== project

=== PeachCompiler
C语言编写, 实现C语言子集
https://www.bilibili.com/video/BV1Jy4y1d7nq/
p1-p4: 介绍与工程
p5-p22: 词法分析
p23-p101: 语法分析

https://github.com/nibblebits/PeachCompiler

=== Tiny C Compiler(Fabrice Bellard)
https://bellard.org/tcc/
https://bellard.org/tcc/tcc-doc.html

=== A small C compiler
https://github.com/rui314/chibicc

=== Writing a C Compiler
OCaml语言编写
https://norasandler.com/archive/
https://github.com/nlsandler/nqcc

=== 自己动手用java写编译器
https://study.163.com/course/courseLearn.htm?courseId=1002830012#

=== The TINY Sample Language
C语言编写，实现类Pascal子集
http://www.cs.sjsu.edu/~louden/cmptext/loucomp.zip

== 语言特性
=== CPS(Continuation-Passing Style)
https://en.wikipedia.org/wiki/Continuation-passing_style

== 参考
《Compiler Construction Principles and Practice》 (编译原理及实践)
《Engineering a Compiler》2nd (编译器设计)
《Compilers, Principles, Techniques and Tools》2nd (龙书)
《Modern Compiler Implementation in C》(虎书)
《Advanced Compiler Design and Implementation》(鲸书)
《Optimizing compilers for modern architectures - a dependency based approach》(现代体系结构的优化编译器)
http://web.stanford.edu/class/cs143/
Stanford CS143: https://www.bilibili.com/video/BV17K4y147Bz
Harvard CS153: https://www.bilibili.com/video/BV1cT4y197hW
https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/
《编译原理之美》 https://time.geekbang.org/column/intro/100034101
《Introduction to the Theory of Computation》3rd (计算理论导引) 正则表达式，自动机，上下文无关文法等相关理论