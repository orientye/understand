:toc:
:toclevels: 5
:hardbreaks-option:

== lock-free
=== lock free
- https://en.wikipedia.org/wiki/Non-blocking_algorithm
- https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf

- vs-wait-free
** wait-free指不管OS如何调度线程，每个线程都始终在做有用的事
** lock free指不管OS如何调度线程，至少有一个线程在做有用的事
** wait-free:
    *** 每个线程都能在有限步骤内完成操作
    *** 禁止无限重试，每个线程必须设计成能在确定步骤内完成，即使所有其他线程都在同时执行冲突操作
** lock-free:
    *** 即使有线程被挂起，其他线程仍能继续执行，但不保证每个线程都能在有限步骤内完成操作
    *** 允许重试循环，但必须保证系统整体前进
** https://github.com/apache/brpc/blob/master/docs/cn/atomic_instructions.md#wait-free--lock-free

[source, cpp]
.lock free示例
----
void push(Node* new_node) {
    do {
        Node* old_top = atomic_load(&top);
        new_node->next = old_top;
    } while (!atomic_compare_exchange_weak(&top, &old_top, new_node));
}
----

[source, cpp]
.wait free示例
----
class WaitFreeCounter {
private:
    std::atomic<int> count;
    
public:
    void increment() {
        count.fetch_add(1, std::memory_order_relaxed);
        // 无论有多少线程同时调用，每个线程都在1步内完成
    }
    
    int get() {
        // 也是单步完成
        return count.load(std::memory_order_relaxed);
    }
};
----

=== wait free
- Wait-Free definition: Each operation completes in a finite number of steps
- Wait-free implies lock-free
- Lock-free algorithms does not imply wait-free

    Note while loops in our lock-free algorithms…

- Wait-free synchronization much harder

    Impossible in many cases
    Usually specifiable only given a fixed number of threads

- Generally appear only in ‘hard’ real time systems

- https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf
- https://www.boost.org/doc/libs/1_76_0/doc/html/lockfree.html#lockfree.introduction___motivation.introduction__amp__terminology

=== vs-mutex
https://stackoverflow.com/questions/43540943/using-boost-lockfree-queue-is-slower-than-using-mutexes

=== implement
- With few exceptions, non-blocking algorithms use atomic read-modify-write primitives that the hardware must provide, the most notable of which is compare and swap (CAS).

- Additionally, some non-blocking data structures are weak enough to be implemented without special atomic primitives. These exceptions include:
    * a single-reader single-writer ring buffer FIFO, with a size which evenly divides the overflow of one of the available unsigned integer types, can unconditionally be implemented safely using only a memory barrier
    * Read-copy-update with a single writer and any number of readers. (The readers are wait-free; the writer is usually lock-free, until it needs to reclaim memory).
    * Read-copy-update with multiple writers and any number of readers. (The readers are wait-free; multiple writers generally serialize with a lock and are not obstruction-free).

=== 内存回收
主要解决的问题是: 如何在不干扰其他线程的前提下，安全地销毁已被移除的节点。

风险指针 (Hazard Pointers):

    每个线程注册一个或多个“风险指针”，用于声明自己正在访问的共享对象。
    在释放一个对象前，扫描所有线程的风险指针列表。
    只有当没有任何线程的风险指针指向该对象时，才能安全释放。

基于分代 (Epoch-based, EBR):

    将时间划分为代，所有线程进入新一代后，旧代内存整体回收。
    如果有一个线程停滞或挂起，可能会阻碍整个纪元的推进，导致内存无法释放/大幅增长。

RCU (Read-Copy-Update):

    读写分离，通过等待“宽限期”确保无读者后再物理删除
    读取性能极致；能处理复杂的指针引用链
    写操作开销大（需复制）
    回收延迟高

其他辅助技术:

    引用计数 (Reference Counting)
    垃圾回收 (GC)
    静态对象池 (Object Pooling): 预分配内存，节点不真正释放，只做状态标记。

Question:

    folly UnboundedQueue.h 是如何管理内存的？

=== correctness
==== relacy
https://github.com/dvyukov/relacy

==== cppmem
http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/

==== 形式化验证
spin: https://spinroot.com/spin/whatispin.html

==== linux kernel
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc#toolp[linux-kernel-barrier-tool]

==== 参考
https://github.com/MattPD/cpplinks/blob/master/atomics.lockfree.memory_model.md#data-structures-readings-correctness

=== SPSC
▪ folly
https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h
fixed capacity
performance: https://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++

▪ boost
https://github.com/boostorg/lockfree/blob/master/include/boost/lockfree/spsc_queue.hpp
单值: https://github.com/boostorg/lockfree/blob/develop/include/boost/lockfree/spsc_value.hpp

    bounded: 有界环形缓冲区
        // 1. 固定容量（编译时确定）
        boost::lockfree::spsc_queue<int, boost::lockfree::capacity<1024>> queue;
        // 2. 动态容量（运行时确定）
        boost::lockfree::spsc_queue<int> queue(1024);

▪ rigtorp
https://github.com/rigtorp/SPSCQueue
fixed capacity

▪ cameron314
https://github.com/cameron314/readerwriterqueue

▪ 1024cores(Dmitry Vyukov)
https://web.archive.org/web/20151227000642/http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue

▪ 参考
https://groups.google.com/g/lock-free/search?q=SPSC%20queue
https://arxiv.org/abs/1012.1824

=== MPMC
▪ folly
https://github.com/facebook/folly/blob/master/folly/MPMCQueue.h
fixed capacity
unbounded: https://github.com/facebook/folly/blob/main/folly/concurrency/UnboundedQueue.h
形式化验证: https://cs.au.dk/~birke/papers/mpmc-queue.pdf

▪ boost
https://github.com/boostorg/lockfree/blob/master/include/boost/lockfree/queue.hpp

▪ rigtorp
被Frostbite(EA寒霜引擎)和一些金融量化等高性能系统采用
bounded
https://github.com/rigtorp/MPMCQueue

▪ atomic_queue
https://github.com/max0x7ba/atomic_queue
linear fixed size ring-buffer array

▪ cameron314
https://github.com/cameron314/concurrentqueue

▪ 1024cores(Dmitry Vyukov)
https://web.archive.org/web/20151004102027/http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue
https://github.com/couchbase/phosphor/blob/master/thirdparty/dvyukov/include/dvyukov/mpmc_bounded_queue.h

▪ benchmark
https://github.com/joadnacer/atomic_queues
https://blog.bearcats.nl/simple-message-queue/

▪ 参考
https://groups.google.com/g/lock-free/search?q=MPMC%20queue

=== project
==== disruptor
https://zhuanlan.zhihu.com/p/23863915
https://lmax-exchange.github.io/disruptor/
https://github.com/LMAX-Exchange/disruptor

=== 参考
https://github.com/MattPD/cpplinks/blob/master/atomics.lockfree.memory_model.md
https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md#wait-free--lock-free
https://github.com/rigtorp/awesome-lockfree
http://psy-lob-saw.blogspot.com/p/lock-free-queues.html
perfbook: 14.2 Non-Blocking Synchronization
https://groups.google.com/g/lock-free
https://stackoverflow.com/questions/tagged/lock-free