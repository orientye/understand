:toc:
:toclevels: 5
:hardbreaks-option:

== lock-free
=== lock free
- https://en.wikipedia.org/wiki/Non-blocking_algorithm
- https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf

- vs-wait-free
** wait-free指不管OS如何调度线程，每个线程都始终在做有用的事；lock free比前者弱一些，指不管OS如何调度线程，至少有一个线程在做有用的事。
** lock-free:
    *** 即使有线程被挂起，其他线程仍能继续执行，但不保证每个线程都能在有限步骤内完成操作。
    *** 允许重试循环，但必须保证系统整体前进。
** wait-free:
    *** 每个线程都能在有限步骤内完成操作。
    *** 禁止无限重试，每个线程必须设计成能在确定步骤内完成，即使所有其他线程都在同时执行冲突操作。
** https://github.com/apache/brpc/blob/master/docs/cn/atomic_instructions.md#wait-free--lock-free

[source, cpp]
.lock free示例
----
void push(Node* new_node) {
    do {
        Node* old_top = atomic_load(&top);
        new_node->next = old_top;
    } while (!atomic_compare_exchange_weak(&top, &old_top, new_node));
}
----

[source, cpp]
.wait free示例
----
class WaitFreeCounter {
private:
    std::atomic<int> count;
    
public:
    void increment() {
        count.fetch_add(1, std::memory_order_relaxed);
        // 无论有多少线程同时调用，每个线程都在1步内完成
    }
    
    int get() {
        // 也是单步完成
        return count.load(std::memory_order_relaxed);
    }
};
----

=== wait free
- Wait-Free definition: Each operation completes in a finite number of steps
- Wait-free implies lock-free
- Lock-free algorithms does not imply wait-free

    Note while loops in our lock-free algorithms…

- Wait-free synchronization much harder

    Impossible in many cases
    Usually specifiable only given a fixed number of threads

- Generally appear only in ‘hard’ real time systems

- https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf
- https://www.boost.org/doc/libs/1_76_0/doc/html/lockfree.html#lockfree.introduction___motivation.introduction__amp__terminology

=== vs-mutex
https://stackoverflow.com/questions/43540943/using-boost-lockfree-queue-is-slower-than-using-mutexes

=== implement

- With few exceptions, non-blocking algorithms use atomic read-modify-write primitives that the hardware must provide, the most notable of which is compare and swap (CAS). 

- Additionally, some non-blocking data structures are weak enough to be implemented without special atomic primitives. These exceptions include:

    ▪ a single-reader single-writer ring buffer FIFO, with a size which evenly divides the overflow of one of the available unsigned integer types, can unconditionally be implemented safely using only a memory barrier
    ▪ Read-copy-update with a single writer and any number of readers. (The readers are wait-free; the writer is usually lock-free, until it needs to reclaim memory).
    ▪ Read-copy-update with multiple writers and any number of readers. (The readers are wait-free; multiple writers generally serialize with a lock and are not obstruction-free).

=== 相关API
https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free.html
https://en.cppreference.com/w/c/atomic/atomic_is_lock_free.html

=== correctness
==== relacy
https://github.com/dvyukov/relacy

==== cppmem
http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/

==== 形式化验证
spin: https://spinroot.com/spin/whatispin.html

==== linux kernel
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc#toolp[linux-kernel-barrier-tool]

==== 参考
https://github.com/MattPD/cpplinks/blob/master/atomics.lockfree.memory_model.md#data-structures-readings-correctness

=== SPSC
Q: SPSC实现的根本原理是什么?
A: consumer和producer只关心对某个变量的写操作，以及对其它变量的读操作。通过内存序（memory ordering）和原子操作（atomic operations）来替代锁，确保生产者和消费者在并发访问共享数据结构时的正确性。

▪ folly
https://github.com/facebook/folly/blob/master/folly/ProducerConsumerQueue.h (spsc, fixed capacity)

▪ boost
https://github.com/boostorg/lockfree/blob/master/include/boost/lockfree/spsc_queue.hpp
单值: https://github.com/boostorg/lockfree/blob/develop/include/boost/lockfree/spsc_value.hpp

    bounded: 有界环形缓冲区
        // 1. 固定容量（编译时确定）
        boost::lockfree::spsc_queue<int, boost::lockfree::capacity<1024>> queue;
        // 2. 动态容量（运行时确定）
        boost::lockfree::spsc_queue<int> queue(1024);

=== MPMC
▪ folly
https://github.com/facebook/folly/blob/master/folly/MPMCQueue.h (fixed capacity)
https://cs.au.dk/~birke/papers/mpmc-queue.pdf
https://github.com/rigtorp/MPMCQueue

▪ boost
https://github.com/boostorg/lockfree/blob/master/include/boost/lockfree/queue.hpp

=== project
==== disruptor
https://zhuanlan.zhihu.com/p/23863915
https://lmax-exchange.github.io/disruptor/
https://github.com/LMAX-Exchange/disruptor

=== 参考
https://github.com/MattPD/cpplinks/blob/master/atomics.lockfree.memory_model.md
https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md#wait-free--lock-free
https://github.com/rigtorp/awesome-lockfree
http://psy-lob-saw.blogspot.com/p/lock-free-queues.html
perfbook: 14.2 Non-Blocking Synchronization