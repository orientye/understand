:toc:
:toclevels: 5
:hardbreaks-option:

== lock
=== 概念
- Locks are bad:

    Taking too few locks
    Taking too many locks
    Taking the wrong locks
    Taking locks in the wrong order
    Error recovery
    Lost wakeups and erroneous retries
    But the fundamental shortcoming of lock-based programming
        is that locks and condition variables do not support modular programming.
    - 参考《Beautiful Code》- Beautiful Concurrency

- 可重入/递归

    可重入锁是一种特殊的互斥锁，它允许同一个线程在已经持有该锁的情况下，多次获取该锁而不会导致死锁。
    优点：
        避免自死锁：允许方法调用同类或其它需要同一锁的方法。
        简化编程模型：在面向对象设计中，无需关心一个方法会被谁调用，只要锁是保护同一份资源，就可以安全地使用同一把锁。
    缺点：
        复杂性：需要小心管理锁的获取和释放次数，确保解锁次数与加锁次数严格匹配。
        可能掩盖设计问题：过度使用可重入锁可能导致过大的锁范围，降低并发性。一个需要重入锁的设计可能意味着代码结构需要重构。
    std::mutex 不可重入，std::recursive_mutex 可重入。
    Java的 synchronized 与 ReentrantLock 是可重入的。

- busy wait与sleep wait

    忙等待: 线程在获取锁失败后，不放弃CPU，而是在一个循环中不停地检查锁的状态，直到锁被释放。如自旋锁。
    睡眠等待: 线程在获取锁失败后，主动放弃CPU，进入阻塞（睡眠）状态，等待锁被释放时由操作系统将其唤醒。如Mutex。

- 乐观锁(optimistic locking)与悲观锁(pessimistic locking)

    乐观锁是一种并发控制机制。
    其核心思想是：假设在绝大多数情况下，数据访问不会发生冲突。
    因此，在数据操作过程中不加锁，而是在提交数据更新时，才会正式对数据冲突进行检测。

    Q: 乐观锁有哪些?
        如CAS
    Q: 乐观锁适合什么场景/优缺点?
        乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试/回退的成本非常高
        只有在冲突概率比较低，且加锁成本非常高的场景时，才考虑使用乐观锁
    Q: 乐观锁 vs. 悲观锁
        https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking

- blocking与non-blocking

    lock-based/blocking
    -------------------------------------------------------
    non-blocking(lock-free)
        obstruction-free(无障碍)
        lock-free(无锁)
        wait-free(无等待)
    -------------------------------------------------------
    https://en.wikipedia.org/wiki/Non-blocking_algorithm
    https://www.boost.org/doc/libs/latest/doc/html/lockfree.html#lockfree.introduction___motivation.introduction__amp__terminology

- 公平锁(Fair Lock)与非公平锁(Non-fair Lock)

    公平锁:
        多个线程按照申请锁的绝对时间顺序来依次获得锁。
        线程会直接进入一个队列中排队，只有队列头的线程才能获得锁。
    非公平锁是大多数情况下的默认和推荐选择，因为它能提供更高的吞吐量。
        这也是为什么 ReentrantLock 和 synchronized 默认都是非公平的。
    std::mutex 在标准上不保证公平性(Lock Fairness)，在实践中都是非公平的。
    公平锁是一种为了保障公平性而牺牲部分性能的策略，适用于对线程执行顺序有严格要求的特定场景。

- 优先级反转(priority inversion)

    问题：优先级反转是由于锁的引入，导致中优先级任务无意中阻塞了高优先级任务，破坏了系统的实时性。
    根源：高优先级任务在等待一个被低优先级任务持有的资源，而低优先级任务又无法运行。
    解决：
    优先级继承是最常用的方法，它通过临时提升低优先级任务的优先级来解决问题，确保它能尽快释放锁。
    优先级反转的解决主要是在操作系统内核层实现的。
    https://en.wikipedia.org/wiki/Priority_inversion

- STM(Software Transactional Memory)

    软件事务内存
    在主流命令式编程中，STM 未能广泛取代锁
    目前支持STM的编程语言主要是函数式语言，函数式语言里的数据天生具备不可变性，实现STM相对来说更简单。

=== dead lock
==== 概念
两个或两个以上的进程（或线程）在执行过程中，因争夺资源而互相等待，无法向前推进。

死锁通常是因为获取锁时形成了环路。

==== 死锁发生前
- 尽量不要使用共享

- 例如使用消息通讯，例如Erlang里的变量不变

- 尽量使用并发组件

    例如java.util.concurrent

- 尽量使用非递归锁(不可重入锁)

    例如pthread_mutex_t默认非递归

- 控制顺序

    thread 1: Lock(a), Lock(b)
    thread 2: Lock(b), Lock(a)
    转变为统一的顺序如Lock(a), Lock(b)
    运行期警告

- try_lock

- 把Lock历史形成一个graph，看是否存在回路

- 超时机制

    如带有timeout的wait, innodb_lock_wait_timeout等

- 工具测试

    例如Intel inspector, Valgrind-Helgrind(pthread)等

- PS. 银行家算法

    由Edsger Dijkstra爷爷为设计THE操作系统创建，其使用场景也有些局限性:
    比如需要知道进程请求资源的可能数量，以及假设进程数量是固定的等，因此基本不具有实用性。

==== 死锁发生后
- 堆栈查看

    pstack(其实就是gdb thread apply all bt)
    jstack, jconsole
    ps. CPU100%也可以通过这种方法

- 检测机制

    例如innodb的wait-for graph，形成环路（或者层次太深时也会认为死锁）时，
    此时会选择Undo量小的事务进行回滚。

==== vs. livelock
Livelock: A livelock is a special type of deadlock, where the processes are changing their states continuously but not making any progress.

Now, let's say in the above example we wish to resolve this deadlock. We put in a deadlock identifying setup which becomes aware of a deadlock when it happens. It orders the processes that are part of the deadlock, to release all their resources for some time and then come back and try proceeding again. If A, B, and C do this at the same time, they would keep oscillating in a loop of 1. Getting stuck in deadlock 2. Releasing the resource 3. Waiting for some time 4. Locking again the resource they were previously holding, thus recreating the deadlock.

Real life example would be when you make a phone call, but the person at the other end is trying to call you too. You both hang up and try again after the same time, which creates the same situation again. This can go on for eternity.

参考: https://en.wikipedia.org/wiki/Deadlock#Livelock

==== vs. starvation
https://www.codingninjas.com/studio/library/deadlock-vs-starvation

参考: https://www.geeksforgeeks.org/difference-between-deadlock-and-starvation-in-os/

=== lock lack
https://mp.weixin.qq.com/s?__biz=MzI5NDY2MDE0Nw==&mid=2247483665&idx=1&sn=272e38645d0e414c77e67ce8389fe3e1&chksm=ec5e304ddb29b95bf2d4052266fb37a1c828c24e6d4db51320ddcc60e1af90a8661e4e69874f&mpshare=1&scene=1&srcid=1008Spw64tFyuoQZegtgVytP&sharer_sharetime=[lock-lack]

=== thread safety analysis
https://insights.sei.cmu.edu/blog/thread-safety-analysis-in-c-and-c/
https://github.com/facebook/infer
https://github.com/microsoft/infersharp

=== linux kernel中的锁
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc[linux-kernel-lock]

=== 分布式锁
vs. 分布式事务
- 基于数据库来实现
- 基于缓存来实现
- 基于zookeeper来实现
- 基于consul来实现

=== 工程实践
- PTHREAD_MUTEX_ERRORCHECK

=== Q&A
Q: What if I want several threads to hold the same lock at the same time?
