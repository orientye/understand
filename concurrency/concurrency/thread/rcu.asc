:toc:
:toclevels: 5
:hardbreaks-option:

=== rcu
==== 概念
RCU (Read-Copy-Update) 的核心思想可以概括为：“读取时不加锁，更新时先复制，延迟回收旧内存”。
1. Read（读取端）：零竞争访问
机制：读者直接通过指针访问当前数据，不执行任何加锁操作（甚至不需要原子指令）。
特性：在进入“读临界区”时，读者只需做一个极轻量级的标记（如增加一个线程局部的计数器）。
效果：读操作永远不会被写操作阻塞，多个读者可以与写者完全并发运行，性能接近单线程访问。
2. Copy & Update（更新端）：非原地修改
写者如果想修改数据，不会直接覆盖当前读者正在看的内存，而是遵循以下步骤：
Copy（复制）：开辟一块新内存，将旧数据完整拷贝过去。
Modify（修改）：在副本（新内存）上进行修改。
Update（发布）：通过一次原子操作，将全局指针从“旧内存”指向“新内存”。
效果：在指针切换瞬间，新的读者会看到新数据，而切换前已存在的读者仍安全地访问旧数据。
3. Grace Period（宽限期）：安全回收
这是 RCU 最核心的机制，解决了“旧内存何时能删”的问题：
定义：从“指针切换”开始，到“所有正在访问旧数据的读者全部退出”为止的这段时间，称为宽限期。
回收：写者必须等待宽限期结束，确认没有任何读者还在引用旧对象后，才执行内存释放。
方式：
同步等待：调用 synchronize_rcu() 阻塞，直到宽限期结束。
异步回调：调用 retire() 注册一个回调，由后台线程在宽限期后自动清理。

缺点:
1. 写入开销大 (Write Overhead)
复制成本：每次修改数据都必须完整拷贝一份副本。如果对象很大（例如一个包含数万元素的哈希表），拷贝操作会消耗大量 CPU 和内存带宽。
写者竞争：虽然读者不阻塞写者，但为了保证数据一致性，多个写者之间通常仍需互斥锁来同步。因此，RCU 无法解决高频并发写入的扩展性问题。
2. 宽限期延迟 (Grace Period Latency)
回收滞后：旧内存不能立即释放，必须等待宽限期结束。如果某个读者线程因某种原因（如进入死循环或处理耗时任务）迟迟不退出临界区，宽限期就会被无限拉长。
同步阻塞：如果写者使用同步模式（如 synchronize_rcu），它必须阻塞等待。在复杂的分布式或高负载系统中，这个等待时间可能达到毫秒级，对实时性要求高的写操作影响很大。
3. 内存压力 (Memory Pressure)
内存膨胀：由于回收是延迟的，系统中会同时存在多个版本的数据副本。在更新频率较高时，待回收的对象会迅速堆积，导致内存占用激增，甚至引发 OOM（内存溢出）。
管理复杂：开发者需要手动确保每个对象都正确调用了 retire 或进入了宽限期处理，相比自动垃圾回收（GC），其心智负担更高。
4. 数据一致性弱 (Consistency)
读取陈旧数据：RCU 提供的是最终一致性。在写者完成指针切换后的宽限期内，旧读者看到的仍然是旧版本数据。对于要求“强一致性”（即更新后所有人必须立刻看到新值）的金融级交易等场景，RCU 并不适用。
5. 编程限制与风险
读者临界区限制：在某些实现中（如 Linux 内核早期版本），RCU 读者临界区内严禁发生上下文切换或休眠。虽然 C++26 和 Folly 的用户态 RCU 放宽了限制，但长时间持有读者锁仍是性能禁忌。
调试困难：RCU 相关的 Bug（如忘记标记读临界区、在临界区外访问指针）通常会导致偶发性的内存损坏或逻辑错误，这类问题极难复现和排查。

==== linux kernel
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc#rcu[linux-kernel-rcu]

==== folly

==== c++26
