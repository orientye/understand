:hardbreaks-option:

=== 线程安全
==== 定义
线程安全有不止一种定义，而且互不兼容。
《Java Concurrency in Practice》里定义，一个线程安全的class应当满足以下三个条件:
• 多个线程同时访问时，其表现出正确的行为
• 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织(interleaving)
• 调用端代码无须额外的同步或其他协调动作

依据这个定义，C++标准库里的大多数class都不是线程安全的，包括std::string、std::vector、std::map、std::shared_ptr等等

而C系统库大多数函数是线程安全的，包括malloc/free/printf/gettimeofday等等。
gethostbyname通常不是线程安全，但FreeBSD的实现用了thread local storage，因此是安全的。
至于read/write同一个fd是不是线程安全，按POSIX定义是，按程序语义则不一定(因为有可能出现short read/short write); 从实现看，Linux 3.14之前的write不是线程安全，多线程写有overlap的可能，3.14之后才是安全的。

另外一种定义，同一类型的多个对象能分别被各自所属的不同线程并发访问，就算是线程安全的。在这个定义下，C++标准库容器和基本类型都是"线程安全的"。为了与前一种定义区别，这个一般叫做thread compatible。

线程安全需要保证几个基本特性:
原子性: 相关操作不会中途被其它线程干扰。
可见性: 一个线程修改了某个共享变量，其状态能够立即被其它线程知晓，通常被解释为将线程本地状态反映到主内存上。
有序性: 保证线程内串行语义，避免指令重排等。

thread safe的级别(其实意义不大):
按照 https://docs.oracle.com/cd/E19683-01/806-6867/6jfpgdco5/index.html 的划分
假设有一个公共卫生间：
Unsafe：没有门锁，任何人可随时进入 → 混乱
Serializable：整个卫生间一把大锁，一次只进一人 → 安全但低效
MT-Safe：每个隔间有自己的锁，多人可同时使用不同隔间 → 既安全又高效

参考:
https://en.wikipedia.org/wiki/Thread_safety
https://www.zhihu.com/question/23244293/answer/24032098

==== race condition
https://en.wikipedia.org/wiki/Race_condition

==== visibility(可见性)
可见性决定了其他线程何时能够看到当前线程所做的更改，以及是否能够看到这些更改。
可以通过特殊操作（如设置内存屏障）来确保可见性。不过，在实践中，可见性是最无需费心的特性，因为在缓存一致性架构上（即所有现代商用架构——IA-32、Intel 64、SPARC、POWER），可见性是自动保证的，每个写入操作都会以尽力而为的方式自动传播到所有其他处理器/核心。
也有一些例外情况，例如在 x86 架构中，非临时存储（使用 MOVNTDQ 等指令实现）以及对内存的 WC（写合并）区域进行的存储实际上是非缓存一致性的。也就是说，它们只有在执行 SFENCE 指令、MFENCE 指令、LOCKed 指令或其他序列化操作之前，才会传播到其他处理器/核心。

https://web.archive.org/web/20150530204245/http://www.1024cores.net/home/lock-free-algorithms/so-what-is-a-memory-model-and-how-to-cook-it/visibility

==== ordering(有序性)
https://web.archive.org/web/20150530233431/http://www.1024cores.net/home/lock-free-algorithms/so-what-is-a-memory-model-and-how-to-cook-it/ordering