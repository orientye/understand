:toc:
:toclevels: 5
:hardbreaks-option:

=== atomic(原子操作)
==== 概念
原子操作指的是在执行过程中不可被中断的一个或一系列操作。要么完全执行完毕，要么完全没执行，不会出现中间状态。

注意，c/c++的atomic不仅仅是一个原子操作，结合适当的std::memory_order，还具有线程间同步的作用。本篇重点关注原子操作，memory_order部分参考link:./memory-order.asc[memory-order]。

C++标准对std::atomic的定义:
Each instantiation and full specialization of the std::atomic template defines an atomic type. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see memory model for details on data races).
In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by std::memory_order.
（每个std::atomic模板的实例化和完全特化都定义一个原子类型。如果一个线程写入原子对象而另一个线程从中读取，行为是明确定义的。此外，对原子对象的访问可以建立线程间同步，并按照std::memory_order指定的方式对非原子内存访问进行排序。）

参考:
https://stackoverflow.com/questions/31978324/what-exactly-is-stdatomic
https://github.com/apache/brpc/blob/master/docs/cn/atomic_instructions.md

==== cpu
===== X86
====== 1.基本内存操作的原子性
首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

====== 2.总线锁定(Bus Locking)
总线锁定是处理器实现原子操作的传统机制，它通过物理上锁定内存总线来确保操作的原子性。
基本原理:
    发出LOCK#信号到系统总线
    其他处理器检测到此信号
    在操作完成前，其他处理器无法访问任何内存
    操作完成后，释放LOCK#信号

====== 3.缓存锁定(Cache Locking)
总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，因此总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

频繁使用的内存会缓存在处理器的L1，L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在奔腾6和最近的处理器中可以使用"缓存锁定"的方式来实现复杂的原子性。所谓"缓存锁定"就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。
一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32处理器和Intel 64处理器使用MESI(修改，独占，共享，无效)控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。

不会使用缓存锁定的情况:
第一种情况是: 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行(cache line)，则处理器会调用总线锁定。
第二种情况是: 有些处理器不支持缓存锁定。对于Intel 486和奔腾处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

====== LOCK prefix 指令
The LOCK prefix ensures that the processor has exclusive use of any shared memory while the signal is asserted.
即LOCK前缀确保在信号被断言期间，处理器对任何共享内存拥有独占使用权。

对于LOCK前缀指令(包括隐式的)，处理器根据条件选择使用缓存锁定或总线锁定。
https://stackoverflow.com/questions/3144335/on-a-multicore-x86-is-a-lock-necessary-as-a-prefix-to-xchg

Lock前缀指令会引起处理器缓存回写到内存。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占使用任何共享内存。（因为它会锁住总线，导致其他CPU不能访问总线，不能访问总线就意味着不能访问系统内存），但是在最近的处理器里，LOCK#信号一般不锁总线，而是锁缓存，毕竟锁总线开销比较大。在8.1.4章节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和最近的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反地，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为"缓存锁定"，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。

====== 参考
https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html
chapter8 multi-processor management  8.1
https://www.infoq.cn/article/atomic-operation
https://www.infoq.cn/article/ftf-java-volatile
https://github.com/orientye/understand/blob/main/co-ca/cpu.asc#cache-coherence-protocols

==== kernel
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E5%90%8C%E6%AD%A5.asc#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C[linux-kernel-atomic]

==== compare_and_swap(CAS)
===== CPU
- Compare-And-Swap (CAS) on x86
https://en.wikipedia.org/wiki/Compare-and-swap

- Load-Link/Store-Conditional (LL/SC) on Alpha, PowerPC, MIPS and ARM
https://en.wikipedia.org/wiki/Load-link/store-conditional
注意，LL/SC机制没有ABA问题，这是因为:
LL/SC机制通常不仅能监测目标地址的数据是否被更改，还能监测其物理地址是否经历过"解除映射-重新映射"等更底层的状态变化。即使值从A变B又变回A，LL指令建立的"监控链接"也能捕捉到这个过程，从而使随后的SC操作失败。

===== CAS的性能
《perfbook 3.2.2 Costs of Operations》

Same-CPU 同CPU内
On-Core 同核心内
Off-Core 跨核心
Off-Socket 跨插槽
Cross-Interconnect 跨互连
Off-System 跨系统

The lock operation is more expensive than CAS because it requires two atomic operations on the lock data structure, one for acquisition and the other for release.

===== CAS的问题
- ABA 问题背景
假设一个共享变量的值变化过程为：A → B → A。
线程1准备将值从 A 改为 C，但在执行 CAS 之前被挂起。此时线程2介入，先将值从 A 改为 B，然后又改回 A。当线程1恢复执行时，CAS 操作仍然会成功（因为当前值还是 A），但这可能隐藏了一些问题。

- ABA 解决方案

    标签指针:
        版本号: 每次变量更新时候版本号加一，A-B-A就会变成1A-2B-3A。
        Java1.5开始atomic包类AtomicStampedReference/AtomicMarkableReference来解决ABA问题:
        其compareAndSet方法首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，
        如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
        AtomicStampedReference(V initialRef, int initialStamp)//构造
        public boolean compareAndSet
            (V      expectedReference,// 预期引用
            V      newReference,//更新后的引用
            int    expectedStamp,// 预期标志
            int    newStamp) // 更新后的标志
    硬件方案:
        Load-Link/Store-Conditional (LL/SC) on Alpha, PowerPC, MIPS and ARM
        LL/SC机制没有ABA问题

- 循环时间长开销大
自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令(de-pipeline), 使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突(memory order violation)而引起CPU流水线被清空(CPU pipeline flush)，从而提高CPU的执行效率。

- 参考
https://www.infoq.cn/article/atomic-operation

===== C++ CAS
https://en.cppreference.com/w/c/atomic/atomic_compare_exchange
https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange
https://en.cppreference.com/w/cpp/atomic/atomic_ref/compare_exchange.html

    主要接口:
    bool compare_exchange_weak( T& expected, T desired,
                                std::memory_order success,
                                std::memory_order failure ) noexcept;
    bool compare_exchange_weak( T& expected, T desired,
                                std::memory_order order =
                                    std::memory_order_seq_cst ) noexcept;
    bool compare_exchange_strong( T& expected, T desired,
                                std::memory_order success,
                                std::memory_order failure ) noexcept;
    bool compare_exchange_strong( T& expected, T desired,
                                std::memory_order order =
                                    std::memory_order_seq_cst ) noexcept;

Atomically compares the value representation of the referenced object with that of expected, and if those are bitwise-equal, replaces the former with desired (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into expected (performs a load operation).

[source, cpp]
----
std::atomic<int> x{10};
int expected = 10;
int desired = 20;

bool success = x.compare_exchange_strong(expected, desired);
// success = true
// x现在 = 20
// expected保持不变 = 10（旧值）
----

[source, cpp]
----
std::atomic<int> x{30};
int expected = 10;
int desired = 20;

bool success = x.compare_exchange_strong(expected, desired);
// success = false（因为 x != 10）
// x保持不变 = 30
// expected被更新为30（实际当前值/旧值）
----

weak vs. strong:
keyword: spurious failure, performance, loop
compare_exchange_weak - 弱比较交换:
可能虚假失败，即使在比较相等时也可能失败；但性能较好，使用时配以循环。

虚假失败的原因:
(1) 架构相关的实现
[source, cpp]
----
// 在某些架构上（如ARM, PowerPC），LL/SC指令机制可能导致失败
bool compare_exchange_weak_impl(int& expected, int desired) {
    // 加载-链接(Load-Linked)
    int current = load_linked(&value);
    
    if (current != expected) {
        return false;  // 真正的失败
    }
    
    // 条件存储(Conditional Store) - 这里可能失败！
    // 即使条件满足，如果其他线程修改了附近内存或发生中断，存储可能失败
    bool stored = store_conditional(&value, desired);
    
    return stored;  // 可能虚假失败
}
----
(2) 内存对齐和缓存行
[source, cpp]
----
struct Data {
    std::atomic<int> a;
    std::atomic<int> b;  // 可能在同一个缓存行
};

void cache_line_issue() {
    Data data;
    data.a = 1;
    data.b = 2;
    
    int expected_a = 1;
    
    // 线程1
    auto thread1 = [&]() {
        // 即使没有线程修改data.a，对data.b的修改也可能导致data.a的CAS失败
        while (!data.a.compare_exchange_weak(expected_a, 3)) {
            // 可能因为data.b被修改而虚假失败
        }
    };
    
    // 线程2
    auto thread2 = [&]() {
        data.b.store(5);  // 修改相邻内存
    };
}
----

vs. atomic_exchange/atomic_exchange_explicit:
atomic_exchange( volatile A* obj, C desired );
atomic_exchange_explicit( volatile A* obj, C desired, memory_order order );
是无条件(即无比较)更新
https://en.cppreference.com/w/c/atomic/atomic_exchange.html

https://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11
https://stackoverflow.com/questions/17914630/when-should-stdatomic-compare-exchange-strong-be-use

NOTE: 避免在并发代码中使用浮点数原子操作时的意外行为。Note that although you can use std::atomic<float> or std::atomic<double>, because the built-in floating point types do satisfy the criteria for use with memcpy and memcmp, the behavior may be surprising in the case of compare_exchange_strong. The operation may fail even though the old stored value was equal in value to the comparand, if the stored value had a different representation. Note that there are no atomic arithmetic operations on floating-point values. You’ll get similar behavior with compare_exchange_strong if you use std::atomic<> with a user-defined type that has an equality-comparison operator defined, and that operator differs from the comparison using memcmp—the operation may fail because the otherwise-equal values have a different representation.
参考: https://stackoverflow.com/questions/66566810/why-does-compare-exchange-strong-fail-with-stdatomicdouble-stdatomicfloa

Q: compare_exchange vs. test_and_set
test_and_set操作对象：通常是一个布尔值（或单个比特位）。
语义：无条件地将目标内存位置设置为 true（或 1），并返回该位置的旧值。
用途：主要用于实现简单的自旋锁。如果返回的旧值是 false，表示成功获得了锁；如果是 true，表示锁已被其他线程持有。
在现代多线程编程中，compare_exchange 的用途远广于 test_and_set。

Q: C++ compare_exchange vs. Java CAS
A:
(1) C++提供了weak和strong两种版本，weak可能虚假失败，但性能更好；strong保证不会虚假失败。
(2) C++可以指定memory_order，Java的原子操作使用其volatile语义（类似acquire-release）。
(3) Java提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题，通过版本号或标记位来避免ABA问题:
AtomicStampedReference(V initialRef, int initialStamp) // 构造时指定初始引用和版本号
compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) // 同时比较引用和版本号

==== fetch_and_add(FAA)
Q: 100个线程同时执行 fetch_add(1, relaxed)，最终结果一定会增加100么？
A: 是。
保证单个变量的修改顺序对所有线程一致:
    每个fetch_add都是原子的
    所有线程最终会对counter的修改顺序达成一致
    不会有数据竞争导致的值损坏

https://en.cppreference.com/w/cpp/atomic/atomic/fetch_add.html
https://en.wikipedia.org/wiki/Fetch-and-add

==== test_and_set(TAS)
std::atomic_flag::test_and_set:
Atomically changes the state of a std::atomic_flag to set (true) and returns the value it held before.
反操作:
std::atomic_flag::clear:
Atomically changes the state of a std::atomic_flag to clear 

std::atomic_flag:
std::atomic_flag is an atomic boolean type. Unlike all specializations of std::atomic, it is guaranteed to be lock-free(std::atomic_flag总是无锁的). Unlike std::atomic<bool>, std::atomic_flag does not provide load or store operations.

https://en.cppreference.com/w/cpp/atomic/atomic_flag/test_and_set.html
https://en.wikipedia.org/wiki/Test-and-set

TTAS(Test-And-Test-And-Set):
https://en.wikipedia.org/wiki/Test_and_test-and-set
《The Art of Multiprocessor Programming 2nd》7.3 Test-and-set locks
 
==== std::atomic<T>::is_lock_free
https://en.cppreference.com/w/cpp/atomic/atomic/is_lock_free.html

如果返回 true，表示该类型的原子操作使用 CPU 的原子指令实现，不需要内部锁
如果返回 false，表示该类型可能需要内部互斥锁来实现原子性

类型	             通常无锁？	          说明
std::atomic<bool>	   是	       布尔类型通常无锁
std::atomic<int>	   是	       基本整数类型通常无锁
std::atomic<long>	   是	       如果平台支持
std::atomic<T*>	       是	       指针类型通常无锁
std::atomic<double>	 可能是	       取决于平台和大小
std::atomic<struct>	 可能否	       如果结构体太大或不对齐

==== operator=
使用 sequential consistency (memory_order_seq_cst) 内存序
https://cplusplus.com/reference/atomic/atomic/operator=/
https://en.cppreference.com/w/cpp/atomic/atomic/operator=.html

Q: 以下这段代码有无问题？为什么？
[source, cpp]
.《C++ Concurrency in Action 2nd Edition》Listing 5.2
----
std::vector<int> data;
std::atomic_bool data_ready(false);

void reader_thread()
{
    while(!data_ready.load())
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
    std::cout<<"The answer="<<data[0]<<"\n";
}
void writer_thread()
{
    data.push_back(42);
    data_ready=true;
}
----

==== API
- c++
https://en.cppreference.com/w/cpp/atomic/atomic
可以对满足平凡可复制(TriviallyCopyable)要求的类/结构体使用 std::atomic<T>
更常见的做法是对类中的特定成员变量使用原子类型

- java
java.util.concurrent.atomic
volatile
since Java 9: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/VarHandle.html

- csharp
https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked
volatile、Volatile

==== impl
Implementing Your Own C++ Atomics - Ben Saks - CppCon 2025
https://zhuanlan.zhihu.com/p/1988644189492254385

==== 参考
https://github.com/MattPD/cpplinks/blob/master/atomics.lockfree.memory_model.md