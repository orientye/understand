# 槽（Slot）的可视化示例

## 场景设置

假设我们有一个容量为 **4** 的队列：
- `capacity = 4`
- `stride = 3`（假设计算出的步长）
- 有 2 个生产者线程（P1, P2）和 2 个消费者线程（C1, C2）

## 初始状态

```
队列结构：
┌─────────────────────────────────────────────┐
│ [pad] [slot0] [slot1] [slot2] [slot3] [pad]│
└─────────────────────────────────────────────┘

票号状态：
pushTicket_ = 0
popTicket_  = 0
```

## 时间线示例

### T1: P1 写入元素 A（票号 0）

```
1. 获取票号: ticket = 0
2. 计算槽: idx(0, 4, 3) = (0 * 3) % 4 = 0 → slot[0]
3. 计算轮次: turn(0, 4) = 0 / 4 = 0
4. 等待: sequencer_.waitForTurn(0 * 2) = turn 0（写入轮次）
5. 写入: new (&slot[0].contents_) T(A)
6. 完成: sequencer_.completeTurn(0 * 2)

队列状态：
┌─────────────────────────────────────────────┐
│ [pad] [  A  ] [slot1] [slot2] [slot3] [pad]│
│        ↑                                    │
│     已写入，等待读取                        │
└─────────────────────────────────────────────┘

pushTicket_ = 1
popTicket_  = 0
```

### T2: P2 写入元素 B（票号 1）

```
1. 获取票号: ticket = 1
2. 计算槽: idx(1, 4, 3) = (1 * 3) % 4 = 3 → slot[3]
3. 计算轮次: turn(1, 4) = 1 / 4 = 0
4. 等待: sequencer_.waitForTurn(0 * 2) = turn 0（写入轮次）
5. 写入: new (&slot[3].contents_) T(B)
6. 完成: sequencer_.completeTurn(0 * 2)

队列状态：
┌─────────────────────────────────────────────┐
│ [pad] [  A  ] [slot1] [slot2] [  B  ] [pad]│
│        ↑                    ↑               │
│     已写入               已写入             │
└─────────────────────────────────────────────┘

pushTicket_ = 2
popTicket_  = 0
```

**注意：** P1 和 P2 **并行操作不同的槽**（slot[0] 和 slot[3]），互不干扰！

### T3: C1 读取元素（票号 0）

```
1. 获取票号: ticket = 0
2. 计算槽: idx(0, 4, 3) = 0 → slot[0]
3. 计算轮次: turn(0, 4) = 0
4. 等待: sequencer_.waitForTurn(0 * 2 + 1) = turn 1（读取轮次）
   └─ 等待 slot[0] 的 turn 0 写入完成（已完成）
5. 读取: elem = move(slot[0].contents_) → 得到 A
6. 完成: sequencer_.completeTurn(0 * 2 + 1)

队列状态：
┌─────────────────────────────────────────────┐
│ [pad] [空槽] [slot1] [slot2] [  B  ] [pad]│
│        ↑                                    │
│     已读取，可以用于下一轮                  │
└─────────────────────────────────────────────┘

pushTicket_ = 2
popTicket_  = 1
```

### T4: C2 读取元素（票号 1）

```
1. 获取票号: ticket = 1
2. 计算槽: idx(1, 4, 3) = 3 → slot[3]
3. 计算轮次: turn(1, 4) = 0
4. 等待: sequencer_.waitForTurn(0 * 2 + 1) = turn 1（读取轮次）
5. 读取: elem = move(slot[3].contents_) → 得到 B
6. 完成: sequencer_.completeTurn(0 * 2 + 1)

队列状态：
┌─────────────────────────────────────────────┐
│ [pad] [空槽] [slot1] [slot2] [空槽] [pad]│
│                                              │
│     所有槽都空闲，可以用于下一轮            │
└─────────────────────────────────────────────┘

pushTicket_ = 2
popTicket_  = 2
```

## 槽的重复使用示例

### 当票号超过容量时

假设现在 `pushTicket_ = 4`，要写入元素 E：

```
1. 获取票号: ticket = 4
2. 计算槽: idx(4, 4, 3) = (4 * 3) % 4 = 0 → slot[0]
3. 计算轮次: turn(4, 4) = 4 / 4 = 1 ← **新的轮次！**

关键点：
- 票号 0 和 4 使用同一个槽 slot[0]
- 但轮次不同：turn 0 vs turn 1
- TurnSequencer 确保不会混淆
```

### 轮次序列可视化

```
slot[0] 的完整生命周期：
┌─────────────────────────────────────────────┐
│ Turn 0 (写入): ticket 0 写入 A              │
│   ↓                                         │
│ Turn 1 (读取): ticket 0 读取 A              │
│   ↓                                         │
│ Turn 2 (写入): ticket 4 写入 E              │ ← 重复使用
│   ↓                                         │
│ Turn 3 (读取): ticket 4 读取 E              │
│   ↓                                         │
│ Turn 4 (写入): ticket 8 写入 I              │ ← 再次重复使用
│   ↓                                         │
│ ...                                         │
└─────────────────────────────────────────────┘
```

## 并发场景：多个操作同时进行

### 场景：4 个线程同时操作

```
时间点 T0:
┌─────────────────────────────────────────────┐
│ P1: 准备写入 ticket=0 → slot[0], turn=0    │
│ P2: 准备写入 ticket=1 → slot[3], turn=0    │
│ C1: 准备读取 ticket=0 → slot[0], turn=0    │
│ C2: 准备读取 ticket=1 → slot[3], turn=0    │
└─────────────────────────────────────────────┘

时间点 T1（并行执行）:
┌─────────────────────────────────────────────┐
│ P1: 正在写入 slot[0] ← 并行                 │
│ P2: 正在写入 slot[3] ← 并行                 │
│ C1: 等待 slot[0] 写入完成 ← 阻塞            │
│ C2: 等待 slot[3] 写入完成 ← 阻塞            │
└─────────────────────────────────────────────┘

时间点 T2（P1, P2 完成）:
┌─────────────────────────────────────────────┐
│ P1: 完成写入 slot[0]                        │
│ P2: 完成写入 slot[3]                        │
│ C1: 唤醒，开始读取 slot[0] ← 并行            │
│ C2: 唤醒，开始读取 slot[3] ← 并行            │
└─────────────────────────────────────────────┘
```

## 槽索引映射表（capacity=4, stride=3）

| 票号 | 计算过程 | 槽索引 | 轮次 | 说明 |
|------|---------|--------|------|------|
| 0    | (0×3) % 4 = 0 | slot[0] | 0 | 第一轮 |
| 1    | (1×3) % 4 = 3 | slot[3] | 0 | 第一轮 |
| 2    | (2×3) % 4 = 2 | slot[2] | 0 | 第一轮 |
| 3    | (3×3) % 4 = 1 | slot[1] | 0 | 第一轮 |
| 4    | (4×3) % 4 = 0 | slot[0] | 1 | **重复使用 slot[0]，但轮次+1** |
| 5    | (5×3) % 4 = 3 | slot[3] | 1 | **重复使用 slot[3]，但轮次+1** |
| 6    | (6×3) % 4 = 2 | slot[2] | 1 | **重复使用 slot[2]，但轮次+1** |
| 7    | (7×3) % 4 = 1 | slot[1] | 1 | **重复使用 slot[1]，但轮次+1** |
| 8    | (8×3) % 4 = 0 | slot[0] | 2 | **再次重复使用 slot[0]，轮次+2** |

## 关键理解点

### 1. 槽 ≠ 队列位置

- **槽**是物理存储单元
- **队列位置**是逻辑概念（由票号决定）
- 多个队列位置可能映射到同一个槽（不同轮次）

### 2. 并行性来源

```
传统队列（单槽）：
操作1 → 操作2 → 操作3 → 操作4（串行）

MPMCQueue（多槽）：
操作1 → slot[0] ┐
操作2 → slot[3] ├─ 并行执行
操作3 → slot[2] │
操作4 → slot[1] ┘
```

### 3. 轮次的作用

轮次让有限的槽可以处理无限的操作：

```
槽数量: 4
票号范围: 0, 1, 2, ..., 1000, 1001, ...

通过轮次，每个槽可以处理：
- 票号 0, 4, 8, 12, ... (turn 0, 1, 2, 3, ...)
- 票号 1, 5, 9, 13, ... (turn 0, 1, 2, 3, ...)
- 票号 2, 6, 10, 14, ... (turn 0, 1, 2, 3, ...)
- 票号 3, 7, 11, 15, ... (turn 0, 1, 2, 3, ...)
```

## 总结

**槽的核心理解：**

1. **物理存储**：每个槽是一个 `SingleElementQueue`，存储一个元素
2. **并行基础**：多个槽允许不同操作并行执行
3. **无限复用**：通过轮次机制，槽可以无限重复使用
4. **同步保证**：`TurnSequencer` 确保每个槽的写入和读取顺序正确
5. **性能优化**：步长分散访问，减少缓存冲突

**一句话总结：**
槽是队列的"房间"，票号决定使用哪个房间，轮次决定是第几批客人。

