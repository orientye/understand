# MPMCQueue 中的"槽"（Slot）详解

## 什么是槽？

**槽（Slot）** 就是 `SingleElementQueue`，它是队列中的一个**存储单元**，每个槽可以存储**一个元素**。

```cpp
struct SingleElementQueue {
    aligned_storage_for_t<T> contents_;  // 存储一个 T 类型的元素
    TurnSequencer<Atom> sequencer_;      // 同步机制
};
```

## 槽的物理结构

### 1. 槽数组

队列内部是一个**槽数组**：

```
MPMCQueue (capacity = 8)
┌─────────────────────────────────────────────────────────┐
│ [padding] [slot0] [slot1] [slot2] ... [slot7] [padding] │
└─────────────────────────────────────────────────────────┘
     ↑                                                    ↑
  kSlotPadding                                        kSlotPadding
```

- **实际槽数** = `capacity + 2 * kSlotPadding`
- **两端填充**：避免 false sharing（缓存行冲突）

### 2. 单个槽的内部结构

```
SingleElementQueue
┌─────────────────────────────┐
│ contents_ (sizeof(T) 字节)  │  ← 存储元素的地方
│ sequencer_ (TurnSequencer)  │  ← 同步机制
└─────────────────────────────┘
```

## 槽如何工作？

### 核心思想：票号 → 槽索引 → 轮次

队列使用**票号系统**将操作映射到槽：

```cpp
// 1. 获取票号
uint64_t ticket = pushTicket_++;  // 例如：ticket = 5

// 2. 计算使用哪个槽
size_t slot_index = idx(ticket, capacity, stride);
// idx(5, 8, 3) = ((5 * 3) % 8) + padding = 7 + padding

// 3. 计算轮次（因为槽会重复使用）
uint32_t turn = turn(ticket, capacity);
// turn(5, 8) = 5 / 8 = 0
```

### 示例：容量为 8 的队列

假设 `stride = 3`，`capacity = 8`：

| 票号 | 槽索引计算 | 实际槽 | 轮次 |
|------|-----------|--------|------|
| 0    | (0×3) % 8 = 0 | slot[0] | 0 |
| 1    | (1×3) % 8 = 3 | slot[3] | 0 |
| 2    | (2×3) % 8 = 6 | slot[6] | 0 |
| 3    | (3×3) % 8 = 1 | slot[1] | 0 |
| 4    | (4×3) % 8 = 4 | slot[4] | 0 |
| 5    | (5×3) % 8 = 7 | slot[7] | 0 |
| 6    | (6×3) % 8 = 2 | slot[2] | 0 |
| 7    | (7×3) % 8 = 5 | slot[5] | 0 |
| 8    | (8×3) % 8 = 0 | slot[0] | 1 ← **同一个槽，但轮次不同** |
| 9    | (9×3) % 8 = 3 | slot[3] | 1 |

**关键点：**
- 票号 0 和 8 使用**同一个槽**（slot[0]）
- 但**轮次不同**（turn 0 vs turn 1）
- 这通过 `TurnSequencer` 来区分

## 槽的生命周期：写入和读取

### 写入流程（Enqueue）

```
线程 A 要写入元素 X，票号 = 5
┌─────────────────────────────────────────────────┐
│ 1. 获取票号: ticket = 5                         │
│ 2. 计算槽: slot_index = idx(5, 8, 3) = 7       │
│ 3. 计算轮次: turn = turn(5, 8) = 0              │
│ 4. 等待轮次: sequencer_.waitForTurn(0 * 2)      │
│    └─ 等待 slot[7] 的 turn 0 可用              │
│ 5. 构造元素: new (&contents_) T(X)              │
│ 6. 完成轮次: sequencer_.completeTurn(0 * 2)     │
│    └─ 通知等待的读者                            │
└─────────────────────────────────────────────────┘
```

### 读取流程（Dequeue）

```
线程 B 要读取元素，票号 = 5
┌─────────────────────────────────────────────────┐
│ 1. 获取票号: ticket = 5                         │
│ 2. 计算槽: slot_index = idx(5, 8, 3) = 7       │
│ 3. 计算轮次: turn = turn(5, 8) = 0              │
│ 4. 等待轮次: sequencer_.waitForTurn(0 * 2 + 1)  │
│    └─ 等待 slot[7] 的 turn 0 写入完成           │
│ 5. 提取元素: elem = move(contents_)              │
│ 6. 完成轮次: sequencer_.completeTurn(0 * 2 + 1) │
│    └─ 通知等待的写者（可以写入下一轮）          │
└─────────────────────────────────────────────────┘
```

## TurnSequencer：槽的同步机制

### 轮次编号规则

- **偶数轮次**：写入操作（0, 2, 4, ...）
- **奇数轮次**：读取操作（1, 3, 5, ...）

```
同一个槽 slot[0] 的轮次序列：
┌─────────────────────────────────────────────┐
│ Turn 0 (写入): 票号 0 写入                  │
│ Turn 1 (读取): 票号 0 读取                  │
│ Turn 2 (写入): 票号 8 写入                  │
│ Turn 3 (读取): 票号 8 读取                  │
│ Turn 4 (写入): 票号 16 写入                 │
│ ...                                         │
└─────────────────────────────────────────────┘
```

### 同步保证

`TurnSequencer` 确保：
1. **写入者**必须等待前一轮读取完成（turn 0 等待 turn -1 完成）
2. **读取者**必须等待对应写入完成（turn 1 等待 turn 0 完成）

## 为什么需要多个槽？

### 并行性

如果只有一个槽，所有操作必须串行：

```
单槽队列（串行）：
┌─────┐
│槽 0 │ ← 所有操作排队
└─────┘
```

多个槽允许**并行操作**：

```
多槽队列（并行）：
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│槽 0 │ │槽 1 │ │槽 2 │ │槽 3 │ ← 可以同时操作不同槽
└─────┘ └─────┘ └─────┘ └─────┘
```

### 示例：4 个线程同时操作

```
时间线：
T1: 写入 ticket=0 → slot[0] (并行)
T2: 写入 ticket=1 → slot[3] (并行)
T3: 读取 ticket=0 → slot[0] (等待 T1 完成)
T4: 读取 ticket=1 → slot[3] (等待 T2 完成)
```

## 槽的重复使用：轮次机制

### 问题：槽数量有限

如果 `capacity = 8`，只有 8 个槽，但票号可以无限增长（0, 1, 2, ..., 1000, ...）

### 解决方案：轮次（Turn）

每个槽可以**重复使用**，用轮次区分：

```
slot[0] 的使用历史：
┌─────────────────────────────────────────────┐
│ 票号 0  → turn 0 (写入) → turn 1 (读取)     │
│ 票号 8  → turn 2 (写入) → turn 3 (读取)     │
│ 票号 16 → turn 4 (写入) → turn 5 (读取)     │
│ ...                                         │
└─────────────────────────────────────────────┘
```

**公式：**
```cpp
turn = ticket / capacity
```

## 步长（Stride）的作用

### 避免 False Sharing

如果按顺序使用槽：
```
slot[0] slot[1] slot[2] slot[3] ...
         ↑
    可能在同一个缓存行
```

使用步长分散访问：
```
stride = 3
ticket 0 → slot[0]
ticket 1 → slot[3]  ← 跳过了 slot[1] 和 slot[2]
ticket 2 → slot[6]
ticket 3 → slot[1]
```

这样可以减少缓存行冲突。

## 槽的状态转换

### 单个槽的状态

```
┌─────────────┐
│   空闲      │ ← 初始状态
└─────┬───────┘
      │ 写入者获取 turn N (偶数)
      ↓
┌─────────────┐
│  写入中     │ ← 正在构造元素
└─────┬───────┘
      │ 写入完成
      ↓
┌─────────────┐
│  有数据     │ ← 元素已构造，等待读取
└─────┬───────┘
      │ 读取者获取 turn N+1 (奇数)
      ↓
┌─────────────┐
│  读取中     │ ← 正在提取元素
└─────┬───────┘
      │ 读取完成
      ↓
┌─────────────┐
│   空闲      │ ← 可以用于下一轮（turn N+2）
└─────────────┘
```

## 总结

**槽（Slot）的本质：**

1. **存储单元**：每个槽存储一个元素
2. **并行基础**：多个槽允许并行操作
3. **重复使用**：通过轮次机制，槽可以无限重复使用
4. **同步机制**：`TurnSequencer` 确保写入和读取的正确顺序
5. **性能优化**：步长和填充避免缓存冲突

**关键理解：**
- 票号决定**使用哪个槽**和**第几轮**
- 槽是**物理存储**，轮次是**逻辑区分**
- 多个槽 = 更高的并行度

