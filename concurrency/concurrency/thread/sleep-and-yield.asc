:hardbreaks-option:

=== sleep-and-yield

==== sleep
除非测试，否则尽量不用sleep:
使用select/poll/epoll_wait或者条件变量等方式:
https://stackoverflow.com/questions/3125645/why-use-select-instead-of-sleep
https://www.gnu.org/software/libc/manual/html_node/Sleeping.html
https://stackoverflow.com/questions/264350/is-there-an-alternative-for-sleep-in-c

sleep的问题:

    // 典型的 sleep 循环模式
    while (!is_data_ready) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        // 醒来检查条件
        check_condition();
    }
    1. 响应延迟
    2. CPU浪费：频繁唤醒检查
    3. 不精确：条件可能在sleep后立即满足

https://en.cppreference.com/w/cpp/thread/sleep_for.html

==== yield
https://en.cppreference.com/w/cpp/thread/yield.html

std::this_thread::yield() 会提示调度器：现在可以暂停，让其他线程先运行，但线程立即进入就绪队列，可能很快又被调度执行。
std::this_thread::sleep_for() 会让线程进入阻塞状态指定时间，期间不会被调度器考虑。

特性	yield	sleep
目的	主动让出CPU给其他线程	暂停线程执行指定时间
时间控制	不指定时间，立即恢复就绪状态	指定精确的休眠时间
线程状态	从运行态 → 就绪态	从运行态 → 阻塞态
调度器行为	立即重新调度	计时结束后才进入就绪队列
典型用途	协作式多任务、自旋锁优化	定时任务、节流、延迟执行