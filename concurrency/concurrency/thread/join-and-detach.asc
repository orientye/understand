:toc:
:toclevels: 5
:hardbreaks-option:

=== join and detach
==== join
If a thread is not detached, then we must join with it using pthread_join(). If we fail to do this, then, when the thread terminates, it produces the thread equivalent of a zombie process. Aside from wasting system resources, if enough thread zombies accumulate, we won’t be able to create additional threads.

可连接线程(Joinable / Non-Detached Thread):
    线程的默认属性（除非显式设置创建为分离的）。
    这种线程终止后，它的退出状态（返回值）和线程资源（如栈空间）不会立即被系统回收。
    必须由另一个线程调用 pthread_join() 来回收它。这个过程会获取线程的返回值并释放其所有资源。
    类比: 这就像进程中的 wait() 或 waitpid() 系统调用。如果一个可连接线程从未被 join，它就会变成一个僵尸线程，浪费系统资源。

==== detach
Detaching a thread doesn’t make it immune to a call to exit() in another thread or a return in the main thread. In such an event, all threads in the process are imme-diately terminated, regardless of whether they are joinable or detached. To put things another way, pthread_detach() simply controls what happens after a thread terminates, not how or when it terminates.

分离线程(Detached Thread):
    线程终止后，其资源和退出状态会由系统自动回收。
    其它线程无法对它使用 pthread_join() 来获取其返回值。

可以通过两种方式进行设置:
    在创建线程时，设置线程属性为 PTHREAD_CREATE_DETACHED。
    在线程创建后，调用 pthread_detach()。

==== cpp
https://en.cppreference.com/w/cpp/thread/thread/join.html
https://en.cppreference.com/w/cpp/thread/thread/detach.html

==== java
https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#join--

In Java, there's no explicit "detach" method like in some other languages, but there are several ways to achieve similar behavior.

==== join的实现
https://github.com/walac/glibc/blob/master/nptl/pthread_join.c

join的可见性:
• As a thread terminates, all written variables are flushed to main memory.
• If a thread uses join to synchronize on the termination of another thread, then it’s guaranteed to see the effects made by that thread

lll_wait_tid (pd->tid)
这是让当前线程进入等待状态的核心调用。
pd->tid：这是目标线程的内核线程ID。线程结束时，内核会将其 tid 设置为0或-1等特定值。
lll_wait_tid：这通常是一个对 Linux futex 系统调用的封装。它的作用是以 pd->tid 为地址，检查其值，如果不符合预期（即线程还未终止），则让当前线程在内核中休眠。
同步与可见性：当目标线程终止时，内核会修改 pd->tid 并唤醒所有在此 futex 上等待的线程。这个从内核唤醒的过程伴随着完整的内存屏障，确保了被等待线程的所有修改对刚被唤醒的等待者线程完全可见。这就是 join 如何保证可见性的最根本实现。