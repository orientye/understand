:toc:
:toclevels: 5
:hardbreaks-option:

=== overview
==== 概念
▪ thread-safe

▪ creation, termination, cancellation
▪ join detach
▪ once
▪ per-thread-variables/thread-specific data/thread-local storage
▪ thread-pool
▪ sleep yield
▪ schedule policy and priority

▪ volatile
▪ atomic
▪ cacheline
▪ memory order/fence/barrier
▪ mutex, spin lock, rw lock, semaphore...
▪ rcu

▪ condition_variable, wait/notify, future/promise

▪ impletation
▪ signal
▪ process control

==== pthread
https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html

There are around 100 threads procedures, all prefixed pthread_ and they can be categorized into four groups:

(1)Thread management - creating, joining threads etc.
(2)Mutexes
(3)Condition variables
(4)Synchronization between threads using read/write locks and barriers

The POSIX semaphore API works with POSIX threads but is not part of threads standard, having been defined in the POSIX.1b, Real-time extensions (IEEE Std 1003.1b-1993) standard. Consequently, the semaphore procedures are prefixed by sem_ instead of pthread_.

==== cpp
https://en.cppreference.com/w/cpp/thread

==== java
https://github.com/orientye/understand/blob/main/lan/java.asc#concurrency
http://www.sti.uniurb.it/events/sfm15mp/slides/lea.2.pdf

==== impl-overview
===== 历史
- Linux Threads(已废弃), NTPL(now)
https://en.wikipedia.org/wiki/LinuxThreads
https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library

- HTL - LinuxThreads 最初的 Linux 线程实现

    时期: 1996-2003 年
    作者: Xavier Leroy
    状态: 已废弃，从 glibc 2.4 开始被移除

    # 在 HTL 中，每个线程都是独立的进程
        $ ps -eLf | grep myprogram
        UID    PID   PPID   LWP   NLWP CMD
        user  1001   1000  1001     1 myprogram  # 主线程
        user  1002   1001  1002     1 myprogram  # 线程1  
        user  1003   1001  1003     1 myprogram  # 线程2
    # 在 NPTL 中，所有线程属于同一个进程
        $ ps -eLf | grep myprogram
        UID    PID   PPID   LWP   NLWP CMD
        user  1001   1000  1001     4 myprogram  # 主线程 (LWP=1001)
        user  1001   1000  1002     4 myprogram  # 线程1 (LWP=1002)
        user  1001   1000  1003     4 myprogram  # 线程2 (LWP=1003)

- NPTL - Native POSIX Threads Library 现代 Linux 的标准线程实现

    引入时间: 2003 年 (Red Hat 开发)
    首次发布: glibc 2.3.2
    成为默认: 从 glibc 2.4 开始
    当前状态: Linux 标准线程实现

- NPTL 需要 Linux 2.6+ 内核的支持:

    futex(2) - 快速用户空间互斥锁
    CLONE_THREAD 标志
    每线程终止信号 (SIGRTMIN)
    tgkill(2) - 线程定向信号

===== Thread Implementation Models

    how threads are mapped onto kernel scheduling entities (KSEs):
        Many-to-one (M:1) implementations (user-level threads)
        One-to-one (1:1) implementations (kernel-level threads)
        Many-to-many (M:N) implementations (two-level model)
    Both of the Linux threading implementations—LinuxThreads and NPTL—employ the 1:1 model.

===== thread-stack

image::img/stack-for-thread.png[]
Four threads executing in a process (Linux/x86-32)

Q: 线程堆栈默认大小？
per-thread-size默认大小: 8MB(x86-32)? 32MB(IA64)?
https://stackoverflow.com/questions/2340093/how-is-stack-size-of-linux-process-related-to-pthread-fork-and-exec