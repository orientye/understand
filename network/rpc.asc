= rpc
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com
<<<

== 概述
- 概念

    Remote Procedure Call，即远程过程调用
    用于解决分布式系统中服务之间的调用问题，实现调用远程方法就跟调用本地方法一样的体验

    服务、方法(参数与返回值)

- 调用方式

    同步
    异步
    并行

- 协议

    可扩展与向后兼容

- 序列化

    安全
    通用性
    兼容性
    性能
    空间开销

- 线程模型

- 动态代理

- 注册与发现

- 负载均衡

- 安全

- 扩展功能

    服务治理

== 序列化

=== protobuf
https://developers.google.com/protocol-buffers/docs/proto3
https://halfrost.com/protobuf_encode/

=== json
json vs. json5
JSON5 is an extension to the popular JSON file format that aims to be easier to write and maintain by hand (e.g. for config files). It is not intended to be used for machine-to-machine communication. (Keep using JSON or other file formats for that.)
json5: https://github.com/json5/json5

=== bson
https://github.com/mongodb/js-bson

=== messagepack
https://github.com/msgpack/msgpack/blob/master/spec.md

=== capnproto
核心思想: no encoding/decoding step
无拷贝序列化，本质上是开辟一个bytes slice作为buffer，所有对数据结构的读写操作都是直接读写buffer，读写完成后，在头部添加一些buffer的信息就可以直接发送，对端收到后即可读取。

参考:
https://www.cloudwego.io/zh/blog/2021/09/23/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-go-rpc-%E6%A1%86%E6%9E%B6-kitex-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/#%E6%97%A0%E6%8B%B7%E8%B4%9D%E5%BA%8F%E5%88%97%E5%8C%96

=== memorypack
类似capnproto，也是zero encoding
https://github.com/Cysharp/MemoryPack

=== 参考
https://stackoverflow.com/questions/21854687/improving-performance-of-protocol-buffers

== gRPC

=== 概要
https://hengyun.tech/thinking-about-grpc-http2/

=== 服务调用

    Unary RPC:  rpc simpleHello(Person) returns (Result) {}
    Server streaming RPC:  rpc serverStreamHello(Person) returns (stream Result) {}
    Client streaming RPC:  rpc clientStreamHello(stream Person) returns (Result) {}
    Bidirectional streaming RPC:  rpc biStreamHello(stream Person) returns (stream Result) {}

    普通RPC调用
        同步阻塞，通常实现类xxxBlockingStub(基于proto定义生成)
        异步非阻塞，基于Future-Listener机制，通常实现类xxxFutureStub
        异步非阻塞，基于Reactive的响应编程模式，通常实现类是xxxStub

    基于HTTP/2.0的streaming调用方式
        服务端streaming: 例如短信群发功能
        客户端streaming: 例如汇总功能
        双向streaming

参考: https://grpc.io/docs/what-is-grpc/core-concepts/

=== 语言形式
https://grpc.io/docs/languages/

cpp:
https://grpc.io/docs/languages/cpp/basics/
https://grpc.io/docs/languages/cpp/async/

c#:
https://learn.microsoft.com/zh-cn/aspnet/core/grpc
https://learn.microsoft.com/zh-cn/aspnet/core/grpc/performance

== Thrift
https://github.com/apache/thrift

== dubbo
=== 概览
https://cn.dubbo.apache.org/zh-cn/overview/home/

概念与架构:
https://cn.dubbo.apache.org/zh-cn/overview/what/overview/

与 gRPC、Spring Cloud、Istio 的关系:
https://cn.dubbo.apache.org/zh-cn/overview/what/xyz-difference/
gRPC定位为一款 RPC 框架，Dubbo定位是一款微服务开发框架

优势:
https://cn.dubbo.apache.org/zh-cn/overview/what/advantages/

=== 协议
https://cn.dubbo.apache.org/zh-cn/overview/reference/protocols/
https://cn.dubbo.apache.org/zh-cn/overview/core-features/protocols/
https://zhuanlan.zhihu.com/p/446499369

=== 线程模型
- 概要
https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/performance/threading-model/

- 通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:

	<dubbo:protocol name="dubbo" dispatcher="all" threadpool="fixed" threads="100" />

- Dispatcher

	all 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等
	direct 所有消息都不派发到线程池，全部在IO线程上直接执行
	message 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行
	execution 只有请求消息派发到线程池，响应和其它连接断开事件，心跳等消息，直接在IO线程上执行
	connection 在IO线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池

- ThreadPool

	fixed 固定大小线程池，启动时建立线程，不关闭，一直持有(缺省)
	cached 缓存线程池，空闲一分钟自动删除，需要时重建
	limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩是为了避免收缩时突然来了大流量引起的性能问题
	eager 优先创建Worker线程池
		在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。
		当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。
		阻塞队列充满时抛出RejectedExecutionException。
		(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)
	
- 参考
https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/examples/thread-model/

=== 高级特性与用法
https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/

=== 参考
https://github.com/apache/dubbo

== Spring Cloud

== brpc
https://github.com/orientye/understand/blob/main/misc/brpc.asc

== tars

== PhxRPC

== srpc
https://github.com/sogou/srpc/tree/master/docs
https://github.com/sogou/workflow/tree/master/docs

Workflow:
FAQ: https://github.com/sogou/workflow/issues/170
https://www.zhihu.com/question/20124494/answer/2298649258
https://zhuanlan.zhihu.com/p/165638263
https://zhuanlan.zhihu.com/p/484293077

SRPC架构介绍: https://zhuanlan.zhihu.com/p/249071112

== flare
https://github.com/Tencent/flare

== hertz
https://github.com/cloudwego/hertz

== kitex
https://github.com/cloudwego/kitex

参考:
https://www.cloudwego.io/zh/blog/2021/09/23/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-go-rpc-%E6%A1%86%E6%9E%B6-kitex-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/

== 实战

=== 超时与重试
==== 概念
超时的意义是什么？

重试的意义是什么？或者说什么情况下需要重试?

重试需要注意的问题？

https://cloud.tencent.com/developer/article/1605116

==== brpc
https://github.com/apache/brpc/blob/master/docs/cn/client.md#%E8%B6%85%E6%97%B6
https://github.com/apache/brpc/blob/master/docs/cn/client.md#%E9%87%8D%E8%AF%95

==== dubbo
dubbo支持非常细粒度的超时设置，包括：方法级别、接口级别和全局。
如果各个级别同时配置了，则优先级为：消费端方法级 > 服务端方法级 > 消费端接口级 > 服务端接口级 > 消费端全局 > 服务端全局。

==== grpc
https://learn.microsoft.com/zh-cn/aspnet/core/grpc/retries

=== 微服务开发
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/service-definition/
https://cn.dubbo.apache.org/zh-cn/overview/core-features/ecosystem/

=== 服务发现
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/service-discovery/

=== 负载均衡
==== brpc
https://github.com/apache/brpc/blob/master/docs/cn/load_balancing.md

==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/what/advantages/governance/#%E6%B5%81%E9%87%8F%E7%AE%A1%E6%8E%A7
https://cn.dubbo.apache.org/zh-cn/overview/core-features/load-balance/

==== grpc
https://learn.microsoft.com/zh-cn/aspnet/core/grpc/loadbalancing

=== 流量管控
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/tasks/traffic-management/

=== 通信协议
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/protocols/

=== 扩展适配
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/extensibility/

=== 观测服务
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/observability/

=== 认证鉴权
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/security/

=== 服务网格
==== dubbo
https://cn.dubbo.apache.org/zh-cn/overview/core-features/service-mesh/

=== 熔断
==== brpc
https://github.com/apache/brpc/blob/master/docs/cn/circuit_breaker.md

=== 容错
==== dubbo
https://cn.dubbo.apache.org/zh-cn/docs/advanced/fault-tolerent-strategy/


=== misc
==== 泛化服务
[source, java]
----
class GenericService {

    Object $invoke(String methodName, String[] paramTypes, Object[] params);

    CompletableFuture<Object> $asyncInvoke(String methodName, String[] paramTypes, Object[] params);

}
----

通过统一的GenericService接口类生成的动态代理，来实现在没有接口的情况下进行RPC调用的功能，称之为泛化调用。

==== 流量回放
相比TcpCopy、Nginx等流量回放方案，在RPC里内置流量回放功能，使用起来会更加方便，可以做更多定制化需求。

==== 启动与关闭
启动预热与延迟暴露

优雅关闭:
先保证不接收新请求，通知调用方下线，然后再处理关闭前收到的请求，最后关闭释放资源。
同时加上超时时间控制，当超过了指定时间没有结束，则强制退出应用。

=== demo
https://www.bilibili.com/video/BV1Qm411f71o
