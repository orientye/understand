= Computer Graphics
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
:stem: latexmath
<<<

== 图形渲染管线(The Graphics Render Pipeline)
=== 应用程序阶段(The Appliction Stage)
• 通过软件方式实现，开发者能够对该阶段发生的情况进行完全控制。其他阶段则全部或者部分建立在硬件基础上，改变其实现过程会非常困难。
• 一般使用CPU，也有些情况，例如compute shader会使用到GPU。
• 不能像几何和光栅化阶段那样继续分为若干个子阶段，但可以在几个并行处理器上同时执行。
• 通常包括碰撞检测、加速算法、输入检测、动画、物理仿真，以及一些不在其它阶段执行的计算，如层次视锥裁剪等加速算法。
• 将绘制图元(rendering primitives，如点、线、三角形等)输出到管线的几何处理阶段。

=== 几何处理阶段(The Geometry Processing Stage)
==== 顶点着色(Vertex Shading)
确定材质上的光照效果的操作称之为着色(shading)。
可在顶点处存储如位置，法线，颜色或者计算着色方程所需的其它信息。
顶点着色的计算完成后，其结果会被发送到光栅化阶段进行插值。

==== 投影(Projection)
投影是将模型从三维空间投射到二维空间的过程。

• 正交投影(Orthograpic Projection):
平行线在变换后彼此之间仍然保持平行。

• 透视投影(Perspective Projection):
越是远离摄像机的物体，投影后看起来越小。
透视投影是模拟人类感知物体的方式。

==== 裁剪(Clipping)
当图元完全或者部分处于视体内部时，才需要将其发送到光栅化阶段。
对于部分位于视体内部的图元，需要进行裁剪处理。

==== 屏幕映射(Screen Mapping)
将之前得到的空间坐标映射到屏幕坐标系上。

=== 光栅化阶段(The Rasterizier Stage)
==== 三角形建立(Tringle Setup)
主要用来计算三角形表面的差异和三角形表面的其他相关数据。

==== 三角形遍历(Tringle Traversal)
找到哪些采样点或像素在三角形中的过程通常叫三角形遍历(TriangleTraversal)或扫描转换(scan conversion)。

=== 像素处理阶段(The Pixel Processing Stage)
==== 像素着色(Pixel Shading)
在可编程GPU上执行，计算所有需逐像素操作的过程，例如纹理贴图。

Q: 片元 vs. 像素
https://www.khronos.org/opengl/wiki/Fragment

==== 融合(Merging)
合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，还负责可见性问题(Z缓冲相关)的处理。

== GPU
=== 数据并行架构(Data-Parallel Architectures)

参考:
https://zhuanlan.zhihu.com/p/598173226
https://medium.com/codex/understanding-the-architecture-of-a-gpu-d5d2d2e8978b

=== GPU管线总览(GPU Pipeline Overview)
=== 可编程着色器阶段(The Programmable Shader Stage)

=== 着色API演变(The Evolution of Programmable Shading and APIs)
2014 Metal
2016 Vulkan
https://en.wikipedia.org/wiki/High-Level_Shader_Language
https://en.wikipedia.org/wiki/OpenGL_Shading_Language

=== 顶点着色器(The Vertex Shader)
对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。

=== 曲面细分阶段(The Tessellation Stage)

=== 几何着色器(The Geometry Shader)
允许GPU高效地创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元(点、线、三角形)的顶点进行操作。几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片段着色器。

=== 像素着色器(The Pixel Shader)
常常又称为片断着色器，片元着色器(Fragment Shader，OpenGL 中的叫法)，是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。

=== 合并阶段(The Merging Stage)
尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改(Color Modifying)，Z缓冲(Z- buffer)，混合(Blend)，模板(Stencil)和相关缓存的处理。

=== 计算着色器(The Compute Shader)

== 数学基础
=== 向量

ifdef::env-github[]
- 表示: $\vec{a}$ 或者粗体表示 $\boldsymbol{a}$
- 方向: $\overrightarrow{AB}$ = $\boldsymbol{A-B}$
- 长度/模: $\Vert \vec{a} \Vert$ 或者 $|\vec{a}|$
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: $\hat{a}=\vec{a}/|\vec{a}|$
endif::[]

ifndef::env-github[]
- 表示: latexmath:[$\vec{a}$] 或者粗体表示 latexmath:[$\boldsymbol{a}$]
- 方向: latexmath:[$\overrightarrow{AB}$] = latexmath:[$\boldsymbol{A-B}$]
- 长度/模: latexmath:[$\Vert \vec{a} \Vert$] 或者 latexmath:[$|\vec{a}|$]
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: latexmath:[$\hat{a}=\vec{a}/|\vec{a}|$]
endif::[]

- 加法
    几何: 四边形法则 三角形法则
    代数: 坐标相加

- 图形学里一般使用列向量

- 转置

- 点乘 Dot(scalar) Product
ifdef::env-github[]
    ▪ $ a \cdot b = |\vec{a}| |\vec{b}| \cos\theta $
endif::[]
ifndef::env-github[]
    ▪ latexmath:[$ a \cdot b = |\vec{a}| |\vec{b}| \cos\theta $]
endif::[]
    ▪ 交换律
    ▪ 结合律
    ▪ 分配律
    ▪ 用途:
        向量间的夹角
        一个向量在另外一个向量上的投影(projection)
        向量的接近程度
        分解向量(decompose)
        前后关系(forward/backward)
    ▪ 也叫数量积/内积

- 坐标系
    ▪ 左手/右手
    ▪ 各平台、引擎的坐标系

- 叉乘 Cross(vector) Product
    ▪ 结果是一个向量
        其方向: 垂直于两个向量，右手坐标系
ifdef::env-github[]
        其长度: $ |a \times b| = |\vec{a}| |\vec{b}| \sin\theta $
endif::[]
ifndef::env-github[]
        其长度: latexmath:[$ |a \times b| = |\vec{a}| |\vec{b}| \sin\theta $]
endif::[]
    ▪ 反交换律
    ▪ 结合律
    ▪ 分配律
    ▪ 用途:
        构建坐标系
        左右关系
        内外(inside/outside)
        叉乘可以用矩阵乘以列向量矩阵来表示
    ▪ 向量积/外积

=== 矩阵
- 作用
    通常用来表示变换(transformation), 例如平移(translate)，旋转(rotate)，缩放(scale)，剪切/切变(shear)

- 性质
    交换律: 通常不满足
    结合律: 满足
    分配律: 满足

- 转置(transpose)

- 单位矩阵

- 逆矩阵(inverse)

- 向量操作的矩阵形式(Vector Operations in Matrix Form)

    Q: 点乘
    Q: 叉乘

- 矩阵与线性变换

    线性变换是一类满足线性条件的变换。
    线性条件: T(u+v) = T(u) + T(v) 和T(cu) = cT(u)
    向量的加法和数乘运算在变换前和变换后的效果是一样的，也就是说线性变换保持了向量的加法和数乘运算。
    https://www.zhihu.com/question/322319580

- 正交矩阵与旋转矩阵

    正交矩阵的逆=正交矩阵的转置
    旋转矩阵是正交矩阵。正交矩阵不一定是旋转矩阵。
    任何一组正交基向量在旋转矩阵的变换下仍然是正交的，因此旋转矩阵是正交矩阵。
    但是，反之就不一定，例如某镜像变换。
    https://www.zhihu.com/question/316200199

=== 变换(transformation)

==== 齐次坐标系(homogeneous coordinates)

    齐次坐标就是用N+1维来代表N维坐标。
    
    为什么需要齐次坐标系呢？
    在某些场合下，使用齐次坐标系更为合适:
    对于平移变换，如果维度不变，用矩阵左乘是表达不了平移操作的。加上一个维度后，平移才可以同旋转缩放等操作一样: 统一成矩阵变换的形式。
    对于透视变换，笛卡尔坐标系下平行线永不相交，这不适用于透视场景。
    再例如，点光源与方向光等也可以用齐次坐标来表示(例如，w=1: point light, w=0: directional light)。

    2维点: (x, y, 1)
    2维向量: (x, y, 0)
    3维点: (x, y, z, 1)
    3维向量: (x, y, z, 0)

    齐次坐标是图形学的重要手段之一，它既能够用来明确区分向量和点，也更易于进行仿射变换。

    参考:
    http://www.songho.ca/math/homogeneous/homogeneous.html
    https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/

==== 2D变换
===== 缩放变换(scale)

===== 反射变换(reflection)

===== 切变变换(shear)

===== 旋转变换(rotate)

===== 平移变换(translate)

===== 仿射变换(affine)
(先)线性变换 + (后)平移变换

===== 逆变换(inverse transform sampling)

===== composing transforms

===== decomposing transforms

==== 3D变换

===== 旋转

====== 绕任意轴的旋转
- 任意轴经过原点

    Rodrigues' rotation formula
    https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula

- 任意轴不经过原点
    
    转化为经过原点的任意轴旋转+平移

====== 欧拉角
pitch: 俯仰
yaw: 偏航
roll: 翻滚

优点: 直观易于理解；比矩阵省空间
缺点: 万向节死锁(Gimbal Lock)

什么是万向节死锁?
https://blog.csdn.net/huazai434/article/details/6458257
https://v.youku.com/v_show/id_XNzkyOTIyMTI=.html
https://www.bilibili.com/video/BV1e3411y7RX

https://www.zhihu.com/question/47736315
https://stackoverflow.com/questions/17044296/quaternion-rotation-without-euler-angles
https://stackoverflow.com/questions/9715776/using-quaternions-for-opengl-rotations/9716268#9716268
https://www.cnblogs.com/psklf/articles/5656938.html
https://www.cnblogs.com/psklf/p/5667593.html

====== 四元数(quaternion)
优点: 不存在万向节死锁问题；利于旋转插值；比较省空间
缺点: 误差问题导致失效；难于理解

如何理解四元数?

https://www.bilibili.com/video/BV1gP4y1a7vZ

https://www.zhihu.com/question/23005815
https://www.3dgep.com/understanding-quaternions/
https://www.qiujiawei.com/understanding-quaternions/

==== 3D到2D的变换

===== 模型变换(Modeling Tranformation)

===== 视图/摄像机变换(View/Camera Tranformation)
Camera属性: Position  LookAt  Up
想象拿着个相机拍照，Position是相机的位置，LookAt是相机的朝向，Up怎么理解呢？
相机是可以转动的，Up就是固定这个转动。

View矩阵

参考: https://learn.microsoft.com/en-us/previous-versions/ff729721(v=vs.85)#view-space

===== 投影变换(Projection Tranformation)

====== 正交投影(Orthograpic Projection)
也称Parallel Projection。

Ortho矩阵

应用:
一些较老的RTS游戏例如《帝国时代》会采用正交投影/正射投影，现代的RTS游戏还是会使用透视投影。

====== 透视投影(Perspective Projection)
Persp矩阵 -> Ortho矩阵

https://zhuanlan.zhihu.com/p/362713511#:~:text=%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98%EF%BC%9A-,%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%EF%BC%88Projection%20transformation%EF%BC%89,%E4%BA%A4%E6%8A%95%E5%BD%B1%E5%92%8C%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E3%80%82
https://juejin.cn/post/6994334681885835278

===== 视口变换(Viewport Tranformation)
l, r, b, t:  fovY(field of view) and aspect ratio
fovY and aspect ratio 转换成l, r, b, t:
    tan(fovY/2) = t/|n|;
    aspect = r/t;

屏幕

Viewport矩阵

===== 参考
https://learn.microsoft.com/en-us/windows/uwp/graphics-concepts/transforms

===== 小结
MVP变换

    模型变换(Model Transformation): 模型空间坐标->世界空间坐标
    摄像机变换(Camera Transformation): 世界空间坐标->观察空间坐标
    投影变换(Projection Transformation): 观察空间坐标->裁剪空间坐标

视口变换(Viewport Transformation): 裁剪空间坐标->屏幕空间坐标

V′ = Mviewport * Mpersepctive * Mview * Mmodel * V

== 物理基础

== 管线
=== 顶点着色器

=== 图元装配

=== 背面剔除

=== 光栅化
三角形的光栅化(rasterization)
抗锯齿/反走样(jaggies, Anti-Aliasing)

=== 测试
==== 裁剪测试

==== 采样

==== 模板测试

==== 深度测试

参考:
https://zhuanlan.zhihu.com/p/75517534

=== 混合

=== 抖动

== 纹理(texturing)

=== The Texturing Pipeline
=== Image Texturing
=== Procedural Texturing
=== Texture Animation
=== Material Mapping
=== Alpha Mapping
=== Bump Mapping
凹凸贴图(Bump Mapping)
移位贴图(Displacement Mapping)
法线贴图(Normal Mapping)
视差贴图(Parallax Mapping)
浮雕贴图(Relief Mapping)
=== Parallax Mapping
=== Textured Lights

== 阴影(shadow)
=== Planar Shadows
=== Shadows on Curved Surfaces
=== Shadow Volumes
=== Shadow Maps
=== Percentage-Closer Filtering
=== Percentage-Closer Soft Shadows
=== Filtered Shadow Maps
=== Volumetric Shadow Techniques
=== Irregular Z -Buffer Shadows
=== Other Applications

== 光照与颜色(light and color)

=== 概念
光源: 平行光源、点光源和聚光灯。

所有的光物质相互作用都是两种现象的结果: 散射(scattering)和吸收(absorption)。

散射(scattering)发生在当光线遇到任何种类的光学不连续性(optical discontinuity)时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。
散射不会改变光量，只是使其改变方向。
散射一般又分为反射(reflection)和折射(refraction)。

吸收(absorption)发生在物质内部，其会导致一些光转变成另一种能量并消失。
吸收会减少光量，但不会影响其方向。

Flat shading
Gouraud shading
Phong shading

=== Light Quantities
=== Scene to Screen

== 基于物理学的遮蔽(Physically Based Shading)
=== Physics of Light
=== The Camera
=== The BRDF
=== Illumination
=== Fresnel Reflectance
=== Microgeometry
=== Microfacet Theory
=== BRDF Models for Surface Reflection
=== BRDF Models for Subsurface Scattering
=== BRDF Models for Cloth
=== Wave Optics BRDF Models
=== Layered Materials
=== Blending and Filtering Materials

== 局部光照(Local Illumination)
=== Area Light Sources
=== Environment Lighting
=== Spherical and Hemispherical Functions
=== Environment Mapping
=== Specular Image-Based Lighting
=== Irradiance Environment Mapping
=== Sources of Error

== 全局光照(Global Illumination)
=== The Rendering Equation
=== General Global Illumination
=== Ambient Occlusion
=== Directional Occlusion
=== Diffuse Global Illumination
=== Specular Global Illumination
=== Unified Approaches

== 图像-空间效果(Image-Space Effects)
=== Image Processing
=== Reprojection Techniques
=== Lens Flare and Bloom
=== Depth of Field
=== Motion Blur

== 多边形之外(Beyond Polygons)
=== The Rendering Spectrum
=== Fixed-View Effects
=== Skyboxes
=== Light Field Rendering
=== Sprites and Layers
=== Billboarding
=== Displacement Techniques
=== Particle Systems
=== Point Rendering
=== Voxels

== 体积与半透明性渲染(Volumetric and Translucency Rendering)
=== Light Scattering Theory
=== Specialized Volumetric Rendering
=== General Volumetric Rendering
=== Sky Rendering
=== Translucent Surfaces
=== Subsurface Scattering
=== Hair and Fur
=== Unified Approaches

== 非写实渲染(Non-Photorealistic Rendering)
=== Toon Shading
=== Outline Rendering
=== Stroke Surface Stylization
=== Lines
=== Text Rendering

== 多边形技术(Polygonal Techniques)
=== Sources of Three-Dimensional Data
=== Tessellation and Triangulation
=== Consolidation
=== Triangle Fans, Strips, and Meshes
=== Simplification
=== Compression and Precision

== 曲线与曲面(Curves and Curved Surfaces)
=== Parametric Curves
=== Parametric Curved Surfaces
=== Implicit Surfaces
=== Subdivision Curves
=== Subdivision Surfaces
=== Efficient Tessellation

== 管道优化(Pipeline Optimization)
=== Profiling and Debugging Tools
=== Locating the Bottleneck
=== Performance Measurements
=== Optimization
=== Multiprocessing

== 加速算法(Acceleration Algorithms)
=== Spatial Data Structures
=== Culling Techniques
=== Backface Culling
=== View Frustum Culling
=== Portal Culling
=== Detail and Small Triangle Culling
=== Occlusion Culling
=== Culling Systems
=== Level of Detail
=== Rendering Large Scenes

== 高效阴影(Efficient Shading)
=== Deferred Shading
=== Decal Rendering
=== Tiled Shading
=== Clustered Shading
=== Deferred Texturing
=== Object and Texture-Space Shading

== 虚拟现实与增强现实(Virtual and Augmented Reality)

== 相交测试方法(Intersection Test Methods)
GPU-Accelerated Picking
Definitions and Tools
Bounding Volume Creation
Geometric Probability
Rules of Thumb
Ray/Sphere Intersection
Ray/Box Intersection
Ray/Triangle Intersection
Ray/Polygon Intersection
Plane/Box Intersection
Triangle/Triangle Intersection
Triangle/Box Intersection
Bounding-Volume/Bounding-Volume Intersection
View Frustum Intersection
Line/Line Intersection
Intersection between Three Planes

== 图形硬件(Graphics Hardware)
Rasterization
Massive Compute and Scheduling
Latency and Occupancy
Memory Architecture and Buses
Caching and Compression
Color Buffering
DepthCulling, Testing, and Buffering
Texturing
Architecture
Case Studies
Ray Tracing Architectures

== project
https://bellard.org/TinyGL/
https://github.com/ssloy/tinyrenderer/wiki
https://github.com/skywind3000/mini3d/blob/master/mini3d.c

== shader
https://developer.valvesoftware.com/wiki/Shader

== 参考
- https://www.zhihu.com/tardis/zm/ans/2311690807?source_id=1003

- 《Fundamentals of Computer Graphics, 5th》

- 《Real-Time Rendering 4rd》
https://www.realtimerendering.com/
https://github.com/QianMo/Real-Time-Rendering-4th-Bibliography-Collection

- GAMES101:
视频: https://www.bilibili.com/video/BV1X7411F744/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html

- GAMES102:
视频: https://www.bilibili.com/video/BV1NA411E7Yr/
课件: http://staff.ustc.edu.cn/~lgliu/Courses/GAMES102_2020/default.html

- GAMES103:
视频: https://www.bilibili.com/video/BV12Q4y1S73g/
课件: https://games-cn.org/games103/

- GAMES201:
视频: https://www.bilibili.com/video/BV1ZK411H7Hc
课件: https://yuanming.taichi.graphics/teaching/2020-games201/

- GAMES202:
视频: https://www.bilibili.com/video/BV1YK4y1T7yY/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html

- 太极图形:
https://space.bilibili.com/1779922645
 