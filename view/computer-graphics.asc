= Computer Graphics
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
:stem: latexmath
<<<

== 图形渲染管线(The Graphics Render Pipeline)
=== 应用程序阶段(The Appliction Stage)
• 通过软件方式实现，开发者能够对该阶段发生的情况进行完全控制。其他阶段则全部或者部分建立在硬件基础上，改变其实现过程会非常困难。
• 一般使用CPU，也有些情况，例如compute shader会使用到GPU。
• 不能像几何和光栅化阶段那样继续分为若干个子阶段，但可以在几个并行处理器上同时执行。
• 通常包括碰撞检测、加速算法、输入检测、动画、物理仿真，以及一些不在其它阶段执行的计算，如层次视锥裁剪等加速算法。
• 将绘制图元(rendering primitives，如点、线、三角形等)输出到管线的几何处理阶段。

=== 几何处理阶段(The Geometry Processing Stage)
==== 顶点着色(Vertex Shading)
确定材质上的光照效果的操作称之为着色(shading)。
可在顶点处存储如位置，法线，颜色或者计算着色方程所需的其它信息。
顶点着色的计算完成后，其结果会被发送到光栅化阶段进行插值。

==== 投影(Projection)
投影是将模型从三维空间投射到二维空间的过程。

• 正交投影(Orthograpic Projection):
平行线在变换后彼此之间仍然保持平行。

• 透视投影(Perspective Projection):
越是远离摄像机的物体，投影后看起来越小。
透视投影是模拟人类感知物体的方式。

==== 裁剪(Clipping)
当图元完全或者部分处于视体内部时，才需要将其发送到光栅化阶段。
对于部分位于视体内部的图元，需要进行裁剪处理。

==== 屏幕映射(Screen Mapping)
将之前得到的空间坐标映射到屏幕坐标系上。

=== 光栅化阶段(The Rasterizier Stage)
==== 三角形建立(Tringle Setup)
主要用来计算三角形表面的差异和三角形表面的其他相关数据。

==== 三角形遍历(Tringle Traversal)
找到哪些采样点或像素在三角形中的过程通常叫三角形遍历(TriangleTraversal)或扫描转换(scan conversion)。

=== 像素处理阶段(The Pixel Processing Stage)
==== 像素着色(Pixel Shading)
在可编程GPU上执行，计算所有需逐像素操作的过程，例如纹理贴图。

Q: 片元 vs. 像素
https://www.khronos.org/opengl/wiki/Fragment

==== 融合(Merging)
合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，还负责可见性问题(Z缓冲相关)的处理。

== GPU
=== 数据并行架构(Data-Parallel Architectures)

参考:
https://zhuanlan.zhihu.com/p/598173226
https://medium.com/codex/understanding-the-architecture-of-a-gpu-d5d2d2e8978b

=== GPU管线总览(GPU Pipeline Overview)
=== 可编程着色器阶段(The Programmable Shader Stage)

=== 着色API演变(The Evolution of Programmable Shading and APIs)
2014 Metal
2016 Vulkan
https://en.wikipedia.org/wiki/High-Level_Shader_Language
https://en.wikipedia.org/wiki/OpenGL_Shading_Language

=== 顶点着色器(The Vertex Shader)
对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。

=== 曲面细分阶段(The Tessellation Stage)

=== 几何着色器(The Geometry Shader)
允许GPU高效地创建和销毁几何图元。几何着色器是可选的，完全可编程的阶段，主要对图元(点、线、三角形)的顶点进行操作。几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片段着色器。

=== 像素着色器(The Pixel Shader)
DirectX叫Pixel Shader, 又称片断着色器，片元着色器(Fragment Shader，OpenGL的叫法)，是完全可编程的阶段，主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。

=== 合并阶段(The Merging Stage)
尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改(Color Modifying)，Z缓冲(Z- buffer)，混合(Blend)，模板(Stencil)和相关缓存的处理。

=== 计算着色器(The Compute Shader)

== 数学基础
=== 向量

ifdef::env-github[]
- 表示: $\vec{a}$ 或者粗体表示 $\boldsymbol{a}$
- 方向: $\overrightarrow{AB}$ = $\boldsymbol{A-B}$
- 长度/模: $\Vert \vec{a} \Vert$ 或者 $|\vec{a}|$
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: $\hat{a}=\vec{a}/|\vec{a}|$
endif::[]

ifndef::env-github[]
- 表示: latexmath:[$\vec{a}$] 或者粗体表示 latexmath:[$\boldsymbol{a}$]
- 方向: latexmath:[$\overrightarrow{AB}$] = latexmath:[$\boldsymbol{A-B}$]
- 长度/模: latexmath:[$\Vert \vec{a} \Vert$] 或者 latexmath:[$|\vec{a}|$]
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: latexmath:[$\hat{a}=\vec{a}/|\vec{a}|$]
endif::[]

- 加法
    几何: 四边形法则 三角形法则
    代数: 坐标相加

- 图形学里一般使用列向量

- 转置

- 点乘 Dot(scalar) Product
ifdef::env-github[]
    ▪ $ a \cdot b = |\vec{a}| |\vec{b}| \cos\theta $
endif::[]
ifndef::env-github[]
    ▪ latexmath:[$ a \cdot b = |\vec{a}| |\vec{b}| \cos\theta $]
endif::[]
    ▪ 交换律
    ▪ 结合律
    ▪ 分配律
    ▪ 用途:
        向量间的夹角
        一个向量在另外一个向量上的投影(projection)
        向量的接近程度
        分解向量(decompose)
        前后关系(forward/backward)
    ▪ 也叫数量积/内积

- 坐标系
    ▪ 左手/右手
    ▪ 各平台、引擎的坐标系

- 叉乘 Cross(vector) Product
    ▪ 结果是一个向量
        其方向: 垂直于两个向量，右手坐标系
ifdef::env-github[]
        其长度: $ |a \times b| = |\vec{a}| |\vec{b}| \sin\theta $
endif::[]
ifndef::env-github[]
        其长度: latexmath:[$ |a \times b| = |\vec{a}| |\vec{b}| \sin\theta $]
endif::[]
    ▪ 反交换律
    ▪ 结合律
    ▪ 分配律
    ▪ 用途:
        构建坐标系
        左右关系
        内外(inside/outside)
        叉乘可以用矩阵乘以列向量矩阵来表示
    ▪ 向量积/外积

=== 矩阵
- 作用
    通常用来表示变换(transformation), 例如平移(translate)，旋转(rotate)，缩放(scale)，剪切/切变(shear)

- 性质
    交换律: 通常不满足
    结合律: 满足
    分配律: 满足

- 转置(transpose)

- 单位矩阵

- 逆矩阵(inverse)

- 向量操作的矩阵形式(Vector Operations in Matrix Form)

    Q: 点乘
    Q: 叉乘

- 矩阵与线性变换

    线性变换是一类满足线性条件的变换。
    线性条件: T(u+v) = T(u) + T(v) 和T(cu) = cT(u)
    向量的加法和数乘运算在变换前和变换后的效果是一样的，也就是说线性变换保持了向量的加法和数乘运算。
    https://www.zhihu.com/question/322319580

- 正交矩阵与旋转矩阵

    正交矩阵的逆=正交矩阵的转置
    旋转矩阵是正交矩阵。正交矩阵不一定是旋转矩阵。
    任何一组正交基向量在旋转矩阵的变换下仍然是正交的，因此旋转矩阵是正交矩阵。
    但是，反之就不一定，例如某镜像变换。
    https://www.zhihu.com/question/316200199

=== 变换(transformation)

==== 齐次坐标系(homogeneous coordinates)

    齐次坐标就是用N+1维来代表N维坐标。
    
    为什么需要齐次坐标系呢？
    在某些场合下，使用齐次坐标系更为合适:
    对于平移变换，如果维度不变，用矩阵左乘是表达不了平移操作的。加上一个维度后，平移才可以同旋转缩放等操作一样: 统一成矩阵变换的形式。
    对于透视变换，笛卡尔坐标系下平行线永不相交，这不适用于透视场景。
    再例如，点光源与方向光等也可以用齐次坐标来表示(例如，w=1: point light, w=0: directional light)。

    2维点: (x, y, 1)
    2维向量: (x, y, 0)
    3维点: (x, y, z, 1)
    3维向量: (x, y, z, 0)

    齐次坐标是图形学的重要手段之一，它既能够用来明确区分向量和点，也更易于进行仿射变换。

    参考:
    http://www.songho.ca/math/homogeneous/homogeneous.html
    https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/

==== 2D变换
===== 缩放变换(scale)

===== 反射变换(reflection)

===== 切变变换(shear)

===== 旋转变换(rotate)

===== 平移变换(translate)

===== 仿射变换(affine)
(先)线性变换 + (后)平移变换

===== 逆变换(inverse transform sampling)

===== composing transforms

===== decomposing transforms

==== 3D变换

===== 旋转

====== 绕任意轴的旋转
- 任意轴经过原点

    Rodrigues' rotation formula
    https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula

- 任意轴不经过原点
    
    转化为经过原点的任意轴旋转+平移

====== 欧拉角
pitch: 俯仰
yaw: 偏航
roll: 翻滚

优点: 直观易于理解；比矩阵省空间
缺点: 万向节死锁(Gimbal Lock)

什么是万向节死锁?
https://blog.csdn.net/huazai434/article/details/6458257
https://v.youku.com/v_show/id_XNzkyOTIyMTI=.html
https://www.bilibili.com/video/BV1e3411y7RX

https://www.zhihu.com/question/47736315
https://stackoverflow.com/questions/17044296/quaternion-rotation-without-euler-angles
https://stackoverflow.com/questions/9715776/using-quaternions-for-opengl-rotations/9716268#9716268
https://www.cnblogs.com/psklf/articles/5656938.html
https://www.cnblogs.com/psklf/p/5667593.html

====== 四元数(quaternion)
优点: 不存在万向节死锁问题；利于旋转插值；比较省空间
缺点: 误差问题导致失效；难于理解

如何理解四元数?

https://www.bilibili.com/video/BV1gP4y1a7vZ

https://www.zhihu.com/question/23005815
https://www.3dgep.com/understanding-quaternions/
https://www.qiujiawei.com/understanding-quaternions/

==== 3D到2D的变换

===== 模型变换(Modeling Tranformation)

===== 视图/摄像机变换(View/Camera Tranformation)
Camera属性: Position  LookAt  Up
想象拿着个相机拍照，Position是相机的位置，LookAt是相机的朝向，Up怎么理解呢？
相机是可以转动的，Up就是固定这个转动。

View矩阵

参考: https://learn.microsoft.com/en-us/previous-versions/ff729721(v=vs.85)#view-space

===== 投影变换(Projection Tranformation)

====== 正交投影(Orthograpic Projection)
也称Parallel Projection。

Ortho矩阵

应用:
一些较老的RTS游戏例如《帝国时代》会采用正交投影/正射投影，现代的RTS游戏还是会使用透视投影。

====== 透视投影(Perspective Projection)
Persp矩阵 -> Ortho矩阵

https://zhuanlan.zhihu.com/p/362713511#:~:text=%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98%EF%BC%9A-,%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%EF%BC%88Projection%20transformation%EF%BC%89,%E4%BA%A4%E6%8A%95%E5%BD%B1%E5%92%8C%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E3%80%82
https://juejin.cn/post/6994334681885835278

===== 视口变换(Viewport Tranformation)
l, r, b, t:  fovY(field of view) and aspect ratio
fovY and aspect ratio 转换成l, r, b, t:
    tan(fovY/2) = t/|n|;
    aspect = r/t;

屏幕

Viewport矩阵

===== 参考
https://learn.microsoft.com/en-us/windows/uwp/graphics-concepts/transforms

===== 小结
MVP变换

    模型变换(Model Transformation): 模型空间坐标->世界空间坐标
    摄像机变换(Camera Transformation): 世界空间坐标->观察空间坐标
    投影变换(Projection Transformation): 观察空间坐标->裁剪空间坐标

视口变换(Viewport Transformation): 裁剪空间坐标->屏幕空间坐标

V′ = Mviewport * Mpersepctive * Mview * Mmodel * V

== 变换(Transforms)
=== Basic Transforms 
=== Special Matrix Transforms and Operations
=== Quaternions
=== Vertex Blending
=== Morphing
=== Geometry Cache Playback
=== Projections

== 物理基础

== 着色基础(Shading Basics)
=== ShadingModels
=== LightSources
=== ImplementingShadingModels
=== AliasingandAntialiasing
=== Transparency,Alpha,andCompositing
=== DisplayEncoding

== 纹理(Texturing)
=== The Texturing Pipeline
=== Image Texturing
=== Procedural Texturing
=== Texture Animation
=== Material Mapping
=== Alpha Mapping
=== Bump Mapping
- 凹凸贴图(Bump Mapping)

- 移位贴图(Displacement Mapping)

- 法线贴图(Normal Mapping)

- 视差贴图(Parallax Mapping)

- 浮雕贴图(Relief Mapping)
浮雕贴图使用的Relief Mapping是精确的Texture Offset, 因此表现效果会更好。
=== Parallax Mapping
=== Textured Lights

== 阴影(shadow)
=== Planar Shadows
=== Shadows on Curved Surfaces
=== Shadow Volumes
=== Shadow Maps
=== Percentage-Closer Filtering
=== Percentage-Closer Soft Shadows
=== Filtered Shadow Maps
=== Volumetric Shadow Techniques
=== Irregular Z -Buffer Shadows
=== Other Applications

== 光照与颜色(light and color)

=== 概念
==== 光源
平行光源、点光源和聚光灯。

==== 散射与吸收
所有的光物质相互作用都是两种现象的结果: 散射(scattering)和吸收(absorption)。

散射(scattering)发生在当光线遇到任何种类的光学不连续性(optical discontinuity)时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。
散射不会改变光量，只是使其改变方向。
散射一般又分为反射(reflection)和折射(refraction)。

吸收(absorption)发生在物质内部，其会导致一些光转变成另一种能量并消失。
吸收会减少光量，但不会影响其方向。

==== 着色处理方法
===== 平滑着色(Flat shading)
三角面使用同一个颜色。

===== 高洛德着色(Gouraud shading)
每顶点求值后线性插值。
在高洛德着色的实现中，顶点着色器传递世界空间的顶点法线和位置到Shade函数(首先确保法线矢量长度为1)，然后将结果写入内插值。像素着色器将获取内插值并将其直接写入输出。
高洛德着色可以为无光泽表面产生合理的结果，但是对于强高光反射的表面，可能会产生失真(artifacts)。

===== 冯氏着色(Phong shading)
冯氏着色是对着色方程进行完全的像素求值。
在冯氏着色实现中，顶点着色器将世界空间法线和位置写入内插值，此值通过像素着色器传递给Shade函数。而将Shade函数返回值写入到输出中。请注意，即使表面法线在顶点着色器中缩放为长度1，插值也可以改变其长度，因此可能需要在像素着色器中再次执行此归一化操作。
• 注意Phong Shading和Phong Lighting Model的区别，前者是考虑如何在三个顶点中填充颜色，而后者表示的是物体被光照产生的效果。
• 冯氏着色可以说是三者中最接近真实的着色效果，开销也是最大的。因为高洛德着色是每个顶点(vertex)计算一次光照，冯氏着色是每个片元(fragment)或者说每像素计算一次光照，点的法向量是通过顶点的法向量插值得到的，所以不会出现高洛德着色也许会遇到的失真问题。

=== Light Quantities
=== Scene to Screen

== 基于物理学的遮蔽(Physically Based Shading)
=== Physics of Light
=== The Camera

=== The BRDF
Bidirectional Reflectance Distribution Function，双向反射分布函数，是真实感图形学中最核心的概念之一，描述的是物体表面将光能从任何一个入射方向反射到任何一个视点方向的反射特性，即入射光线经过某个表面反射后如何在各个出射方向上分布。
BRDF模型是绝大多数图形学算法中用于描述光反射现象的基本模型。

=== Illumination
=== Fresnel Reflectance
=== Microgeometry
=== Microfacet Theory
=== BRDF Models for Surface Reflection
=== BRDF Models for Subsurface Scattering
=== BRDF Models for Cloth
=== Wave Optics BRDF Models
=== Layered Materials
=== Blending and Filtering Materials

== 局部光照(Local Illumination)
=== Area Light Sources
=== Environment Lighting
=== Spherical and Hemispherical Functions
=== Environment Mapping
=== Specular Image-Based Lighting
=== Irradiance Environment Mapping
=== Sources of Error

== 全局光照(Global Illumination)
=== The Rendering Equation
=== General Global Illumination
=== Ambient Occlusion
=== Directional Occlusion
=== Diffuse Global Illumination
=== Specular Global Illumination
=== Unified Approaches

== 图像-空间效果(Image-Space Effects)
=== Image Processing
=== Reprojection Techniques
=== Lens Flare and Bloom
=== Depth of Field
=== Motion Blur

== 多边形之外(Beyond Polygons)
=== The Rendering Spectrum
=== Fixed-View Effects
=== Skyboxes
=== Light Field Rendering
=== Sprites and Layers
=== Billboarding
根据观察方向来确定多边形面朝方向的一种技术。
可以用公告板技术表示一些不具有平滑实体表面的现象，比如烟，火，雾，爆炸效果，云朵等。

公告板可以分为:
• Screen-Aligned Billboard
• World-Oriented Billboard
• Axial Billboard

=== Displacement Techniques
=== Particle Systems
粒子系统(Particle System)是一组分散的微小物体的集合，这些微小物体按照某种算法运动。
通常应用于模拟火焰，烟，爆炸，流水，树木，瀑布，旋转星系等场景。

=== Point Rendering
=== Voxels

== 体积与半透明性渲染(Volumetric and Translucency Rendering)
=== Light Scattering Theory
=== Specialized Volumetric Rendering
=== General Volumetric Rendering
=== Sky Rendering
=== Translucent Surfaces
=== Subsurface Scattering
=== Hair and Fur
=== Unified Approaches

== 非写实渲染(Non-Photorealistic Rendering)
=== Toon Shading
=== Outline Rendering
=== Stroke Surface Stylization
=== Lines
=== Text Rendering

== 多边形技术(Polygonal Techniques)
=== Sources of Three-Dimensional Data
=== Tessellation and Triangulation
=== Consolidation
=== Triangle Fans, Strips, and Meshes
=== Simplification
=== Compression and Precision

== 曲线与曲面(Curves and Curved Surfaces)
=== Parametric Curves
=== Parametric Curved Surfaces
=== Implicit Surfaces
=== Subdivision Curves
=== Subdivision Surfaces
=== Efficient Tessellation

== 管道优化(Pipeline Optimization)
=== Profiling and Debugging Tools
=== Locating the Bottleneck
=== Performance Measurements
=== Optimization
=== Multiprocessing

== 加速算法(Acceleration Algorithms)
=== Spatial Data Structures
=== Culling Techniques
=== Backface Culling
=== View Frustum Culling
=== Portal Culling
=== Detail and Small Triangle Culling
=== Occlusion Culling
=== Culling Systems
=== Level of Detail
=== Rendering Large Scenes

== 高效阴影(Efficient Shading)
=== Deferred Shading
==== 概念
延迟渲染(Deferred Rendering)/延迟着色(Deferred Shading)是将着色计算延迟到深度测试之后进行处理的一种渲染方法。
延迟着色的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给拥有大量光源的场景提供了很多可能性。

正向渲染(Forward Rendering)/正向着色(Forward Shading)是渲染物体的一种非常直接的方式，在场景中根据所有光源照亮一个物体之后再渲染下一个物体，以此类推。其基本思路是先进行着色再进行深度测试。正向着色的主要缺点是光照计算跟场景复杂度和光源个数有很大关系。

延迟渲染(Deferred Rendering)将所有物体都先绘制到屏幕空间的缓冲(即Gbuffer/Geometric Buffer，几何缓冲区)中，再逐光源对该缓冲进行着色，避免了因计算被深度测试丢弃的片元的着色产⽣的不必要的开销。

算法复杂度: n个物体m光源，正向渲染复杂度是O(m*n)，延迟渲染复杂度则为O(n+m)。

==== G-Buffer
Geometric Buffer，几何缓冲区，主要存储每个像素对应的位置Position，法线Normal，漫反射颜色Diffuse Color以及其它材质参数。根据这些信息，就可以在二维空间中对每个像素进行光照处理。

==== 过程
1. 几何处理阶段：渲染所有的几何/颜色数据到G-buffer
2. 光照处理阶段：使用G-buffer计算场景的光照

==== 参考
https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting

=== Decal Rendering
=== Tiled Shading
=== Clustered Shading
=== Deferred Texturing
=== Object and Texture-Space Shading

== 虚拟现实与增强现实(Virtual and Augmented Reality)

== 相交测试方法(Intersection Test Methods)
GPU-Accelerated Picking
Definitions and Tools
Bounding Volume Creation
Geometric Probability
Rules of Thumb
Ray/Sphere Intersection
Ray/Box Intersection
Ray/Triangle Intersection
Ray/Polygon Intersection
Plane/Box Intersection
Triangle/Triangle Intersection
Triangle/Box Intersection
Bounding-Volume/Bounding-Volume Intersection
View Frustum Intersection
Line/Line Intersection
Intersection between Three Planes

== 图形硬件(Graphics Hardware)
Rasterization
Massive Compute and Scheduling
Latency and Occupancy
Memory Architecture and Buses
Caching and Compression
Color Buffering
DepthCulling, Testing, and Buffering
Texturing
Architecture
Case Studies
Ray Tracing Architectures

== project
https://bellard.org/TinyGL/
https://github.com/ssloy/tinyrenderer/wiki
https://github.com/skywind3000/mini3d/blob/master/mini3d.c

== shader
https://developer.valvesoftware.com/wiki/Shader

== 参考
- https://www.zhihu.com/tardis/zm/ans/2311690807?source_id=1003

- 《Fundamentals of Computer Graphics, 5th》

- 《Real-Time Rendering 4rd》
https://www.realtimerendering.com/
https://github.com/QianMo/Real-Time-Rendering-4th-Bibliography-Collection

- GAMES101:
视频: https://www.bilibili.com/video/BV1X7411F744/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html

- GAMES102:
视频: https://www.bilibili.com/video/BV1NA411E7Yr/
课件: http://staff.ustc.edu.cn/~lgliu/Courses/GAMES102_2020/default.html

- GAMES103:
视频: https://www.bilibili.com/video/BV12Q4y1S73g/
课件: https://games-cn.org/games103/

- GAMES201:
视频: https://www.bilibili.com/video/BV1ZK411H7Hc
课件: https://yuanming.taichi.graphics/teaching/2020-games201/

- GAMES202:
视频: https://www.bilibili.com/video/BV1YK4y1T7yY/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html

- 太极图形:
https://space.bilibili.com/1779922645
 