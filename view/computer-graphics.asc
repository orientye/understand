= Computer Graphics
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
:stem: latexmath
<<<

== 概念
https://en.wikipedia.org/wiki/Glossary_of_computer_graphics

计算机图形学(Computer Graphics)是从数据得到图像: 给定关于景象结构、表面反射特性、光源配置及相机模型等信息，生成图像。

== 图形渲染管线(The Graphics Render Pipeline)
=== 应用程序阶段(The Appliction Stage)
• 通过软件方式实现，开发者能够对该阶段发生的情况进行完全控制。其他阶段则全部或者部分建立在硬件基础上，改变其实现过程会非常困难。
• 一般使用CPU，也有些情况，例如compute shader会使用到GPU。
• 不能像几何和光栅化阶段那样继续分为若干个子阶段，但可以在几个并行处理器上同时执行。
• 通常包括碰撞检测、加速算法、输入检测、动画、物理仿真，以及一些不在其它阶段执行的计算，如层次视锥裁剪等加速算法。
• 将绘制图元(rendering primitives，如点、线、三角形等)输出到管线的几何处理阶段。

=== 几何处理阶段(The Geometry Processing Stage)
==== 顶点着色(Vertex Shading)
确定材质上的光照效果的操作称之为着色(shading)。
可在顶点处存储如位置，法线，颜色或者计算着色方程所需的其它信息。
顶点着色的计算完成后，其结果会被发送到光栅化阶段进行插值。

• 顶点数据(Vertex Data)
点，线，三角面
通常使用三角形网格来近似表示物体
使用索引来共享顶点间的数据，即:
VBO(Vertex Buffer Object, 顶点缓存对象): https://en.wikipedia.org/wiki/Vertex_buffer_object

==== 投影(Projection)
投影是将模型从三维空间投射到二维空间的过程。

• 正交投影(Orthograpic Projection):
平行线在变换后彼此之间仍然保持平行。

• 透视投影(Perspective Projection):
越是远离摄像机的物体，投影后看起来越小。
透视投影是模拟人类感知物体的方式。

==== 裁剪(Clipping)
当图元完全或者部分处于视体内部时，才需要将其发送到光栅化阶段。
对于部分位于视体内部的图元，需要进行裁剪处理。

常见的裁剪算法有Cohen-Sutherland算法、Liang-Barsky算法和Sutherland-Hodgman多边形裁剪算法。

vs. 帧缓存中的裁剪
帧缓存中的裁剪，将裁剪操作推迟到屏幕坐标中进行，使用一种叫做裁切(Scissoring)的技术在帧缓存中执行裁剪操作；
帧缓存中的裁剪一般只适合于光栅对象，对于几何实体，一般在帧缓存之前进行裁剪会更好些。

==== 屏幕映射(Screen Mapping)
将之前得到的空间坐标映射到屏幕坐标系上。

=== 光栅化阶段(The Rasterizier Stage)
==== 三角形建立(Tringle Setup)
主要用来计算三角形表面的差异和三角形表面的其他相关数据。

==== 三角形遍历(Tringle Traversal)
找到哪些采样点或像素在三角形中的过程通常叫三角形遍历(TriangleTraversal)或扫描转换(scan conversion)。

=== 像素处理阶段(The Pixel Processing Stage)
==== 像素着色(Pixel Shading)
在可编程GPU上执行，计算所有需逐像素操作的过程，例如纹理贴图。

Q: 片元 vs. 像素
https://www.khronos.org/opengl/wiki/Fragment

==== 融合(Merging)
合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，还负责可见性问题(Z缓冲相关)的处理。

== GPU
=== 数据并行架构(Data-Parallel Architectures)

参考:
https://zhuanlan.zhihu.com/p/598173226
https://medium.com/codex/understanding-the-architecture-of-a-gpu-d5d2d2e8978b

=== GPU管线总览(GPU Pipeline Overview)
- Vertex Shader(可编程)

- Tesselation(可编程)

- Geometry Shader(可编程)

- Clipping(固定)

- Screen Mapping(可配置)
Screen mapping is affected by window and viewport settings, internally forming a simple scale and repositioning.

- Triangle Setup & Traversal(固定)

- Pixel Shader(可编程)

- Merger(可配置)
the merger stage is not programmable, it is highly configurable and can be set to perform a wide variety of operations. It implements the “merging” functional stage, in charge of modifying the color, z-buffer, blend, stencil, and any other output-related buffers.

=== 可编程着色器阶段(The Programmable Shader Stage)
• 现代着色阶段(比如支持Shader Model 4.0，DirectX 10以及之后)使用了通用着色核心(common shader core)，这就表明顶点、几何、片段着色器共享一套编程模型。

• 早期的着色模型可以用汇编语言直接编程，但DX10之后，汇编就只在调试输出阶段可见，改用高级着色语言。

• 目前的着色语言都是C-like，如HLSL，CG和GLSL，其被编译成独立于机器的汇编语言，也称为中间语言(IL)。这些汇编语言在单独的阶段，通常是在驱动中，被转化成实际的机器语言，从而可以兼容不同的硬件实现。

• 着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。考虑到很多图形操作都使用短矢量(最高四位)，处理器拥有4路SIMD(single-instruction multiple-data，单指令多数据)兼容性。每个寄存器包含四个独立的值。32位单精度浮点的标量和矢量是其基本数据类型；也随后支持32位整型。浮点矢量通常包含数据如位置(xyzw)，法线，矩阵行，颜色(rgba)，或者纹理坐标(uvwq)。而整型通常用来表示计数器，索引，或者位掩码。也支持综合数据类型比如结构体，数组，和矩阵。而为了便于使用向量，也支持调和(swizzling，即向量分量的重新排序或复制)和屏蔽(masking，只使用指定的矢量元素)等向量操作。

• 一个绘制调用(draw call)会调用图形API来绘制一系列的图元，会驱使图形管线的运行。

• 每个可编程着色阶段拥有两种类型的输入：
uniform输入，在一个draw call中保持不变的值(但在不同draw call之间可以更改)；
varying输入，shader里对每个顶点和像素的处理都不同的值。纹理是特殊类型的uniform输入，曾经一直是一张应用到表面的彩色图片，但现在可以认为是存储着大量数据的数组。

• 在现代GPU上，图形运算中常见的运算操作执行速度非常快。通常情况下，最快的操作是标量和向量的乘法和加法，以及其组合，如乘加运算(multiply-add)和点乘(dot-product)运算。其他操作比如倒数(reciprocal)、平方根(square root)、正弦(sine)、余弦(cosine)、指数(exponentiation)、对数(logarithm)运算，往往会稍微更加昂贵，但依然相当快捷。纹理操作非常高效，但其性能可能受到诸如等待检索结果的时间等因素的限制。

• 着色语言表示出了大多数场常见的操作(比如加法和乘法通过运算符+和*来表示)。其余的操作用固有的函数，比如atan(), dot(), log()等。更复杂的操作也存在内建函数，比如矢量归一化(vector normalization)、反射(reflection)、叉乘(cross products)、矩阵的转置(matrix transpose)和行列式(determinant)等。

• 流控制(flow control)是指使用分支指令来改变代码执行流程的操作。这些指令用于实现高级语言结构，如if，case，以及各种类型的循环。
Shader支持两种类型的流控制：
静态流控制(static flow control)是基于统一输入的值的。这意味着代码的流在调用时是恒定的。静态流控制的主要好处是允许在不同的情况下使用相同的着色器(例如不同数量的光源)。
动态流控制(dynamic flow control)基于不同的输入值。但动态流控制远比静态流量控制更强大但同时也需更高的开销，特别是在调用shader之间，代码流不规律改变的时候。

• Shader程序可以在程序加载或运行时离线编译。和任何编译器一样，有生成不同输出文件和使用不同优化级别的选项。一个编译过的Shader作为字符串或者文本来存储，并通过驱动程序传递给GPU。

=== 着色API演变(The Evolution of Programmable Shading and APIs)
2014 Metal
2016 Vulkan
https://en.wikipedia.org/wiki/High-Level_Shader_Language
https://en.wikipedia.org/wiki/OpenGL_Shading_Language
https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model
https://en.wikipedia.org/wiki/Unified_shader_model

=== 顶点着色器(The Vertex Shader)
对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。

顶点着色器是流水线上的第一个阶段，可选在GPU还是CPU上实现。在CPU上实现的话，需将CPU中的输出数据发送到GPU进行光栅化。目前几乎所有的GPU都支持顶点着色。

The vertex shader can neither create nor destroy vertices, and results generated by one vertex cannot be passed on to another vertex. Since each vertex is treated independently, any number of shader processors on the GPU can be applied in parallel to the incoming stream of vertices.

=== 曲面细分阶段(The Tessellation Stage)
曲面细分是渲染管线一个可选的阶段。
DirectX11, OpenGL 4.0, OpenGL ES 3.2开始支持。

它利用镶嵌化处理技术对三角面进行细分，以此增加物体表面的三角面的数量。
曲面细分通常由三部分组成，用DX的术语来说，分为hull shader、tessellator、domain shader。OpenGL中hull shader被称为tessellation control shader，domain shader被称为tessellation evaluation shader。
有了曲面细分，就不需要创建高模(high-poly)来丰富网格信息了，因此基于GPU可以实现动态的LOD技术，可以根据物体距离摄像机的远近来调整多边形网格的细节，这样也就节省了资源。

=== 几何着色器(The Geometry Shader)
几何着色器是渲染管线一个可选的阶段。
DirectX10, OpenGL 3.2, OpenGL ES 3.2开始支持。

它允许GPU高效地创建和销毁几何图元，主要对图元(点、线、三角形)的顶点进行操作。
几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片段着色器。

After a draw call is issued, there are only three places in the pipeline where work can be created on the GPU: rasterization, the tessellation stage, and the geometry shader. Of these, the geometry shader’s behavior is the least predictable when considering resources and memory needed, since it is fully programmable. In practice the geometry shader usually sees little use, as it does not map well to the GPU’s strengths. On some mobile devices it is implemented in software, so its use is actively discouraged there.

=== 像素着色器(The Pixel Shader)
• DirectX叫Pixel Shader, 又称片断着色器，片元着色器(Fragment Shader，OpenGL的叫法)，是完全可编程的阶段。
其主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。像素着色器是光栅化阶段的主要步骤之一。在顶点和几何着色器执行完其操作之后，图元会被裁剪、屏幕映射，结束几何阶段，到达光栅化阶段，在光栅化阶段中先经历三角形设定和三角形遍历，之后来到像素着色阶段。
• 像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片断着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片断着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。
• 需要注意，像素着色程序通常在最终合并阶段设置片段颜色以进行合并，而深度值也可以由像素着色器修改。模板缓冲(stencil buffer)值是不可修改的，而是将其传递到合并阶段(Merge Stage)。在SM2.0以及以上版本，像素着色器也可以丢弃(discard)传入的片段数据，即不产生输出。这样的操作会消耗性能，因为通常在这种情况下不能使用由GPU执行的优化。诸如雾计算和alpha测试的操作已经从合并操作转移到SM4.0中的像素着色器里计算。
• 可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在Shader Model 4.0中，共有16个向量(每个向量含4个值)可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出32个向量到像素着色器中。像素着色器的追加输入是在Shader Model 3.0中引入的。例如，三角形的哪一面是可见的是通过输入标志来加入的。这个值对于在单个通道中的正面和背面渲染不同材质十分重要。而且像素着色器也可以获得片段的屏幕位置。

=== 合并阶段(The Merging Stage)
尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改(Color Modifying)，Z缓冲(Z-buffer)，混合(Blend)，模板(Stencil)和相关缓存的处理。

合并阶段是用于将片元的深度和颜色(PS的输出)与framebuffer上的信息进行合并。DX将这个阶段称为output merger，OpenGL将这个阶段称为per-sample 操作。在大多数传统管线中，这个阶段包含stencil buffer和z buffer。如果片元可见，则就会触发color blending操作。针对不透明物件，其实并没有真正的blending，只是单纯的用fragment颜色代替之前存储的颜色。真正的将片元和framebufer上存储的颜色进行blending的操作，通常被用于半透明物件以及合成操作。

想象一下，一个由光栅化生成的片元经过PS后，在进行depth test的时候发现自己被前面绘制的片元挡住了，这样的话整个PS操作都白费了。为了避免这种情况，需要GPU将合并阶段中的一些测试房到PS之前。fragment的zbuffer(以及其他被使用的，比如stencil bufer或者scissor)被用于测试可见性，如果不可见，该片元则被cull掉。这个功能被称为early-z。PS可以改变z，或者直接抛弃该片元。如果PS中有这两个操作，early-z就会被关闭，这样的话整个管线就变的低效了。DX11和OpenGL4.2允许PS强制打开early-z，尽管还会有一些限制。使用early-z会获得一个很大的性能提升。

合并阶段发生在fixed-function，比如图元装配，以及可编程管线中间。尽管它并非可编程，但是高度可配置。比如color blending就可以使用多种算法。最常见的有涉及到颜色和alpha的乘法、加法、减法等，还有其他操作，比如最大、最小、按位操作等。DX10增加了将PS中两个颜色与framebuffer上颜色混合的方法。这个能力被称为双源颜色混合，不能和MRT一期使用。MRT支持color blending，DX10.1还增加了针对每个buffer使用不同blend算法的功能。

DX11.3提供了一个方法，可以通过ROV实现progrrammable blending，尽管它在性能上会有一些代价。ROV和合并阶段都是按照顺序渲染的，也就是output invariance输出不变性。不管PS的输出顺序如何，API要求结果按照输入顺序，逐物件和三角形的排序并发送到合并阶段。

=== 计算着色器(The Compute Shader)
GPU不仅用于实现传统的图形管线，也可以用于非图形化应用，比如计算股票期权估值，以及训练神经网络进行深度学习等领域。以这种方式使用硬件被称为GPU计算，像CUDA、OpenCL这样的API被用来控制GPU作为一个巨大的并行处理器来使用，而不需要使用图形特定的功能。这些框架通常使用C/C++的扩展，以及搭配上GPU特定的类库。

DX11中引入了computer shader的概念(OpenGL 4.3)，这个shader不固定在管线中的某个位置。然而它又与渲染过程密切相关，因为它是由图形API调用。它也是根据顶点、像素以及其他shader一起执行。它与管线中的其他shader共享同一个统一shader处理。它与其他shader类似，有一些输入，可以访问buffer(比如纹理)作为输入/输出。在CS中warps和thread的概念更加可视化。比如，每个调用都能获取到它的thread index。还有线程组的概念，在DX11中由1-1024个thread组成。这些线程组分为x、y、z三个轴表示，主要是为了在shader中使用方便。每个线程组都有一个小的内存用于线程间共享。在DX11中，这个大小为32KB。CS是由线程组为单位执行，这样保证一组中的所有线程都并发运行。

CS的一个重要优势在于，它们可以访问GPU生成的数据。将数据从GPU传给CPU会知道延迟，因此如果处理和结果都在GPU上进行，可以提高性能。后处理，将渲染后的数据进行修改，通过CS实现性能更优。共享内存以为这来自采样图像像素的中间结果可以与相邻线程共享。比如，使用CS计算图像的分布或者亮度的执行速度，是PS的两倍。

CS还可以被用于粒子特效、网格处理比如面部动画、剔除、图像过滤、提高depth精度、阴影、DOF以及任何其他可以使用GPU处理的任务。Wihlidal还讨论了CS如何比Tessellation hull shader更加高效。

参考:
https://www.khronos.org/opengl/wiki/Compute_Shader
https://docs.unity3d.com/Manual/class-ComputeShader.html
https://vulkan-tutorial.com/Compute_Shader
https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction

== 数学基础
=== 向量

ifdef::env-github[]
- 表示: $\vec{a}$ 或者粗体表示 $\boldsymbol{a}$
- 方向: $\overrightarrow{AB}$ = $\boldsymbol{A-B}$
- 长度/模: $\Vert \vec{a} \Vert$ 或者 $|\vec{a}|$
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: $\hat{a}=\vec{a}/|\vec{a}|$
endif::[]

ifndef::env-github[]
- 表示: latexmath:[$\vec{a}$] 或者粗体表示 latexmath:[$\boldsymbol{a}$]
- 方向: latexmath:[$\overrightarrow{AB}$] = latexmath:[$\boldsymbol{A-B}$]
- 长度/模: latexmath:[$\Vert \vec{a} \Vert$] 或者 latexmath:[$|\vec{a}|$]
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: latexmath:[$\hat{a}=\vec{a}/|\vec{a}|$]
endif::[]

- 加法
    几何: 四边形法则 三角形法则
    代数: 坐标相加

- 图形学里一般使用列向量

- 转置

- 点乘 Dot(scalar) Product
ifdef::env-github[]
    ▪ $ a \cdot b = |\vec{a}| |\vec{b}| \cos\theta $
endif::[]
ifndef::env-github[]
    ▪ latexmath:[$ a \cdot b = |\vec{a}| |\vec{b}| \cos\theta $]
endif::[]
    ▪ 交换律
    ▪ 结合律
    ▪ 分配律
    ▪ 用途:
        向量间的夹角
        一个向量在另外一个向量上的投影(projection)
        向量的接近程度
        分解向量(decompose)
        前后关系(forward/backward)
    ▪ 也叫数量积/内积

- 坐标系
    ▪ 左手/右手
    https://learn.microsoft.com/zh-cn/windows/uwp/graphics-concepts/coordinate-systems#left-and-right-handed-coordinates
    ▪ 各平台、引擎的坐标系
        D3D与Metal左手坐标系，OpenGL与Vulkan右手坐标系
        UE与Unity均为左手坐标系

- 叉乘 Cross(vector) Product
    ▪ 结果是一个向量
        其方向: 垂直于两个向量，右手坐标系
ifdef::env-github[]
        其长度: $ |a \times b| = |\vec{a}| |\vec{b}| \sin\theta $
endif::[]
ifndef::env-github[]
        其长度: latexmath:[$ |a \times b| = |\vec{a}| |\vec{b}| \sin\theta $]
endif::[]
    ▪ 反交换律
    ▪ 结合律
    ▪ 分配律
    ▪ 用途:
        构建坐标系
        左右关系
        内外(inside/outside)
        叉乘可以用矩阵乘以列向量矩阵来表示
    ▪ 向量积/外积

=== 矩阵
- 作用
    通常用来表示变换(transformation), 例如平移(translate)，旋转(rotate)，缩放(scale)，剪切/切变(shear)

- 性质
    交换律: 通常不满足
    结合律: 满足
    分配律: 满足

- 转置(transpose)

- 单位矩阵

- 逆矩阵(inverse)

- 向量操作的矩阵形式(Vector Operations in Matrix Form)

    Q: 点乘
    Q: 叉乘

- 矩阵与线性变换

    线性变换是一类满足线性条件的变换。
    线性条件: T(u+v) = T(u) + T(v) 和T(cu) = cT(u)
    向量的加法和数乘运算在变换前和变换后的效果是一样的，也就是说线性变换保持了向量的加法和数乘运算。
    https://www.zhihu.com/question/322319580

- 正交矩阵与旋转矩阵

    正交矩阵的逆=正交矩阵的转置
    旋转矩阵是正交矩阵。正交矩阵不一定是旋转矩阵。
    任何一组正交基向量在旋转矩阵的变换下仍然是正交的，因此旋转矩阵是正交矩阵。
    但是，反之就不一定，例如某镜像变换。
    https://www.zhihu.com/question/316200199

=== 变换(transformation)

==== 齐次坐标系(homogeneous coordinates)

    齐次坐标就是用N+1维来代表N维坐标。
    
    为什么需要齐次坐标系呢？
    在某些场合下，使用齐次坐标系更为合适:
    对于平移变换，如果维度不变，用矩阵左乘是表达不了平移操作的。加上一个维度后，平移才可以同旋转缩放等操作一样: 统一成矩阵变换的形式。
    对于透视变换，笛卡尔坐标系下平行线永不相交，这不适用于透视场景。
    再例如，点光源与方向光等也可以用齐次坐标来表示(例如，w=1: point light, w=0: directional light)。

    2维点: (x, y, 1)
    2维向量: (x, y, 0)
    3维点: (x, y, z, 1)
    3维向量: (x, y, z, 0)

    齐次坐标是图形学的重要手段之一，它既能够用来明确区分向量和点，也更易于进行仿射变换。

    参考:
    http://www.songho.ca/math/homogeneous/homogeneous.html
    https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/

==== 2D变换
===== 缩放变换(scale)

===== 反射变换(reflection)

===== 切变变换(shear)

===== 旋转变换(rotate)

===== 平移变换(translate)

===== 仿射变换(affine)
(先)线性变换 + (后)平移变换

===== 逆变换(inverse transform sampling)

===== composing transforms

===== decomposing transforms

==== 3D变换

===== 旋转

====== 绕任意轴的旋转
- 任意轴经过原点

    Rodrigues' rotation formula
    https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula

- 任意轴不经过原点

    转化为经过原点的任意轴旋转+平移

====== 欧拉角
pitch: 俯仰
yaw: 偏航
roll: 翻滚

优点: 直观易于理解；比矩阵省空间
缺点: 万向节死锁(Gimbal Lock)

什么是万向节死锁?
https://blog.csdn.net/huazai434/article/details/6458257
https://v.youku.com/v_show/id_XNzkyOTIyMTI=.html
https://www.bilibili.com/video/BV1e3411y7RX

https://www.zhihu.com/question/47736315
https://stackoverflow.com/questions/17044296/quaternion-rotation-without-euler-angles
https://stackoverflow.com/questions/9715776/using-quaternions-for-opengl-rotations/9716268#9716268
https://www.cnblogs.com/psklf/articles/5656938.html
https://www.cnblogs.com/psklf/p/5667593.html

====== 四元数(quaternion)
- 概念
优点: 不存在万向节死锁问题；利于旋转插值；比较省空间
缺点: 误差问题导致失效；难于理解
四元数常用来表示rotation与orientation

- 复数

- 三维空间中的旋转

- 四元数
四元数的定义和复数非常类似，唯一的区别就是四元数一共有三个虚部，而复数只有一个

- 插值

- 参考
https://krasjet.github.io/quaternion/quaternion.pdf
https://www.zhihu.com/question/23005815
https://www.bilibili.com/video/BV1gP4y1a7vZ
https://www.3dgep.com/understanding-quaternions/
https://www.qiujiawei.com/understanding-quaternions/
https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html

==== 3D到2D的变换

===== 模型变换(Modeling Tranformation)

===== 视图/摄像机变换(View/Camera Tranformation)
Camera属性: Position  LookAt  Up
想象拿着个相机拍照，Position是相机的位置，LookAt是相机的朝向，Up怎么理解呢？
相机是可以转动的，Up就是固定这个转动。

View矩阵

参考: https://learn.microsoft.com/en-us/previous-versions/ff729721(v=vs.85)#view-space

===== 投影变换(Projection Tranformation)

====== 正交投影(Orthograpic Projection)
也称Parallel Projection。

Ortho矩阵

应用:
一些较老的RTS游戏例如《帝国时代》会采用正交投影/正射投影，现代的RTS游戏还是会使用透视投影。

====== 透视投影(Perspective Projection)
Persp矩阵 -> Ortho矩阵

https://zhuanlan.zhihu.com/p/362713511#:~:text=%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98%EF%BC%9A-,%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2%EF%BC%88Projection%20transformation%EF%BC%89,%E4%BA%A4%E6%8A%95%E5%BD%B1%E5%92%8C%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E3%80%82
https://juejin.cn/post/6994334681885835278

===== 视口变换(Viewport Tranformation)
l, r, b, t:  fovY(field of view) and aspect ratio
fovY and aspect ratio 转换成l, r, b, t:
    tan(fovY/2) = t/|n|;
    aspect = r/t;

屏幕

Viewport矩阵

===== 参考
https://learn.microsoft.com/en-us/windows/uwp/graphics-concepts/transforms

===== 小结
MVP变换

    模型变换(Model Transformation): 模型空间坐标->世界空间坐标
    摄像机变换(Camera Transformation): 世界空间坐标->观察空间坐标
    投影变换(Projection Transformation): 观察空间坐标->裁剪空间坐标

视口变换(Viewport Transformation): 裁剪空间坐标->屏幕空间坐标

V′ = Mviewport * Mpersepctive * Mview * Mmodel * V

=== 参考
http://immersivemath.com/

== 物理基础

=== 辐射度量学(Radiometry)

== 着色基础(Shading Basics)
=== ShadingModels
=== LightSources
=== ImplementingShadingModels
=== AliasingandAntialiasing
=== Transparency,Alpha,andCompositing
=== DisplayEncoding

== 纹理(Texturing)
=== The Texturing Pipeline
=== Image Texturing
=== Procedural Texturing
=== Texture Animation
=== Material Mapping
=== Alpha Mapping
=== Bump Mapping
- 凹凸贴图(Bump Mapping)

- 移位贴图(Displacement Mapping)

- 法线贴图(Normal Mapping)

- 视差贴图(Parallax Mapping)

- 浮雕贴图(Relief Mapping)
浮雕贴图使用的Relief Mapping是精确的Texture Offset, 因此表现效果会更好。
=== Parallax Mapping
=== Textured Lights

== 阴影(shadow)
=== Planar Shadows
=== Shadows on Curved Surfaces
=== Shadow Volumes
=== Shadow Maps
=== Percentage-Closer Filtering
=== Percentage-Closer Soft Shadows
=== Filtered Shadow Maps
=== Volumetric Shadow Techniques
=== Irregular Z -Buffer Shadows
=== Other Applications

== 光照与颜色(light and color)

=== 概念
==== 光源
平行光源(也称方向光，例如太阳)、点光源(例如灯泡，蜡烛)和聚光灯(也称探照灯，例如手电筒，汽车大灯)。
在unity中，还有区域光源等灯光类型。

==== 散射与吸收
所有的光物质相互作用都是两种现象的结果: 散射(scattering)和吸收(absorption)。

散射(scattering)发生在当光线遇到任何种类的光学不连续性(optical discontinuity)时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。
散射不会改变光量，只是使其改变方向。
散射一般又分为反射(reflection)和折射(refraction)。

吸收(absorption)发生在物质内部，其会导致一些光转变成另一种能量并消失。
吸收会减少光量，但不会影响其方向。

==== 着色处理方法
===== 平滑着色(Flat shading)
三角面使用同一个颜色。

===== 高洛德着色(Gouraud shading)
每顶点求值后线性插值。
在高洛德着色的实现中，顶点着色器传递世界空间的顶点法线和位置到Shade函数(首先确保法线矢量长度为1)，然后将结果写入内插值。像素着色器将获取内插值并将其直接写入输出。
高洛德着色可以为无光泽表面产生合理的结果，但是对于强高光反射的表面，可能会产生失真(artifacts)。

===== 冯氏着色(Phong shading)
冯氏着色是对着色方程进行完全的像素求值。
在冯氏着色实现中，顶点着色器将世界空间法线和位置写入内插值，此值通过像素着色器传递给Shade函数。而将Shade函数返回值写入到输出中。请注意，即使表面法线在顶点着色器中缩放为长度1，插值也可以改变其长度，因此可能需要在像素着色器中再次执行此归一化操作。
• 注意Phong Shading和Phong Lighting Model的区别，前者是考虑如何在三个顶点中填充颜色，而后者表示的是物体被光照产生的效果。
• 冯氏着色可以说是三者中最接近真实的着色效果，开销也是最大的。因为高洛德着色是每个顶点(vertex)计算一次光照，冯氏着色是每个片元(fragment)或者说每像素计算一次光照，点的法向量是通过顶点的法向量插值得到的，所以不会出现高洛德着色也许会遇到的失真问题。

===== 小结
三种着色方案中平面着色效果最差(计算量最少)，高洛德着色其次(计算量其次)，冯氏着色最好(计算量最多)。

=== Light Quantities
=== Scene to Screen

== 基于物理学的遮蔽(Physically Based Shading)
=== Physics of Light
=== The Camera

=== The BRDF
==== 概念
Bidirectional Reflectance Distribution Function，双向反射分布函数，是真实感图形学中最核心的概念之一，描述的是物体表面将光能从任何一个入射方向反射到任何一个视点方向的反射特性，即入射光线经过某个表面反射后如何在各个出射方向上分布。
BRDF模型是绝大多数图形学算法中用于描述光反射现象的基本模型。

BRDF的精确定义是出射辐射率的微分(differential outgoing radiance)和入射辐照度的微分(differential incoming irradiance)之比。

==== 性质

==== 分类

==== 基于物理的BRDF
基于物理的BRDF模型通过包含材质的各种几何及光学性质来尽可能精确的近似现实世界中的材料。而一个基于物理的BRDF要必须满足至少如下两条BRDF的特性：能量守恒、亥姆霍兹光路可逆性。

=== Illumination
=== Fresnel Reflectance
=== Microgeometry
=== Microfacet Theory
=== BRDF Models for Surface Reflection
=== BRDF Models for Subsurface Scattering
=== BRDF Models for Cloth
=== Wave Optics BRDF Models
=== Layered Materials
=== Blending and Filtering Materials

== 局部光照(Local Illumination)
=== Area Light Sources
=== Environment Lighting
=== Spherical and Hemispherical Functions
=== Environment Mapping
=== Specular Image-Based Lighting
=== Irradiance Environment Mapping
=== Sources of Error

== 全局光照(Global Illumination)
=== 概念
全局光照(简称GI), 既考虑场景中直接来自光源的光照(Direct Light)又考虑经过场景中其他物体反射后的光照(Indirect Light)的一种渲染技术。可以这么理解：全局光照 = 直接光照(Direct Light) + 间接光照(Indirect Light)。

全局光照能够有效地增强场景的真实感。

全局光照的一些实现方式:
• Ray tracing 光线追踪
• Path tracing 路径追踪
• Photon mapping 光子映射
• Point Based Global Illumination 基于点的全局光照
• Radiosity 辐射度
• Metropolis light transport 梅特波利斯光照传输
• Spherical harmonic lighting 球谐光照
• Ambient occlusion 环境光遮蔽
• Voxel-based Global Illumination 基于体素的全局光照
• Light Propagation Volumes Global Illumination
• Deferred Radiance Transfer Global Illumination
• Deep G-Buffer based Global Illumination

参考:
https://zhuanlan.zhihu.com/p/72673165

=== The Rendering Equation
=== General Global Illumination
=== Ambient Occlusion
=== Directional Occlusion
=== Diffuse Global Illumination
=== Specular Global Illumination
=== Unified Approaches

== 图像-空间效果(Image-Space Effects)
=== Image Processing
=== Reprojection Techniques
=== Lens Flare and Bloom
=== Depth of Field
=== Motion Blur

== 多边形之外(Beyond Polygons)
=== The Rendering Spectrum
渲染谱: 从左到右，从二维图像到几何模型，从精灵到路径与光线追踪，从简单到复杂。

=== Fixed-View Effects
=== Skyboxes
=== Light Field Rendering
=== Sprites and Layers
=== Billboarding
根据观察方向来确定多边形面朝方向的一种技术。
可以用公告板技术表示一些不具有平滑实体表面的现象，比如烟，火，雾，爆炸效果，云朵等。

公告板可以分为:
• Screen-Aligned Billboard
• World-Oriented Billboard
• Axial Billboard

=== Displacement Techniques
=== Particle Systems
粒子系统(Particle System)是一组分散的微小物体的集合，这些微小物体按照某种算法运动。
通常应用于模拟火焰，烟，爆炸，流水，树木，瀑布，旋转星系等场景。

=== 点渲染(Point Rendering)
https://zhuanlan.zhihu.com/p/400791979

=== 体素(Voxels)

== 体积与半透明性渲染(Volumetric and Translucency Rendering)
=== Light Scattering Theory
=== Specialized Volumetric Rendering
=== General Volumetric Rendering
=== Sky Rendering
=== Translucent Surfaces
=== Subsurface Scattering
=== Hair and Fur
=== Unified Approaches

== 非真实感渲染(Non-Photorealistic Rendering)

=== 概念
非真实感渲染(Non-Photorealistic Rendering, NPR)，也被称为风格化渲染(StylisticRendering)，与传统的追求照片真实感的真实感渲染不同，非真实感渲染旨在模拟艺术式的绘制风格，常用来对绘画风格和自然媒体(如铅笔、钢笔、墨水、木炭、水彩画等)进行模拟。

=== 卡通着色Toon Shading
卡通渲染(Toon Rendering，又称Cel Rendering)
参考: https://en.wikipedia.org/wiki/Cel_shading

可以将最卡通着色基本的三个要素概括为：
• 锐利的阴影(Sharp shadows)
• 少有或没有高亮的点(Little or no highlight)
• 对物体轮廓进行描边(Outline around objects)

实现方式:
TODO

参考:
https://zhuanlan.zhihu.com/p/165407030

=== Outline Rendering
轮廓描边的渲染方法可以分为:
1) 基于视点方向的描边
2) 基于过程几何方法的描边
3) 基于图像处理的描边
4) 基于轮廓边缘检测的描边
5) 混合轮廓描边

=== Stroke Surface Stylization
=== Lines
=== Text Rendering

=== 纹理调色板(Palette of Textures)
=== 色调艺术图(Tonal Art Maps)
=== 嫁接(Graftals)
=== 水彩(Watercolor)

=== 参考
http://www.red3d.com/cwr/npr/
https://stylized.realtimerendering.com/
https://viterbi-web.usc.edu/~jbarbic/cs420-s22/24-npr/24-npr.pdf
http://graphics.cs.cmu.edu/courses/15-466-f18/notes/npr.html

== 多边形技术(Polygonal Techniques)
=== Sources of Three-Dimensional Data
=== Tessellation and Triangulation
=== Consolidation
=== Triangle Fans, Strips, and Meshes
=== Simplification
=== Compression and Precision

== 曲线与曲面(Curves and Curved Surfaces)
=== Parametric Curves
=== Parametric Curved Surfaces
=== Implicit Surfaces
=== Subdivision Curves
=== Subdivision Surfaces
=== Efficient Tessellation

== 管线优化(Pipeline Optimization)
=== Profiling and Debugging Tools
=== Locating the Bottleneck
=== Performance Measurements
=== Optimization
=== Multiprocessing

== 加速算法(Acceleration Algorithms)
=== Spatial Data Structures
==== 层次包围盒(Bounding Volume Hierarchies)
==== BSP树(BSP Tree)
Binary Space Partitioning Tree, 二叉空间分割树
类似于画家算法，BSP树可以方便地将表面由后往前地在屏幕上渲染出来，特别适用于场景中对象固定不变，仅视点移动的情况。
BSP树的一个有趣特性是，如果用一种特定的方式遍历，树的几何内容可以从任何角度进行前后排序。这个排序可以近似轴对齐，精确对齐多边形BSP。 而BVH与之不同，BVH通常不包含任何形式的排序。

BSP树有两大类别，分别是为轴对齐(Axis-Aligned)BSP树和多边形对齐(Polygon-Aligned)BSP树。

参考:
https://en.wikipedia.org/wiki/Binary_space_partitioning
http://web.cs.wpi.edu/~matt/courses/cs563/talks/bsp/bsp.html
http://archive.gamedev.net/archive/reference/programming/features/bsptree/bsp.pdf
https://twobithistory.org/2019/11/06/doom-bsp.html
https://yilingui.xyz/attachments/spatial_ds--bsp_tree-octree-kd-tree.pdf

==== 四叉树(Quad Tree)
四叉树主要应用于二维空间例如地形等，八叉树主要应用于三维空间例如渲染裁切等。

参考:
https://en.wikipedia.org/wiki/Quadtree

==== 八叉树(Oct Tree)
vs. bsp and quadtree
https://stackoverflow.com/questions/99796/when-to-use-binary-space-partitioning-quadtree-octree

参考:
https://en.wikipedia.org/wiki/Octree

==== kd树(k-dimensional Tree)
The k-d tree is a binary tree in which every node is a k-dimensional point.

参考:
https://en.wikipedia.org/wiki/K-d_tree
https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf
https://zhuanlan.zhihu.com/p/127022333

==== 场景图(Scene Graphs)

参考:
https://en.wikipedia.org/wiki/Scene_graph
http://archive.gamedev.net/archive/reference/programming/features/scenegraph/index.html

=== 裁剪技术(Culling Techniques)
=== 背面裁剪(Backface Culling)
基本思想: 不需要对背面进行处理
可以在screen space或者eye space中进行。

=== 视锥裁剪(View Frustum Culling)
视锥裁剪操作位于应用程序阶段(CPU)，这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围体中，而且几乎所有包围体都是以层次形式聚集在一起。
除了层次包围体，其他的空间数据结构同样也可以用于视锥裁剪，包括八叉树和BSP树。但是当渲染动态场景时，这些方法便会显得不够灵活，不如层次包围体。

=== 入口裁剪(Portal Culling)
对建筑物模型来说，很多裁剪方面的算法可以归结为入口裁剪。
其基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口(如门或者窗户)进行视锥裁剪。当遍历入口的时候，就减小视锥。
因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展。

=== 细节与小三角形裁剪(Detail and Small Triangle Culling)
细节裁剪是一种通过牺牲质量换取速度的技术。
其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。且当视点停下来的时候，通常禁止细节裁剪。
考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪(Screen-Size Culling)。另外，细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。
细节裁剪还可以作为一种简化的LOD技术来实现，其中一个LOD是整个模型，另外一个LOD是空物体。

=== 遮挡剔除(Occlusion Culling)
有多种遮挡剔除算法:
• Hardware Occlusion Queries 硬件遮挡查询
• Hierarchical Z-Buffering 层次Z缓冲
• Occlusion Horizons 遮挡地平线
• Occluder Shrinking 遮挡物收缩
• Frustum Growing 视锥扩张
• Virtual occluder 虚拟遮挡物算法
• Shaft Occlusion Culling 轴遮挡裁剪
• The HOM algorithm 层次遮挡映射算法
• Ray Space Occlusion Culling 射线空间遮挡剔除

=== 裁剪系统(Culling Systems)

=== 层次细节(Level of Detail)
细节层次(Level of Detail, LOD)的基本思想是当物体对渲染出图像贡献越少，使用越简单的形式来表达该物体。
https://images.nvidia.com/geforce-com/international/comparisons/rise-of-the-tomb-raider/alt/rise-of-the-tomb-raider-level-of-detail-interactive-comparison-001-very-high-vs-low-alt.html

LOD的切换(LOD Switching)
LOD的选取(LOD Selection)
时间临界LOD渲染(Time-Critical LOD Rendering)

=== 大型场景渲染(Rendering Large Scenes)

== 高效阴影(Efficient Shading)
=== Deferred Shading
==== 概念
延迟渲染(Deferred Rendering)/延迟着色(Deferred Shading)是将着色计算延迟到深度测试之后进行处理的一种渲染方法。
延迟着色的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给拥有大量光源的场景提供了很多可能性。

正向渲染(Forward Rendering)/正向着色(Forward Shading)是渲染物体的一种非常直接的方式，在场景中根据所有光源照亮一个物体之后再渲染下一个物体，以此类推。其基本思路是先进行着色再进行深度测试。正向着色的主要缺点是光照计算跟场景复杂度和光源个数有很大关系。

延迟渲染(Deferred Rendering)将所有物体都先绘制到屏幕空间的缓冲(即Gbuffer/Geometric Buffer，几何缓冲区)中，再逐光源对该缓冲进行着色，避免了因计算被深度测试丢弃的片元的着色产⽣的不必要的开销。

算法复杂度: n个物体m光源，正向渲染复杂度是O(m*n)，延迟渲染复杂度则为O(n+m)。

延迟渲染的缺点:
• 内存开销较大。
• 透明物体的渲染存在问题，此时需要结合正向渲染进行渲染。
• 对多重采样抗锯齿(MultiSampling Anti-Aliasing, MSAA)的支持不友好，主要是因为需要开启MRT。

==== G-Buffer
Geometric Buffer，几何缓冲区，主要存储每个像素对应的位置Position，法线Normal，漫反射颜色Diffuse Color以及其它材质参数。根据这些信息，就可以在二维空间中对每个像素进行光照处理。

==== 过程
1. 几何处理阶段：渲染所有的几何/颜色数据到G-buffer
2. 光照处理阶段：使用G-buffer计算场景的光照

==== 延迟渲染的改进
常见的两种改进方法:
1. 将存取的G-Buffer数据结构最小化，例如Light Pre-Pass(即Deferred Lighting)，即延迟光照;
2. 将多个光照组成一组，然后一起处理，例如Tile-Based Deferred Rendering，即分块延迟渲染。

==== 延迟光照

参考:
http://diaryofagraphicsprogrammer.blogspot.com/2008/03/light-pre-pass-renderer.html

==== 分块延迟渲染

==== 参考
https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting

=== Decal Rendering
=== Tiled Shading
=== Clustered Shading
=== Deferred Texturing
=== Object and Texture-Space Shading

== 虚拟现实与增强现实(Virtual and Augmented Reality)

== 相交测试方法(Intersection Test Methods)
GPU-Accelerated Picking
Definitions and Tools
Bounding Volume Creation
Geometric Probability
Rules of Thumb
Ray/Sphere Intersection
Ray/Box Intersection
Ray/Triangle Intersection
Ray/Polygon Intersection
Plane/Box Intersection
Triangle/Triangle Intersection
Triangle/Box Intersection
Bounding-Volume/Bounding-Volume Intersection
View Frustum Intersection
Line/Line Intersection
Intersection between Three Planes

== 图形硬件(Graphics Hardware)
Rasterization
Massive Compute and Scheduling
Latency and Occupancy
Memory Architecture and Buses
Caching and Compression
Color Buffering
DepthCulling, Testing, and Buffering
Texturing
Architecture
Case Studies
Ray Tracing Architectures

== project
https://www.zhihu.com/question/24786878
https://bellard.org/TinyGL/
https://github.com/ssloy/tinyrenderer/wiki
https://github.com/skywind3000/mini3d/blob/master/mini3d.c

== shader
https://developer.valvesoftware.com/wiki/Shader

== 参考
- https://www.zhihu.com/tardis/zm/ans/2311690807?source_id=1003

- 《Fundamentals of Computer Graphics, 5th》

- 《Real-Time Rendering 4rd》
https://www.realtimerendering.com/
https://github.com/QianMo/Real-Time-Rendering-4th-Bibliography-Collection

- GAMES101:
视频: https://www.bilibili.com/video/BV1X7411F744/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html

- GAMES102:
视频: https://www.bilibili.com/video/BV1NA411E7Yr/
课件: http://staff.ustc.edu.cn/~lgliu/Courses/GAMES102_2020/default.html

- GAMES103:
视频: https://www.bilibili.com/video/BV12Q4y1S73g/
课件: https://games-cn.org/games103/

- GAMES201:
视频: https://www.bilibili.com/video/BV1ZK411H7Hc
课件: https://yuanming.taichi.graphics/teaching/2020-games201/

- GAMES202:
视频: https://www.bilibili.com/video/BV1YK4y1T7yY/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html

- 太极图形:
https://space.bilibili.com/1779922645

https://kesen.realtimerendering.com/

https://github.com/luisnts/awesome-computer-graphics
