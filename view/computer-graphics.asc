= Computer Graphics
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:hardbreaks-option:
:stem: latexmath
<<<

== 概念
- 计算机图形学(Computer Graphics)
从数据得到图像: 给定关于景象结构、表面反射特性、光源配置及相机模型等信息，生成图像。
http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm

- vs. 计算机视觉(Computer Vision)
给定图象，从图象提取信息，包括景象的三维结构，运动检测，识别物体等。

- vs. 数字图像处理(Digital Image Processing)
对已有的图像进行变换、分析、重构，得到的仍是图像。

- 计算机图形学相关术语
https://en.wikipedia.org/wiki/Glossary_of_computer_graphics

- 主要内容
** 图形渲染(Rendering)
    *** 光栅化(Rasterization)
        **** 将几何图形转换为像素(如三角形填充、Z-buffer算法)
    *** 光线追踪(Ray Tracing)
        **** 模拟光线传播路径生成逼真图像(反射、折射、阴影)
        **** 路径追踪(Path Tracing)用于全局光照
    *** 全局光照(Global Illumination)
        **** 模拟间接光照效果(如光子映射、辐射度算法)
    *** 着色(Shading)
        **** 材质模型(Phong、PBR物理渲染)
        **** 着色语言(GLSL、HLSL)
** 几何建模(Geometric Modeling)
    *** 多边形网格(Polygon Mesh)
        **** 三维模型的表示与优化(顶点、边、面)
    *** 参数化曲面
        **** 通过数学方程定义复杂曲面(如汽车、飞机设计)
    *** 程序化生成
        **** 使用算法生成地形、植被等(如Perlin噪声、L-system)
** 动画与模拟(Animation & Simulation)
    *** 关键帧动画
        **** 通过关键帧插值生成平滑运动
    *** 骨骼动画(Skeletal Animation)
        **** 用于角色动作(如Skinning、逆向动力学IK)
    *** 物理模拟
        **** 刚体/柔体动力学、流体模拟(如布料、水流)
    *** 粒子系统
        **** 模拟火焰、烟雾、爆炸等特效
** 人机交互与可视化
    *** 交互技术
        **** 鼠标/触摸输入处理、虚拟现实(VR)、增强现实(AR)
    *** 科学可视化
        **** 将数据转化为图形(如医学影像、气象云图)
    *** 信息可视化
        **** 图表、三维数据展示(如网络拓扑、地理信息系统GIS)

- 实时渲染与离线渲染
主要用途       游戏、VR                电影、动画
渲染模式       基于光栅化+光线追踪      基于REYES/路径追踪
代表工具       虚幻引擎                RenderMan
渲染速度       实时                   慢(单帧可能数小时)
渲染质量       高(接近电影级)          极高(行业标杆)

- 栅格化渲染(rasterized rendering)与光线追踪渲染(ray-traced rendering)
栅格化渲染可以更快地创建3D图像，但会牺牲画面品质，适用于电子游戏，因为游戏速度的重要性优于画质。
光线追踪渲染需要大量的计算，更适合于质量比快速交互更重要的行业，如电影、电视和广告的视觉特效，以及用于建筑可视化、设计和汽车的图像和动画。
栅格化渲染代表: Unreal。
管线追踪渲染代表: V-Ray。
现代引擎(如Unreal 5)通常采用混合方法，在保持实时性能的同时尽可能加入光线追踪效果。
光栅化为主-处理基础几何和材质; 光线追踪补充-处理反射、阴影等高质量效果。
https://dev.epicgames.com/documentation/en-us/unreal-engine/hardware-ray-tracing-in-unreal-engine

- ray-cast vs. ray-trace
https://stackoverflow.com/questions/67347177/what-is-the-difference-between-ray-tracing-ray-casting-ray-marching-and-path-t

- 色调(hue)、饱和度(saturation)、亮度(brightness/lightness)

- IMR(Immediate Mode Rendering)与TBR(Tile-Based Rendering)

== 图形渲染管线(The Graphics Render Pipeline)
=== 应用程序阶段(The Appliction Stage)
• 通过软件方式实现，开发者能够对该阶段发生的情况进行完全控制。其它阶段则全部或者部分建立在硬件基础上，改变其实现过程会非常困难。
• 一般使用CPU，也有些情况，例如compute shader会使用到GPU。
• 不能像几何和光栅化阶段那样继续分为若干个子阶段，但可以在几个并行处理器上同时执行。
• 通常包括碰撞检测、加速算法、输入检测、动画、物理仿真，以及一些不在其它阶段执行的计算，如层次视锥裁剪等加速算法。
• 将绘制图元(rendering primitives，如点、线、三角形等)输出到管线的几何处理阶段。

=== 几何处理阶段(The Geometry Processing Stage)
==== 顶点着色(Vertex Shading)
确定材质上的光照效果的操作称之为着色(shading)。
可在顶点处存储如位置，法线，颜色或者计算着色方程所需的其它信息。
顶点着色的计算完成后，其结果会被发送到光栅化阶段进行插值。

• 顶点数据(Vertex Data)
点，线，三角面
通常使用三角形网格来近似表示物体
使用索引来共享顶点间的数据，即:
VBO(Vertex Buffer Object, 顶点缓存对象): https://en.wikipedia.org/wiki/Vertex_buffer_object

==== 投影(Projection)
投影是将模型从三维空间投射到二维空间的过程。

• 正交投影(Orthograpic Projection):
平行线在变换后彼此之间仍然保持平行。

• 透视投影(Perspective Projection):
越是远离摄像机的物体，投影后看起来越小。
透视投影是模拟人类感知物体的方式。

==== 裁剪(Clipping)
当图元完全或者部分处于视体内部时，才需要将其发送到光栅化阶段。
对于部分位于视体内部的图元，需要进行裁剪处理。

常见的裁剪算法有Cohen-Sutherland算法、Liang-Barsky算法和Sutherland-Hodgman多边形裁剪算法。

vs. 帧缓存中的裁剪
帧缓存中的裁剪，将裁剪操作推迟到屏幕坐标中进行，使用一种叫做裁切(Scissoring)的技术在帧缓存中执行裁剪操作；
帧缓存中的裁剪一般只适合于光栅对象，对于几何实体，一般在帧缓存之前进行裁剪会更好些。

==== 屏幕映射(Screen Mapping)
将之前得到的空间坐标映射到屏幕坐标系上。

=== 光栅化阶段(The Rasterizier Stage)
==== 三角形建立(Tringle Setup)
主要用来计算三角形表面的差异和三角形表面的其它相关数据。

==== 三角形遍历(Tringle Traversal)
找到哪些采样点或像素在三角形中的过程通常叫三角形遍历(triangle traversal)或扫描转换(scan conversion)。

=== 像素处理阶段(The Pixel Processing Stage)
像素处理阶段是光栅化后的关键步骤，负责将片元(Fragment)转换为最终屏幕上的像素。主要流程如下：

[cols="1,3", options="header"]
|===
| 阶段名称        | 描述
| **片元着色器**  | 计算片元的颜色、深度等属性(可能包含纹理采样、光照计算)
| **裁剪测试**    | 丢弃位于视口(Viewport)外的片元
| **深度测试**    | 比较片元的深度值与深度缓冲区，决定是否覆盖(如 `GL_DEPTH_TEST`)
| **模板测试**    | 根据模板缓冲区(Stencil Buffer)的规则过滤片元(如轮廓效果)
| **融合/混合**   | 将当前片元颜色与帧缓冲区原有颜色按规则混合(如透明度处理)
|===

==== 像素着色(Pixel Shading)
在可编程GPU上执行，计算所有需逐像素操作的过程，例如纹理贴图。

- Q: 片元 vs. 像素
    ** 片元(Fragment)
        *** 光栅化后的中间产物，包含颜色、深度等属性
        *** 需通过测试(如深度测试)才能成为最终像素
        *** 例如: 透明物体叠加时，多个片元竞争同一像素位置
    ** 像素(Pixel)
        *** 屏幕显示的最小单位，由通过测试的片元决定
        *** 位置由整数坐标固定

- Q: 片元着色器 vs. 像素着色器
片元着色器(Fragment Shader)和像素着色器(Pixel Shader)本质上是同一概念的不同术语，但它们的命名差异反映了图形API的发展历史和不同阶段的术语偏好。片元着色器更符合现代图形管线原理，因其明确区分了中间片元与最终像素。
其功能本质是完全相同的。

[cols="1,2,2", options="header"]
|===
| 特性          | 片元着色器(Fragment Shader)       | 像素着色器(Pixel Shader)
| **所属API**   | OpenGL、Vulkan、Metal             | Direct3D(HLSL)
| **操作对象**  | 片元(Fragment，光栅化后的候选像素)  | 名义为像素，实际仍是片元
| **术语侧重**  | 强调渲染过程的中间阶段              | 传统术语，关联最终屏幕输出
|===

==== 融合(Merging)
合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色，还负责可见性问题(Z缓冲相关)的处理。

== GPU
=== 数据并行架构(Data-Parallel Architectures)
https://docs.nvidia.com/cuda/cuda-c-programming-guide/#the-benefits-of-using-gpus

参考:
https://www.zhihu.com/question/19903344
https://zhuanlan.zhihu.com/p/598173226
https://medium.com/codex/understanding-the-architecture-of-a-gpu-d5d2d2e8978b
https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units

=== CPU与GPU之间的通信
==== 应用层角度
1、将数据加载到显存中
2、设置渲染状态
3、调用Draw Call

Q: 什么是Draw Call?

    Draw Call是CPU向GPU发送的绘制指令，用于渲染一个或多个物体。
    每次Draw Call都会触发GPU执行一次绘制操作，涉及设置渲染状态、绑定资源(如纹理、顶点缓冲等)和绘制几何体。

Q: 为什么要减少Draw Call?

    性能瓶颈: 每次Draw Call都会增加CPU和GPU的负担，过多的Draw Call会导致CPU忙于准备数据，影响整体性能。
    渲染效率: 频繁的Draw Call会增加GPU的负载，降低渲染效率，尤其是在复杂场景中。
    帧率稳定: 减少Draw Call有助于维持稳定的帧率，避免卡顿，提升用户体验。

Q: 如何减少Draw Call?

    批处理(Batching):
        静态批处理: 将不移动的物体合并为一个大的网格，减少Draw Call。
        动态批处理: 自动合并小物体，适用于顶点数较少的物体。
        https://docs.unity3d.com/Manual/DrawCallBatching-landing.html
    合并纹理:
        纹理图集: 将多个小纹理合并为一个大纹理，减少纹理切换带来的Draw Call。
    减少材质数量:
        尽量使用相同的材质，减少材质切换带来的Draw Call。
    GPU Instancing:
        对相同网格和材质的物体使用GPU Instancing，减少Draw Call。
        https://docs.unity3d.com/Manual/GPUInstancing.html
    Level of Detail (LOD):
        根据物体与摄像机的距离，使用不同细节层次的模型，减少远处物体的渲染负担。
    遮挡剔除(Occlusion Culling):
        只渲染可见物体，避免渲染被遮挡的物体，减少不必要的Draw Call。
    减少透明物体:
        透明物体通常需要额外处理，尽量减少其数量或优化渲染顺序。
    使用高效的渲染管线:
        如Unity的SRP或Unreal Engine的渲染系统，优化渲染流程。
    参考:
        https://docs.unity3d.com/Manual/reduce-draw-calls-landing.html
        https://unrealcommunity.wiki/reducing-draw-calls-dtz72780

==== 系统层角度
https://github.com/orientye/understand/blob/main/high/gpu.asc

=== GPU管线总览(GPU Pipeline Overview)
- Vertex Shader(可编程)

- Tesselation(可编程)

- Geometry Shader(可编程)

- Clipping(固定)

- Screen Mapping(可配置)
Screen mapping is affected by window and viewport settings, internally forming a simple scale and repositioning.

- Triangle Setup & Traversal(固定)

- Pixel Shader(可编程)

- Merger(可配置)
the merger stage is not programmable, it is highly configurable and can be set to perform a wide variety of operations. It implements the “merging” functional stage, in charge of modifying the color, z-buffer, blend, stencil, and any other output-related buffers.

=== 可编程着色器阶段(The Programmable Shader Stage)
• 现代着色阶段(比如支持Shader Model 4.0，DirectX 10以及之后)使用了通用着色核心(common shader core)，这就表明顶点、几何、片段着色器共享一套编程模型。

• 早期的着色模型可以用汇编语言直接编程，但DX10之后，汇编就只在调试输出阶段可见，改用高级着色语言。

• 目前的着色语言都是C-like，如HLSL，CG和GLSL，其被编译成独立于机器的汇编语言，也称为中间语言(IL)。这些汇编语言在单独的阶段，通常是在驱动中，被转化成实际的机器语言，从而可以兼容不同的硬件实现。
https://www.khronos.org/opengl/wiki/Cg

• 着色语言虚拟机可以理解为一个处理多种类型寄存器和数据源、预编了一系列指令的处理器。考虑到很多图形操作都使用短矢量(最高四位)，处理器拥有4路SIMD(single-instruction multiple-data，单指令多数据)兼容性。每个寄存器包含四个独立的值。32位单精度浮点的标量和矢量是其基本数据类型；也随后支持32位整型。浮点矢量通常包含数据如位置(xyzw)，法线，矩阵行，颜色(rgba)，或者纹理坐标(uvwq)。而整型通常用来表示计数器，索引，或者位掩码。也支持综合数据类型比如结构体，数组，和矩阵。而为了便于使用向量，也支持调和(swizzling，即向量分量的重新排序或复制)和屏蔽(masking，只使用指定的矢量元素)等向量操作。

• 一个绘制调用(draw call)会调用图形API来绘制一系列的图元，会驱使图形管线的运行。

• 每个可编程着色阶段拥有两种类型的输入:
uniform输入，在一个draw call中保持不变的值(但在不同draw call之间可以更改)；
varying输入，shader里对每个顶点和像素的处理都不同的值。纹理是特殊类型的uniform输入，曾经一直是一张应用到表面的彩色图片，但现在可以认为是存储着大量数据的数组。

• 在现代GPU上，图形运算中常见的运算操作执行速度非常快。通常情况下，最快的操作是标量和向量的乘法和加法，以及其组合，如乘加运算(multiply-add)和点乘(dot-product)运算。其他操作比如倒数(reciprocal)、平方根(square root)、正弦(sine)、余弦(cosine)、指数(exponentiation)、对数(logarithm)运算，往往会稍微更加昂贵，但依然相当快捷。纹理操作非常高效，但其性能可能受到诸如等待检索结果的时间等因素的限制。

• 着色语言表示出了大多数场常见的操作(比如加法和乘法通过运算符+和*来表示)。其余的操作用固有的函数，比如atan(), dot(), log()等。更复杂的操作也存在内建函数，比如矢量归一化(vector normalization)、反射(reflection)、叉乘(cross products)、矩阵的转置(matrix transpose)和行列式(determinant)等。

• 流控制(flow control)是指使用分支指令来改变代码执行流程的操作。这些指令用于实现高级语言结构，如if，case，以及各种类型的循环。
Shader支持两种类型的流控制:
静态流控制(static flow control)是基于统一输入的值的。这意味着代码的流在调用时是恒定的。静态流控制的主要好处是允许在不同的情况下使用相同的着色器(例如不同数量的光源)。
动态流控制(dynamic flow control)基于不同的输入值。但动态流控制远比静态流量控制更强大但同时也需更高的开销，特别是在调用shader之间，代码流不规律改变的时候。

• Shader程序可以在程序加载或运行时离线编译。和任何编译器一样，有生成不同输出文件和使用不同优化级别的选项。一个编译过的Shader作为字符串或者文本来存储，并通过驱动程序传递给GPU。

• Shader Language/Shader Model
https://en.wikipedia.org/wiki/High-Level_Shader_Language
https://en.wikipedia.org/wiki/OpenGL_Shading_Language
https://github.com/microsoft/DirectXShaderCompiler/wiki/Shader-Model
https://en.wikipedia.org/wiki/Unified_shader_model

=== 着色API演变(The Evolution of Programmable Shading and APIs)
- DirectX
https://en.wikipedia.org/wiki/DirectX#Versions
the latest: DirectX 12 Ultimate

- OpenGL/OpenGLES
https://www.khronos.org/opengl/wiki/History_of_OpenGL
https://www.opengl.org/sdk/tools/BuGLe/documentation/releasenotes.php
https://en.wikipedia.org/wiki/OpenGL_ES#Versions
the lastest:
OpenGL 4.6 (2017)
OpenGL ES 3.2 (2015)

- Metal
since 2014
https://en.wikipedia.org/wiki/Metal_(API)#History
the latest: Metal 3

- Vulkan
since 2016
https://docs.vulkan.org/guide/latest/vulkan_release_summary.html
the lastest: Vulkan 1.4 (December 3, 2024)

=== 顶点着色器(The Vertex Shader)
对每个顶点进行诸如变换和变形在内的很多操作，提供了修改/创建/忽略顶点相关属性的功能，这些顶点属性包括颜色、法线、纹理坐标和位置。顶点着色器必须完成的任务是将顶点从模型空间转换到齐次裁剪空间。

顶点着色器是流水线上的第一个阶段，可选在GPU还是CPU上实现。在CPU上实现的话，需将CPU中的输出数据发送到GPU进行光栅化。目前几乎所有的GPU都支持顶点着色。

The vertex shader can neither create nor destroy vertices, and results generated by one vertex cannot be passed on to another vertex. Since each vertex is treated independently, any number of shader processors on the GPU can be applied in parallel to the incoming stream of vertices.

=== 曲面细分阶段(The Tessellation Stage)
曲面细分是渲染管线一个可选的阶段。
DirectX 11, OpenGL 4.0, OpenGL ES 3.2开始支持。

它利用镶嵌化处理技术对三角面进行细分，以此增加物体表面的三角面的数量。
曲面细分通常由三部分组成，用DX的术语来说，分为hull shader、tessellator、domain shader。OpenGL中hull shader被称为tessellation control shader，domain shader被称为tessellation evaluation shader。
有了曲面细分，就不需要创建高模(high-poly)来丰富网格信息了，因此基于GPU可以实现动态的LOD技术，可以根据物体距离摄像机的远近来调整多边形网格的细节，这样也就节省了资源。

=== 几何着色器(The Geometry Shader)
几何着色器是渲染管线一个可选的阶段。
DirectX 10, OpenGL 3.2, OpenGL ES 3.2开始支持。

它允许GPU高效地创建和销毁几何图元，主要对图元(点、线、三角形)的顶点进行操作。
几何着色器接收顶点着色器的输出作为输入，通过高效的几何运算，将数据输出，数据随后经过几何阶段和光栅化阶段的其他处理后，会发送给片段着色器。

After a draw call is issued, there are only three places in the pipeline where work can be created on the GPU: rasterization, the tessellation stage, and the geometry shader. Of these, the geometry shader’s behavior is the least predictable when considering resources and memory needed, since it is fully programmable. In practice the geometry shader usually sees little use, as it does not map well to the GPU’s strengths. On some mobile devices it is implemented in software, so its use is actively discouraged there.

=== Early-Z
Early-Z是现代 GPU 在渲染管线中优化性能的关键技术，通过在片元着色器之前执行深度测试，提前丢弃被遮挡的片元，减少不必要的计算开销。

想象一下，一个由光栅化生成的片元经过PS后，在进行depth test的时候发现自己被前面绘制的片元挡住了，这样的话整个PS操作都白费了。为了避免这种情况，需要GPU将合并阶段中的一些测试放到PS之前。fragment的zbuffer(以及其他被使用的，比如stencil bufer或者scissor)被用于测试可见性，如果不可见，该片元则被cull掉。这个功能被称为early-z。PS可以改变z，或者直接抛弃该片元。如果PS中有这两个操作，early-z就会被关闭，这样的话整个管线就变得低效了。DX 11和OpenGL 4.2允许PS强制打开early-z，尽管还会有一些限制。使用early-z会获得一个很大的性能提升。

[cols="1,3", options="header"]
|===
| 阶段          | 说明
| **传统管线**  | 深度测试在片元着色器之后执行 → 所有片元均需经历完整计算。
| **Early-Z**   | 深度测试提前到片元着色器之前 → 仅对可见片元执行着色计算。
|===

.传统渲染管线流程:
[source, text]
----
顶点着色 → 光栅化 → 片元着色 → 深度测试 → 输出像素
----

.Early-Z 优化流程:
[source, text]
----
顶点着色 → 光栅化 → 深度测试(Early-Z) → 片元着色 → 最终深度测试 → 输出像素
----

.Early-Z失效场景:
1. **深度写入冲突**:
   - 透明物体需关闭深度写入(`glDepthMask(GL_FALSE)`)→ 强制回退到传统管线。
2. **动态修改深度**:
   - 片元着色器中写入 `gl_FragDepth` 会禁用 Early-Z。

=== 像素着色器(The Pixel Shader)
• DirectX叫Pixel Shader, 又称片断着色器，片元着色器(Fragment Shader，OpenGL的叫法)，是完全可编程的阶段。
其主要作用是进行像素的处理，让复杂的着色方程在每一个像素上执行。像素着色器是光栅化阶段的主要步骤之一。在顶点和几何着色器执行完其操作之后，图元会被裁剪、屏幕映射，结束几何阶段，到达光栅化阶段，在光栅化阶段中先经历三角形设定和三角形遍历，之后来到像素着色阶段。
• 像素着色器常用来处理场景光照和与之相关的效果，如凸凹纹理映射和调色。名称片断着色器似乎更为准确，因为对于着色器的调用和屏幕上像素的显示并非一一对应。举个例子，对于一个像素，片断着色器可能会被调用若干次来决定它最终的颜色，那些被遮挡的物体也会被计算，直到最后的深度缓冲才将各物体前后排序。
• 需要注意，像素着色程序通常在最终合并阶段设置片段颜色以进行合并，而深度值也可以由像素着色器修改。模板缓冲(stencil buffer)值是不可修改的，而是将其传递到合并阶段(Merge Stage)。在SM2.0以及以上版本，像素着色器也可以丢弃(discard)传入的片段数据，即不产生输出。这样的操作会消耗性能，因为通常在这种情况下不能使用由GPU执行的优化。诸如雾计算和alpha测试的操作已经从合并操作转移到SM4.0中的像素着色器里计算。
• 可以发现，顶点着色程序的输出，在经历裁剪、屏幕映射、三角形设定、三角形遍历后，实际上变成了像素着色程序的输入。在Shader Model 4.0中，共有16个向量(每个向量含4个值)可以从顶点着色器传到像素着色器。当使用几何着色器时，可以输出32个向量到像素着色器中。像素着色器的追加输入是在Shader Model 3.0中引入的。例如，三角形的哪一面是可见的是通过输入标志来加入的。这个值对于在单个通道中的正面和背面渲染不同材质十分重要。而且像素着色器也可以获得片段的屏幕位置。

=== 合并阶段(The Merging Stage)
尽管不能编程，但是高度可配置，可以进行一系列的操作。其除了进行合并操作，还分管颜色修改(Color Modifying)，Z缓冲(Z-buffer)，混合(Blend)，模板(Stencil)和相关缓存的处理。

合并阶段是用于将片元的深度和颜色(PS的输出)与framebuffer上的信息进行合并。DX将这个阶段称为output merger，OpenGL将这个阶段称为per-sample操作。在大多数传统管线中，这个阶段包含stencil buffer和z buffer。如果片元可见，则就会触发color blending操作。针对不透明物件，其实并没有真正的blending，只是单纯的用fragment颜色代替之前存储的颜色。真正的将片元和framebufer上存储的颜色进行blending的操作，通常被用于半透明物件以及合成操作。

合并阶段发生在fixed-function，比如图元装配，以及可编程管线中间。尽管它并非可编程，但是高度可配置。比如color blending就可以使用多种算法。最常见的有涉及到颜色和alpha的乘法、加法、减法等，还有其他操作，比如最大、最小、按位操作等。DX10增加了将PS中两个颜色与framebuffer上颜色混合的方法，这个能力被称为双源颜色混合，不能和MRT一起使用。MRT支持color blending，DX10.1还增加了针对每个buffer使用不同blend算法的功能。
(MRT: https://en.wikipedia.org/wiki/Multiple_Render_Targets)

DX11.3提供了一个方法，可以通过ROV实现programmable blending，尽管它在性能上会有一些代价。ROV和合并阶段都是按照顺序渲染的，也就是output invariance输出不变性。不管PS的输出顺序如何，API要求结果按照输入顺序，逐物件和三角形的排序并发送到合并阶段。

=== 计算着色器(The Compute Shader)
计算着色器是一种特殊的着色器类型，它不属于传统的图形管线(顶点、几何、片元着色器等)，而是作为通用计算(GPGPU，即General-Purpose Computing on Graphics Processing Units)的一种实现方式。计算着色器允许开发者利用GPU强大的并行计算能力来处理各种非图形任务。

- 主要特点

    独立于图形管线: 不直接处理顶点或像素，专注于通用计算
    并行执行: GPU上大量核心可同时处理相同指令流
    工作组(Work Group)组织: 计算被组织成三维工作组网格
    共享内存: 工作组内线程可以访问快速共享内存

- 工作原理

    应用程序通过API(如OpenGL、DirectX、Vulkan)调度计算着色器
    GPU将计算任务划分为多个工作组(Work Group)
    每个工作组包含多个线程(通常32-1024个)
    所有线程并行执行相同的着色器代码

- 主要API支持

    DirectX: 从11.0版本开始支持
    OpenGL: 从4.3版本开始支持(通过GL_ARB_compute_shader扩展)
    Metal: 支持计算命令编码器
    Vulkan: 原生支持计算管线

- 参考
https://www.khronos.org/opengl/wiki/Compute_Shader
https://docs.unity3d.com/Manual/class-ComputeShader.html
https://vulkan-tutorial.com/Compute_Shader
https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction

=== 现代GPU
- DLSS
Deep Learning Super Sampling(深度学习超级采样)
NVIDIA DLSS通过使用较低的分辨率渲染图像，然后使用AI算法将其放大到目标分辨率。与传统的上采样技术不同，DLSS能够通过深度学习网络分析图像的细节，生成更为清晰的图像。

- HairWorks
NVIDIA HairWorks是旨在为游戏和虚拟环境中的毛发、皮毛和羽毛提供更加真实的物理模拟和视觉效果。它利用了GPU的强大计算能力，能够让虚拟角色和动物的毛发表现得更加自然、动态和细致。

=== 参考
https://simonschreibt.de/gat/renderhell/
https://pixeljetstream.blogspot.com/2015/02/life-of-triangle-nvidias-logical.html

== 数学基础
=== Mathematics for Computer Graphics
http://staff.ustc.edu.cn/~zhuang/math_for_graphics_Turk_CN.htm
https://faculty.cc.gatech.edu/~turk/math_gr.html

=== 向量

ifdef::env-github[]
- 表示: $\vec{a}$ 或者粗体表示 $\boldsymbol{a}$
- 方向: $\overrightarrow{AB}$ = $\boldsymbol{A-B}$
- 长度/模: $\Vert \vec{a} \Vert$ 或者 $|\vec{a}|$
- 单位向量
    ▪ 表示方向，长度为1
    ▪ normalization: $\hat{a}=\vec{a}/|\vec{a}|$
endif::[]

ifndef::env-github[]
- 表示: latexmath:[$\vec{a}$] 或者粗体表示 latexmath:[$\boldsymbol{a}$]
- 方向: latexmath:[$\overrightarrow{AB}$] = latexmath:[$\boldsymbol{A-B}$]
- 长度/模: latexmath:[$\Vert \vec{a} \Vert$] 或者 latexmath:[$|\vec{a}|$]
- 单位向量
    ** 表示方向，长度为1
    ** normalization: latexmath:[$\hat{a}=\vec{a}/|\vec{a}|$]
endif::[]

- 加法
    ** 几何: 四边形法则 三角形法则
    ** 代数: 坐标相加

- 图形学里一般使用列向量

- 转置

- 点乘 Dot(scalar) Product
ifdef::env-github[]
    **  $a \cdot b = |\vec{a}| |\vec{b}| \cos\theta$
endif::[]
ifndef::env-github[]
    **  latexmath:[$a \cdot b = |\vec{a}| |\vec{b}| \cos\theta$]
endif::[]
    **  交换律
    **  结合律
    **  分配律
    **  用途
        *** 向量间的夹角
        *** 一个向量在另外一个向量上的投影(projection)
        *** 向量的接近程度
        *** 分解向量(decompose)
        *** 前后关系(forward/backward)
    ** 也叫数量积/内积

- 正交

    向量正交指的是两个向量在空间中的垂直关系。
    两个向量u和v正交(orthogonal)的条件是它们的点积(内积)为零，即u⋅v=0，在几何上，这意味着它们的夹角为90度。

- 坐标系
    ** 左手/右手
    将(四个)手指指向正x方向，然后弯曲手指，将其指向正y方向，拇指指向的方向就是正z轴的方向。
    https://learn.microsoft.com/zh-cn/windows/uwp/graphics-concepts/coordinate-systems#left-and-right-handed-coordinates
    https://zhuanlan.zhihu.com/p/641172693
    ** 各平台、引擎、工具的坐标系
        D3D与Metal左手坐标系，OpenGL与Vulkan右手坐标系
        UE与Unity均为左手坐标系
        3DS Max、Maya、Houdini右手坐标系

- 叉乘 Cross(vector) Product
    ** 结果是一个向量
        其方向: 垂直于两个向量，右手坐标系
ifdef::env-github[]
        其长度: $|a \times b| = |\vec{a}| |\vec{b}| \sin\theta$
endif::[]
ifndef::env-github[]
        其长度: latexmath:[$|a \times b| = |\vec{a}| |\vec{b}| \sin\theta$]
endif::[]
    ** 反交换律
    ** 结合律
    ** 分配律
    ** 用途
        *** 构建坐标系
        *** 左右关系
        *** 内外(inside/outside)
        *** 叉乘可以用矩阵乘以列向量矩阵来表示
    ** 也叫向量积/外积
    ** Q: 如何判断一个点是否位于三角形内部?
            (1) 面积法
            (2) 重心坐标法
                任何点P都可以表示为三角形ABC顶点的加权平均：P = u*A + v*B + w*C，其中u + v + w = 1。
                u = 面积(PBC) / 面积(ABC)
                v = 面积(PCA) / 面积(ABC)
                w = 面积(PAB) / 面积(ABC)
                检查u >= 0, v >= 0, w >= 0 且 u + v + w = 1
            (3) 向量叉积法
                检查叉积符号是否一致: 都非负或都非正:
                    叉积的符号表示点相对于边的方向
                    当点P在三角形内部时，它必须在所有边的同一侧
    ** Q: 如何判断一个点是否位于多边形内部呢?
            (1) 向量叉积法
                仅适用于凸多边形
                    凸多边形判断公式:
                    多边形为凸 ⇔ 所有内角 ≤180° ⇔ 所有顶点转向一致(叉积同号)
            (2) 射线法
                从点P向任意方向(通常取水平向右)作一条射线，统计该射线与多边形边的交点数量。
                如果交点数量为奇数，则点在多边形内部；如果为偶数(包括0)，则点在外部。
                适用于任意多边形

- 投影

    向量 u 在 v 上的投影:
        长度: ∥u∥cosθ
        v 的单位方向向量: v/∥v∥

=== 矩阵
- 作用

    通常用来表示变换(transformation), 例如平移(translate)，旋转(rotate)，缩放(scale)，剪切/切变(shear)

- 性质

    交换律: 通常不满足
        Q: 如何解释矩阵乘法不满足交换律
    结合律: 满足
    分配律: 满足

- 转置(transpose)

- 单位矩阵

- 逆矩阵(inverse)

- 向量操作的矩阵形式(Vector Operations in Matrix Form)

    Q: 点乘
    Q: 叉乘

- 矩阵与线性变换

    参考: https://www.zhihu.com/question/322319580

- 正交矩阵(Orthogonal Matrix)与旋转矩阵

    正交矩阵的逆=正交矩阵的转置
    旋转矩阵是正交矩阵。正交矩阵不一定是旋转矩阵。
    任何一组正交基向量在旋转矩阵的变换下仍然是正交的，因此旋转矩阵是正交矩阵。
    但是，反之就不一定，例如某镜像变换。
    2D反射矩阵 (det = -1): 比如关于x轴的反射:
        [ 1   0 ]
        [ 0  -1 ]
    其列向量 [1, 0]ᵀ 和 [0, -1]ᵀ 相互正交且长度均为1，QᵀQ = I，为正交矩阵，但不是旋转矩阵。
    https://www.zhihu.com/question/316200199

=== 3D(与2D)变换(transformation)

==== 线性变换
- 变换
变换某种意义是就是一种function, 只是变换会暗示以特定方式来可视化这输入(向量)到输出(向量)关系。

- 线性变换

    线性变换是一类满足线性条件的变换。
    线性条件:

        可加性: T(u+v) = T(u) + T(v)
        齐次性: T(cu) = cT(u)
        向量的加法和数乘运算在变换前和变换后的效果是一样的，也就是说线性变换保持了向量的加法和数乘运算。等价条件:
            线性变换可以用矩阵乘法表示，即存在矩阵A使得: T(v)=Av
        另一种几何上的解释:
            直线在变换后仍然保持直线，不能有所弯曲(lines remain lines)；
            原点必须保持固定(origin remains fixed)

- 线性变换的矩阵表示
Q: 所有的线性变换都能用矩阵表示吗？
A: 有限维向量空间可以用矩阵表示，无限维向量空间不一定能。

- 参考
https://www.zhihu.com/question/322319580
https://www.zhihu.com/question/322319580/answer/2465352378

==== 齐次坐标系(homogeneous coordinates)

    齐次坐标就是用N+1维来代表N维坐标。

    为什么需要齐次坐标系呢？
    在某些场合下，使用齐次坐标系更为合适:
        对于平移变换，如果维度不变，用矩阵左乘是表达不了平移操作的。
        加上一个维度后，平移才可以同旋转缩放等操作一样: 统一成矩阵变换的形式。
        对于透视变换，笛卡尔坐标系下平行线永不相交，这不适用于透视场景。
        再例如，点光源与方向光等也可以用齐次坐标来表示(例如，w=1: point light, w=0: directional light)。

    2维点: (x, y, 1)
    2维向量: (x, y, 0)
    3维点: (x, y, z, 1)
    3维向量: (x, y, z, 0)

    (x, y, z, 1), (kx, ky, kz, k!=0), (xz, yz, zz, z!=0) all represent the same point (x, y, z) in 3D
    e.g. (1, 0, 0, 1) and (2, 0, 0, 2) both represent (1, 0, 0)

    齐次坐标是图形学的重要手段之一，它既能够用来明确区分向量和点，也更易于进行仿射变换。

    参考:
    http://www.songho.ca/math/homogeneous/homogeneous.html
    https://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/

==== 缩放变换(scale)

    二维:
        [sx  0]
        [0  sy]
    二维齐次:
        [sx  0  0]
        [0  sy  0]
        [0   0  1]
    三维:
        [sx  0   0]
        [0  sy   0]
        [0   0  sz]
    三维齐次:
        [sx  0   0  0]
        [0  sy   0  0]
        [0   0  sz  0]
        [0   0   0  1]

==== 反射变换(reflection)
将物体沿某条直线(2D)或某个平面(3D)进行对称翻转，保持形状和大小不变，但改变方向(镜像效果)。

    二维-沿x轴反射:
        [1  0]
        [0 -1]
    三维-沿xy平面反射:
        [1  0  0]
        [0  1  0]
        [0  1 -1]

==== 切变变换(shear)
在几何上表现为将图形沿某一方向倾斜或推拉，保持图形的面积(2D)不变/体积(3D)不变但形状发生改变。

    二维切变-水平切变，即沿X轴推拉:
        [1  k]
        [0  1]
        几何意义：所有点的 x 坐标沿水平方向移动，移动量与 y 坐标成正比，k是切变因子。
    二维切变-垂直切变，即沿Y轴推拉:
        [1  0]
        [m  1]
        几何意义：所有点的 y 坐标沿垂直方向移动，移动量与 x 坐标成正比，m是切变因子。

    三维切变变换: 在三维空间中，切变可以沿某个平面或轴进行。

==== 旋转变换(rotate)

===== 绕任意轴的旋转
- 任意轴经过原点

    Rodrigues' rotation formula(罗德里格旋转公式)
    https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula
    Q: 为什么旋转轴必须经过原点？
        罗德里格旋转公式的数学推导基于以下假设:
        旋转轴k是通过坐标原点的直线(即k的方向向量从原点出发)。
        旋转操作是绕原点的线性变换，公式中的叉积(k×v)和点积(k⋅v)均依赖原点坐标系。
    罗德里格公式的旋转轴必须经过原点，否则需通过平移调整。
    实际应用中，若需绕任意轴旋转，推荐结合平移或直接使用四元数/矩阵。

- 任意轴不经过原点

    转化为经过原点的任意轴旋转+平移

===== 欧拉角
pitch: 俯仰
yaw: 偏航
roll: 翻滚

优点: 直观易于理解；比矩阵省空间
缺点: 万向节死锁(Gimbal Lock)

什么是万向节死锁?
https://blog.csdn.net/huazai434/article/details/6458257
https://v.youku.com/v_show/id_XNzkyOTIyMTI=.html
https://www.bilibili.com/video/BV1e3411y7RX

https://www.zhihu.com/question/47736315
https://stackoverflow.com/questions/17044296/quaternion-rotation-without-euler-angles
https://stackoverflow.com/questions/9715776/using-quaternions-for-opengl-rotations/9716268#9716268
https://www.cnblogs.com/psklf/articles/5656938.html
https://www.cnblogs.com/psklf/p/5667593.html

===== 四元数(quaternion)
====== 概念
优点: 不存在万向节死锁(Gimbal Lock)问题；利于旋转插值；比较省空间
缺点: 误差问题导致失效；难于理解
四元数常用来表示rotation与orientation

====== 复数(complex numbers)
复数的相乘其实是旋转与缩放变换的复合
ifdef::env-github[]
如果有一个复数𝑧 = 𝑎+𝑏𝑖，那么 𝑧 与任意一个复数 𝑐 相乘都会将 𝑐 逆时针旋转 θ = atan2(𝑏, 𝑎) 度，并将其缩放 $\Vert \vec{z} \Vert$
endif::[]
ifndef::env-github[]
如果有一个复数𝑧 = 𝑎+𝑏𝑖，那么 𝑧 与任意一个复数 𝑐 相乘都会将 𝑐 逆时针旋转 θ = atan2(𝑏, 𝑎) 度，并将其缩放latexmath:[$\Vert \vec{z} \Vert$]
endif::[]

====== 复数与向量

====== 四元数
四元数的定义和复数非常类似，主要区别就是四元数一共有三个虚部，而复数只有一个；另外就是四元数舍弃了复数的一些性质。
[cols="2,1,1", options="header"]
|===
| **特性**       | **复数**      | **四元数**
| 维度          | 2维(1实+1虚)   | 4维(1实+3虚)
| 乘法交换性    | 可交换        | 不可交换
| 几何作用      | 二维旋转      | 三维旋转
| 单位元关系    | `i² = -1`     | `i² = j² = k² = ijk = -1`
|===

====== 插值
Lerp线性插值(LinearInterpolation)
Nlerp正规化线性插值(Normalized Linear Interpolation)
Slerp球面线性插值(Spherical Linear Interpolation)

====== 参考
http://www.crazepony.com/wiki/quaternions.html
https://zh.wikipedia.org/zh-cn/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%97%8B%E8%BD%AC
https://krasjet.github.io/quaternion/quaternion.pdf
https://www.zhihu.com/question/23005815
https://www.bilibili.com/video/BV1gP4y1a7vZ
https://www.3dgep.com/understanding-quaternions/
https://docs.unity3d.com/Manual/QuaternionAndEulerRotationsInUnity.html

===== 四元数、欧拉角、旋转矩阵之间的转换
- 参考
https://zhuanlan.zhihu.com/p/45404840

==== 平移变换(translate)
Q: 为什么平移变换不是线性变换
A: 不满足可加性、齐次性，或者，无法用矩阵乘法表示

==== 仿射变换(affine)
(先)线性变换 + (后)平移变换
https://en.wikipedia.org/wiki/Affine_transformation
线性变换是仿射变换的特例(当 b=0 时)。
平移是仿射变换的核心扩展，使其能描述更复杂的空间变换。

数学形式:

    线性变换: T(v) = Av
    仿射变换: T(v) = Av+b

==== 逆变换(inverse transform sampling)
注意:
变换矩阵的应用顺序
矩阵不满足交换律

==== 变换合成(composing transforms)
注意:
变换矩阵的应用顺序
矩阵满足结合律
坐标系差异: 局部坐标系和全局坐标系

顺序之所以重要，原因之一就是像旋转和缩放这样的转换是相对于坐标系原点进行的: 缩放以原点为中心的对象产生的结果不同于缩放远离原点的对象所产生的结果；同样，旋转以原点为中心的对象产生的结果不同于旋转远离原点的对象所产生的结果。

==== 变换分解(decomposing transforms)
注意:
变换矩阵的应用顺序

=== 3D到2D的变换

==== 模型变换(Modeling Tranformation)/世界变换(World Transform)
模型变换和世界变换通常指的是同一个概念
用于将模型的顶点从局部坐标系(Model Space/Local Space)变换到世界坐标系(World Space)。它定义了模型在世界中的位置、大小和方向。
通常来说，Mmodel = T⋅R⋅S，即先缩放，再旋转，最后平移

==== 视图/摄像机变换(View/Camera Tranformation)
- 概念
视图变换(View Transformation)或相机变换(Camera Transformation)是计算机图形学中将3D场景从世界坐标系转换到相机坐标系的过程。

- 坐标系定义

    世界坐标系：场景中所有物体的全局参考系
    相机坐标系：以相机为原点的局部坐标系
                摄像机位于原点
                观察方向通常指向 -Z 轴(在 OpenGL 等右手坐标系中较为常见)
                摄像机的向上方向指向 +Y 轴。

- 变换目的

    简化后续投影计算
    将所有物体位置表示为相对于相机的位置

- 视图变换可以用一个4x4矩阵表示，将世界坐标转换为视图坐标:

    [ x_view ]   [ R11 R12 R13 Tx ] [ x_world ]
    [ y_view ] = [ R21 R22 R23 Ty ] [ y_world ]
    [ z_view ]   [ R31 R32 R33 Tz ] [ z_world ]
    [   1    ]   [  0   0   0   1 ] [    1    ]

    推导视图矩阵的核心是构建一个从世界坐标系到摄像机坐标系的变换，这个变换由两部分组成:
        平移:
            将摄像机的世界坐标位置eye平移到原点(0,0,0)
        旋转:
            将摄像机的基向量(右向量R、上向量U、前向量F)旋转到与世界坐标系的基向量(X, Y, Z)对齐

- 参数

    eye、target、up
    想象拿着个相机拍照，eye是相机的位置，根据target和eye确定相机的朝向，up怎么理解呢？
    相机是可以转动的，up就是固定这个转动。

    eye: 摄像机在世界坐标系中的位置(ex, ey, ez)。
    target: 摄像机观察的目标点在世界坐标系中的位置(tx, ty, tz)。
    up: 世界坐标系中表示摄像机“大致向上”方向的向量(ux, uy, uz)。
        这个向量不需要与摄像机最终的向上方向U完全一致，但用于计算U。
        注意: up是一个大致的方向即可，通常可以给定(0, 1, 0)。

- 摄像机坐标系基向量

    前向量 (Forward Vector / Look-at Direction) F: 摄像机观察的方向。
    F = normalize(eye-target) (注意：eye - target 是因为观察方向是从 eye 指向 target，但为了形成指向 -Z 的坐标系，取反并归一化)。
    F = (fx, fy, fz)

    右向量 (Right Vector) R: 与观察方向垂直，指向摄像机右侧。
    R = normalize(cross(up, F)) (在右手坐标系中如OpenGL，常用此顺序)。
    R = (rx, ry, rz)

    上向量 (Up Vector) U: 与观察方向和右方向都垂直，指向摄像机正上方。
    U = normalize(cross(F, R)) (在右手坐标系中，此顺序确保 U 是向上的)。
    U = (ux, uy, uz) (注意：这个 U 是计算出来的精确向上方向，可能与输入的 up 不同)。

    叉乘 cross(A, B) 的顺序 (A, B) 决定了结果向量的方向(遵循右手或左手定则)。
    所有向量 F, R, U 都必须是单位向量(归一化 normalize)。
    这三个向量 R, U, F 必须是两两正交的(互相垂直)，并且构成一个标准正交基(Orthonormal Basis)。这保证了它们构成的旋转矩阵是正交矩阵。

    Q: 为什么 up 不垂直于 F 也能工作？
    A: cross(up, F) 会自动投影 up 到 F 的垂直平面，生成正确的 R; 此外，cross(F, R) 会重新计算 U，确保正交性。

    Q: 如果 up 与 F 平行怎么办？
    A: 例如，GLM 内部会检测 cross(up, F) 的模长是否接近零，并改用备用 up 如(1, 0, 0)。

    Q: 为什么 up 向量"大致"就行？
    1. up 的核心作用：打破旋转对称性
        仅凭观察方向（前向量 F）无法唯一确定摄像机朝向。因为围绕 F 轴旋转时，摄像机可以有不同的"向上"方向（想象人抬头时头可以左右转动）。
        up 提供了一个参考方向，用于确定摄像机"向上"的大致倾向。
    2. 计算过程的自动修正
        F = normalize(eye - target)  # 前向量（观察方向）
        R = normalize(cross(up, F))  # 右向量（修正方向）
        U = normalize(cross(F, R))   # 精确上向量（最终结果）
    3. 直观，API比较友好
        无需手动计算精确垂直的向量

- View矩阵

    Mview = RviewTview

    Translate e to origin:
        Tview:
            [1   0   0  -ex]
            [0   1   0  -ey]
            [0   0   1  -ez]
            [0   0   0    1]

    Rview:
        目标对齐:
            世界坐标系的 X (1,0,0) 需要旋转到与摄像机的 R (rx, ry, rz) 对齐;
            世界坐标系的 Y (0,1,0) 需要旋转到与摄view像机的 U (ux, uy, uz) 对齐;
            世界坐标系的 Z (0,0,1) 需要旋转到与摄像机的 -F (-fx, -fy, -fz) 对齐（因为观察方向指向 -Z）。

        一个旋转矩阵的列（或行，取决于约定）表示旋转后新坐标系的基向量在原坐标系中的坐标。
        对于一个将原坐标系 (X, Y, Z) 旋转到新坐标系 (R, U, -D) 的旋转矩阵 M_rotation：
            第一列：表示新坐标系 R 轴在原坐标系 (X, Y, Z) 中的分量。这正是 R = (rx, ry, rz)。
            第二列：表示新坐标系 U 轴在原坐标系 (X, Y, Z) 中的分量。这正是 U = (ux, uy, uz)。
            第三列：表示新坐标系 -D 轴在原坐标系 (X, Y, Z) 中的分量。这正是 -F = (-fx, -fy, -fz)。
        即Rview:
            [rx, ux, -fx, 0]
            [ry, uy, -fy, 0]
            [rz, uz, -fz, 0]
            [0,   0,   0, 1]
    
    于是Mview:
        [rx, ux, -fx, 0],   [1, 0, 0, -ex]     [rx, ux, -fx, -rx*ex-ux*ey+fx*ez]
        [ry, uy, -fy, 0], * [0, 1, 0, -ey]  =  [ry, uy, -fy, -ry*ex-uy*ey+fy*ez]
        [rz, uz, -fz, 0],   [0, 0, 1, -ez]     [rz, uz, -fz, -rz*ex-uz*ey+fz*ez]
        [0,   0,   0, 1]    [0, 0, 0,   1]     [0,  0,    0,                  1]
    考虑旋转矩阵的逆为其转置，上述Mview的计算也可以:
        [rx,  ry, rz, 0],   [1, 0, 0, -ex]     [ rx,  ry,  rz, -rx*ex-ry*ey-rz*ez]
        [ux,  uy, uz, 0], * [0, 1, 0, -ey]  =  [ ux,  uy,  uz, -ux*ex-uy*ey-uz*ez]
        [-fx,-fy,-fz, 0],   [0, 0, 1, -ez]     [-fx, -fy, -fz,  fx*ex+fy*ey+fz*ez]
        [0,    0,  0, 1]    [0, 0, 0,   1]     [  0,   0,   0,                  1]
    Mview最终结果即:
        [ rx,  ry,  rz, dot(-R, eye)]
        [ ux,  uy,  uz, dot(-U, eye)]
        [-fx, -fy, -fz, dot( F, eye)]
        [  0,   0,   0,            1]

- API
https://www.khronos.org/opengl/wiki/GluLookAt_code
https://github.com/g-truc/glm/blob/master/glm/ext/matrix_transform.inl
https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml
http://learn.microsoft.com/en-us/windows/win32/direct3d9/d3dxmatrixlookatlh

==== 投影变换(Projection Tranformation)

==== 概念
- 标准化设备坐标(Normalized Device Coordinate，NDC)

    NDC是计算机图形渲染管线中的核心坐标空间，位于投影变换之后、视口变换之前。
    其核心作用是为不同硬件提供统一的坐标标准，确保设备无关性。

    API         NDC范围       深度方向      Y轴方向
    OpenGL     [-1, 1]³    -1(近)→1(远)    上正下负
    DirectX    [ 0, 1]³     0(近)→1(远)    上负下正
    Vulkan     [ 0, 1]³     0(近)→1(远)    上负下正
    Metal      [ 0, 1]³     0(近)→1(远)    上负下正

===== 正交投影(Orthograpic Projection)
- 概念
正交投影也称Parallel Projection，它是一种不保留透视效果的投影方式，物体在投影后的大小与其距离摄像机的远近无关(即没有近大远小的效果)。

- 应用
CAD 绘图、2D 游戏、UI 渲染等场景。
一些较老的RTS游戏例如《帝国时代》会采用正交投影/正射投影，现代的RTS游戏还是会使用透视投影。
image:https://www.scratchapixel.com/images/perspective-matrix/projectionsexample.png?[]

- Ortho矩阵

    正交投影矩阵的目的是将指定的视景体(一个长方体)映射到归一化设备坐标(NDC)中。

    Mortho = Sortho * Tortho
    Tortho: 平移，将长方体中心移动到原点
    Sortho: 缩放，将长方体缩放到标准立方体[−1,1]立方空间
    注意: 右手系时，Looking at/along -Z is making near and far not intuitive (n > f)
    [2/r-l, 0, 0, 0],   [1, 0, 0, -(l+r)/2]     [2/r-l, 0, 0, -(l+r)/(r-l)]
    [0, 2/t-b, 0, 0], * [0, 1, 0, -(b+t)/2]  =  [0, 2/t-b, 0, -(b+t)/(t-b)]
    [0, 0, 2/n-f, 0],   [0, 0, 1, -(n+f)/2]     [0, 0, 2/n-f, -(n+f)/(n-f)]
    [0,   0,   0, 1]    [0, 0, 0,        1]     [0,   0,   0,            1]

- 正交投影使用长方体(Cuboid)来定义观察空间(View Volume)的原因

    数学简洁性: 可通过线性矩阵高效计算。
    兼容渲染管线: 自然映射到NDC空间，支持裁剪和深度测试。
    符合实际需求: 适合CAD、2D游戏、科学可视化等场景。
    与透视投影统一: 扩展性强，API支持完善。
    其它形状(如球体、圆柱体)由于计算复杂或无法适配图形硬件，未被采用。

- API
glm::ortho
https://learn.microsoft.com/en-us/windows/win32/direct3d9/d3dxmatrixorthooffcenterlh

===== 透视投影(Perspective Projection)
- 概念
将观察空间(相机空间）中的3D点变换到裁剪空间的过程，最终通过透视除法得到归一化设备坐标(NDC)。
Persp矩阵 -> Ortho矩阵

- vs. 正交投影

    特性        透视投影             正交投影
    视觉效果    近大远小(真实感)      平行投影(无远近缩放)
    视锥体      棱台(Frustum)        长方体
    矩阵形式    4×4(含非线性Z变换)    4×4(线性变换)

- 透视投影矩阵

    视锥体(Frustum)

    先通过某种变换把视锥体压缩成一个长方体(squish the frustum into a cuboid(n->n, f->f)) (Mpersp->ortho)
    再把长方体移到原点上压缩成标准立方体，即等于执行正交投影变换

    推导步骤:
        Mpersp = Mortho * Mpersp->ortho

        根据相似三角形，y'=(n/z)y    x'=(n/z)x
        (x)             (nx/z)     (nx)
        (y)     =>      (ny/z) ==  (ny)
        (z)             ( ?  )     (? )
        (1)             ( 1  )     (z )

        于是，Mpersp->ortho:
            [n, 0, 0, 0]
            [0, n, 0, 0]
            [?, ?, ?, ?]
            [0, 0, 1, 0]

        利用近平面上的点不会发生变化，以及远平面上的点的z不会发生变化:
            对于近平面，
                (x)             (nx/z)     (nx)
                (y)     =>      (ny/z) ==  (ny)
                (n)             ( n  )     (nn)
                (1)             ( 1  )     (z )
                Mpersp->ortho第三行: (0, 0, M33=A, M34=B)
                    A*n + B = n*n
            对于远平面的中心点，
                (0)             (0)     (0)
                (0)     =>      (0) ==  (0)
                (f)             (f)     (ff)
                (1)             (1)     (f )
                    A*f + B = f*f
            于是，A = n + f, B = -nf

        即Mpersp->ortho:
            [n, 0, 0,     0]
            [0, n, 0,     0]
            [0, 0, n+f, -nf]
            [0, 0, 1,     0]
        
        于是，Mpersp = Mortho * Mpersp->ortho:
            [2n/r-l,      0,   -(l+r)/(r-l),            0]
            [0,      2n/t-b,   -(b+t)/(t-b),            0]
            [0,           0,      (n+f)/n-f,   -2nf/(n-f)]
            [0,           0,              1,            0]

    对称视锥体的简化:
        当视锥体对称(l=-r, b=-t)时，使用参数:
        垂直视场角fovY, tan(fovY/2) = t/|n|;
        宽高比aspect = r/t;
        则t=n*tan(fovY/2), r= aspect*t
        于是，Mpersp简化为:
            [1/(aspect*tan(fovY/2)),              0,              0,            0]
            [0,                       1/tan(fovY/2),              0,            0]
            [0,                                   0,      (n+f)/n-f,   -2nf/(n-f)]
            [0,                                   0,              1,            0]

- API
glm::perspective
https://learn.microsoft.com/en-us/windows/win32/direct3d10/d3d10-d3dxmatrixperspectivefovlh

- 参考
https://zhuanlan.zhihu.com/p/362713511
https://juejin.cn/post/6994334681885835278
https://www.zjian.xyz/blog/ProjectionDerivation
https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction.html

==== 视口变换(Viewport Tranformation)
- 概念
视口变换的作用是将归一化设备坐标(NDC)映射到屏幕窗口坐标(即像素坐标)。
NDC空间通常是一个立方体，而屏幕空间是二维像素坐标加上深度值(通常用于深度缓冲)。

- screen
** an array of pixels
** size of the array: resolution
** a typical kind of raster display

- raster == screen in German
** rasterize == drawing onto the screen

- pixel
** a pixel is a little square with uniform color
** real LCD Screen Pixels
    *** Bayer_filter: https://camera-wiki.org/wiki/Bayer_filter
    *** Pixel binning: https://en.wikipedia.org/wiki/Pixel_binning

- screen space

- 视口矩阵

    Irrelevant to z
    Transform in xy plane: [-1,-1]平方空间 to [0, width]X[0, height]
    Mviewport:
            [width/2,        0,   0,    width/2]
            [0,       height/2,   0,   height/2]
            [0,              0,   1,          0]
            [0,              0,   0,          1]

- triangles

- jaggies(锯齿)

- antialiasing(反走样)
the aliasing artifacts: signals are changing too fast(high frequency), but sampled too slowly
https://en.wikipedia.org/wiki/Aliasing

- filtering(滤波)
getting rid of certain frequency contents
filtering = convolution(卷积)
filtering = averaging(平均)

- z-buffering(深度缓冲)
** 画家算法的问题
    *** 画家算法的主要问题:
        ❌ 循环遮挡: 无法处理相互交叉的几何体
        ❌ 排序困难: 复杂场景无法正确排序
        ❌ 过度绘制: 性能浪费严重
        ❌ 透明处理: 难以正确处理透明度
        ❌ 精度问题: 浮点数精度问题影响排序
    *** 现代解决方案:
        ✅ 深度缓冲: per-pixel 深度测试，完美解决遮挡
        ✅ 模板缓冲: 处理特殊遮挡效果
        ✅ 提前深度测试: GPU硬件优化
** z-buffer是一种基于像素的可见性判定算法，用于在3D渲染过程中决定哪些物体（或物体的哪些部分）是可见的，哪些被遮挡。它通过存储每个像素的深度值（Z值）来解决渲染顺序问题，避免了画家算法的排序难题。

- API
https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml
https://learn.microsoft.com/en-us/windows/win32/direct3d9/viewports-and-clipping

==== 小结
- MVP变换

    模型变换(Model Transformation): 模型空间坐标->世界空间坐标
    摄像机变换(Camera Transformation): 世界空间坐标->观察空间坐标
    投影变换(Projection Transformation): 观察空间坐标->裁剪空间坐标

- 视口变换(Viewport Transformation)
    
    裁剪空间坐标->屏幕空间坐标

V′ = Mviewport * Mpersepctive * Mview * Mmodel * V

==== 参考
https://www.songho.ca/opengl/gl_transform.html
《Real-Time Rendering 4rd》Chapter 4 Transforms
《Fundamentals of Computer Graphics, 5th》Chater 7 Transformation Matrices
《Fundamentals of Computer Graphics, 5th》Chater 8 Viewing

=== 参考
http://immersivemath.com/
GAMES001-图形学中的数学: https://www.bilibili.com/video/BV1MF4m1V7e3/

== 物理基础
=== 概念
- 刚体、布料、软体、流体

=== 光学与辐射度量学(Radiometry)
- 球谐函数(Spherical Harmonics)

- 菲涅尔反射(Fresnel Reflection)
菲涅尔反射是指光线在穿过不同折射率的介质界面（如从空气到玻璃或水）时，部分光被反射的现象。其反射率取决于入射角、光的偏振性以及两种介质的折射率。

=== 碰撞及刚体动力学

=== 力学模拟

=== 物理引擎
https://www.zhihu.com/question/466091874

== 着色基础(Shading Basics)
=== 着色模型(ShadingModels)
首先要选择一个着色模型，用来描述对象的颜色如何根据表面朝向、视方向和光照等因素的变化而变化。

=== 光源(Light Sources)
==== 概念
平行光源(也称方向光，例如太阳)、点光源(例如灯泡，蜡烛)和聚光灯(也称探照灯，例如手电筒，汽车大灯)。
在unity中，还有区域光源等灯光类型。

==== 方向光(Directional Lights)
可以认为方向光没有位置，当然实际光源上肯定是有位置的，然而由于方向光是抽象的，当与灯光距离比较大的时候，比如，一个很远的灯光照亮桌面上的一个小物件的时候，可以看成是方向光。此外基本上都会认为太阳就是方向光，除非场景是整个太阳系。

==== 精准光源(Punctual Lights)
精准光源是指有位置的光源。

- 点光源(Point/Omni Lights)

- 聚光灯(Spotlights)

- 其它精准光源

==== 其它类型
真实世界中的光源都是有尺寸和形状的，且针对物体表面上的照射是从多个方向的，这种光源被称为面光源，在实时渲染领域，其使用频率也越来越高。目前面光源的使用主要集中在两个方面: 模拟部分遮挡面光源导致的阴影边缘软化技术，模拟面光源对表面着色效果的影响技术。方向光和精准光源虽然不像过去那样无处不在了，但是不太可能被废弃。目前，已经开发出了比较简单的公式模拟面光源的近似值，这种公式耗能低，因此可以得到更广泛的应用。GPU性能的提高也使得可以使用越来越复杂的技术。

=== 着色模型实现(Implementing Shading Models)
==== 运算频率
Vertex Shader: 逐pre-tesselation顶点运算
Hull Shader: 逐surface patch运算
Domain Shader: 逐post-tesselation顶点运算
Geometry Shader: 逐图元运算
Pixel Shader: 逐像素运算

==== 示例
==== 材质系统

=== 锯齿与反锯齿(Aliasing and Antialiasing)
==== 采样和数字滤波理论(Sampling and Filtering Theory)
==== 屏幕空间反走样(Screen-Based Antialiasing)

=== 半透明，alpha与合成(Transparency, Alpha, and Compositing)
=== 显示编码(Display Encoding)
sRGB
Gamma Correction，伽玛校正

== 纹理(Texturing)
=== The Texturing Pipeline
=== Image Texturing
=== Procedural Texturing
=== Texture Animation
=== Material Mapping
=== Alpha Mapping
=== Bump Mapping
- 凹凸贴图(Bump Mapping)

- 移位贴图(Displacement Mapping)

- 法线贴图(Normal Mapping)

- 视差贴图(Parallax Mapping)

- 浮雕贴图(Relief Mapping)
浮雕贴图使用的Relief Mapping是精确的Texture Offset, 因此表现效果会更好。
=== Parallax Mapping
=== Textured Lights

== 阴影(shadow)
=== 概念
- 硬阴影 vs 软阴影
类型          特点       性能消耗       适用场景
硬阴影      边缘锐利        较低       风格化/移动端
软阴影      边缘模糊        较高       写实风格/PC/主机

- 实时阴影 vs 烘焙阴影

=== Planar Shadows
=== Shadows on Curved Surfaces
=== Shadow Volumes
=== Shadow Maps
=== Percentage-Closer Filtering
=== Percentage-Closer Soft Shadows
=== Filtered Shadow Maps
=== Volumetric Shadow Techniques
=== Irregular Z -Buffer Shadows
=== Other Applications

== 光照与颜色(light and color)

=== 概念

==== 散射与吸收
所有的光物质相互作用都是两种现象的结果: 散射(scattering)和吸收(absorption)。

散射(scattering)发生在当光线遇到任何种类的光学不连续性(optical discontinuity)时，可能存在于具有不同光学性质的两种物质分界之处，晶体结构破裂处，密度的变化处等。
散射不会改变光量，只是使其改变方向。
散射一般又分为反射(reflection)和折射(refraction)。

吸收(absorption)发生在物质内部，其会导致一些光转变成另一种能量并消失。
吸收会减少光量，但不会影响其方向。

==== 着色处理方法
===== 平滑着色(Flat shading)
三角面使用同一个颜色。

===== 高洛德着色(Gouraud shading)
每顶点求值后线性插值。
在高洛德着色的实现中，顶点着色器传递世界空间的顶点法线和位置到Shade函数(首先确保法线矢量长度为1)，然后将结果写入内插值。像素着色器将获取内插值并将其直接写入输出。
高洛德着色可以为无光泽表面产生合理的结果，但是对于强高光反射的表面，可能会产生失真(artifacts)。

===== 冯氏着色(Phong shading)
冯氏着色是对着色方程进行完全的像素求值。
在冯氏着色实现中，顶点着色器将世界空间法线和位置写入内插值，此值通过像素着色器传递给Shade函数。而将Shade函数返回值写入到输出中。请注意，即使表面法线在顶点着色器中缩放为长度1，插值也可以改变其长度，因此可能需要在像素着色器中再次执行此归一化操作。
• 注意Phong Shading和Phong Lighting Model的区别，前者是考虑如何在三个顶点中填充颜色，而后者表示的是物体被光照产生的效果。
• 冯氏着色可以说是三者中最接近真实的着色效果，开销也是最大的。因为高洛德着色是每个顶点(vertex)计算一次光照，冯氏着色是每个片元(fragment)或者说每像素计算一次光照，点的法向量是通过顶点的法向量插值得到的，所以不会出现高洛德着色也许会遇到的失真问题。

===== 小结
三种着色方案中平面着色效果最差(计算量最少)，高洛德着色其次(计算量其次)，冯氏着色最好(计算量最多)。

==== ACES(Academy Color Encoding System)

=== Light Quantities
==== Radiometry
==== Photometry
==== Colorimetry
==== Rendering with RGB Colors

=== Scene to Screen
==== High Dynamic Range Display Encoding
==== Tone Mapping
==== Color Grading

== 基于物理学的遮蔽(Physically Based Shading)
=== 概览
PBS vs. PBR:
几乎可以认为等同，https://www.adobe.com/hk_en/products/substance3d/discover/pbr.html
另一种看法是:
Physically Based Shading(PBS)专注于材质着色模型，描述表面如何与光交互的数学模型，核心是BRDF(双向反射分布函数)的实现，不考虑全局光照或环境光照，而Physically Based Rendering(PBR)则是更完整的渲染系统，包含PBS材质模型，还包含光照计算、全局光照、阴影等完整流程。

https://zhuanlan.zhihu.com/p/53086060
https://learnopengl.com/PBR/Theory

=== Physics of Light
==== Particles
==== Media
==== Surfaces
==== Subsurface Scattering

=== The Camera

=== The BRDF
==== 概念
Bidirectional Reflectance Distribution Function，双向反射分布函数，是真实感图形学中最核心的概念之一，描述的是物体表面将光能从任何一个入射方向反射到任何一个视点方向的反射特性，即入射光线经过某个表面反射后如何在各个出射方向上分布。
BRDF模型是绝大多数图形学算法中用于描述光反射现象的基本模型。

BRDF的精确定义是出射辐射率的微分(differential outgoing radiance)和入射辐照度的微分(differential incoming irradiance)之比。

==== 性质

==== 分类

==== 基于物理的BRDF
基于物理的BRDF模型通过包含材质的各种几何及光学性质来尽可能精确的近似现实世界中的材料。而一个基于物理的BRDF要必须满足至少如下两条BRDF的特性: 能量守恒、亥姆霍兹光路可逆性。

- 核心特性
** 能量守恒:
    *** 反射光的总能量不超过入射光能量
** 互易性(Helmholtz互易原理):
    *** f_r(ω_i,ω_o) = f_r(ω_o,ω_i)
** 线性叠加性:
    *** 多个光源的效果可以线性叠加

=== Illumination
=== Fresnel Reflectance
=== Microgeometry
=== Microfacet Theory
=== BRDF Models for Surface Reflection
=== BRDF Models for Subsurface Scattering
=== BRDF Models for Cloth
=== Wave Optics BRDF Models
=== Layered Materials
=== Blending and Filtering Materials
=== 优化
https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_renaldas_2D00_slides.pdf

== 局部光照(Local Illumination)
=== Area Light Sources
=== Environment Lighting
=== Spherical and Hemispherical Functions
=== Environment Mapping
=== Specular Image-Based Lighting
=== Irradiance Environment Mapping
=== Sources of Error

== 全局光照(Global Illumination)
=== 概念
全局光照(简称GI), 既考虑场景中直接来自光源的光照(Direct Light)又考虑经过场景中其他物体反射后的光照(Indirect Light)的一种渲染技术。
可以这么理解: 全局光照 = 直接光照(Direct Light) + 间接光照(Indirect Light)。

全局光照能够有效地增强场景的真实感。

全局光照的一些实现方式:
• Ray tracing 光线追踪
• Path tracing 路径追踪
• Photon mapping 光子映射
• Point Based Global Illumination 基于点的全局光照
• Radiosity 辐射度
• Metropolis light transport 梅特波利斯光照传输
• Spherical harmonic lighting 球谐光照
• Ambient occlusion 环境光遮蔽
• Voxel-based Global Illumination 基于体素的全局光照
• Light Propagation Volumes Global Illumination
• Deferred Radiance Transfer Global Illumination
• Deep G-Buffer based Global Illumination

在实时渲染领域，Probe GI(探针全局光照)和Volume GI(体全局光照)是两种不同的动态全局光照技术，用于模拟间接光照效果。
现代引擎(如UE5)常结合两者: 用Volume GI处理大范围光照，Probe GI补充细节或动态物体。

参考:
https://zhuanlan.zhihu.com/p/72673165

=== The Rendering Equation
=== General Global Illumination
=== Ambient Occlusion
=== Directional Occlusion
=== Diffuse Global Illumination
=== Specular Global Illumination
=== Unified Approaches

== 图像-空间效果(Image-Space Effects)
=== Image Processing
=== Reprojection Techniques
=== Lens Flare and Bloom
=== Depth of Field
=== Motion Blur

== 多边形之外(Beyond Polygons)
=== The Rendering Spectrum
渲染谱: 从左到右，从二维图像到几何模型，从精灵到路径与光线追踪，从简单到复杂。

=== Fixed-View Effects
=== Skyboxes
=== Light Field Rendering
=== Sprites and Layers
=== Billboarding
根据观察方向来确定多边形面朝方向的一种技术。
可以用公告板技术表示一些不具有平滑实体表面的现象，比如烟，火，雾，爆炸效果，云朵等。

公告板可以分为:
• Screen-Aligned Billboard
• World-Oriented Billboard
• Axial Billboard

=== Displacement Techniques
=== Particle Systems
粒子系统(Particle System)是一组分散的微小物体的集合，这些微小物体按照某种算法运动。
通常应用于模拟火焰，烟，爆炸，流水，树木，瀑布，旋转星系等场景。

=== 点渲染(Point Rendering)
https://zhuanlan.zhihu.com/p/400791979

=== 体素(Voxels)

== 体积与半透明性渲染(Volumetric and Translucency Rendering)
=== Light Scattering Theory
=== Specialized Volumetric Rendering
=== General Volumetric Rendering
=== Sky Rendering
=== Translucent Surfaces
=== Subsurface Scattering
=== Hair and Fur
=== Unified Approaches

== 非真实感渲染(Non-Photorealistic Rendering)

=== 概念
非真实感渲染(Non-Photorealistic Rendering, NPR)，也被称为风格化渲染(StylisticRendering)，与传统的追求照片真实感的真实感渲染不同，非真实感渲染旨在模拟艺术式的绘制风格，常用来对绘画风格和自然媒体(如铅笔、钢笔、墨水、木炭、水彩画等)进行模拟。

=== 卡通着色(Toon Shading)
==== 概念
卡通渲染(Toon Rendering，又称Cel Rendering)是一种模拟手绘动画风格的图形学技术，广泛应用于二次元、漫画风格的游戏(如《原神》《塞尔达传说: 荒野之息》)。
其核心目标是用简化的色彩和清晰的轮廓线模仿2D动画效果，而非追求物理真实感。
参考: https://en.wikipedia.org/wiki/Cel_shading

vs. NPR
NPR 是一个大类别，包含卡通渲染、水彩渲染、铅笔画风格、油画风格等。
卡通渲染是NPR中最流行的一种，专攻动漫/游戏卡通化表现。

卡通着色的一些特征:
• 锐利的阴影(sharp shadows)
• 少有或没有高亮的点(little or no highlight)
• 对物体轮廓进行描边(outline around objects)

==== 实现
TODO:

==== 参考
https://zhuanlan.zhihu.com/p/165407030
https://developer.unity.cn/projects/6180d69bedbc2a06d1042cf3?fbclid=IwAR2bcb6XucWGsML_V4nLGlSGAXvi99w-2JXqt0M-qSL16CnFOUuZtXFRPYo

=== Outline Rendering
轮廓描边的渲染方法可以分为:
1) 基于视点方向的描边
2) 基于过程几何方法的描边
3) 基于图像处理的描边
4) 基于轮廓边缘检测的描边
5) 混合轮廓描边

=== Stroke Surface Stylization
=== Lines
=== Text Rendering

=== 纹理调色板(Palette of Textures)
=== 色调艺术图(Tonal Art Maps)
=== 嫁接(Graftals)
=== 水彩(Watercolor)

=== 示例
https://zhuanlan.zhihu.com/p/602960198
https://zhuanlan.zhihu.com/p/1911837898686314146

=== 参考
http://www.red3d.com/cwr/npr/
https://stylized.realtimerendering.com/
https://viterbi-web.usc.edu/~jbarbic/cs420-s22/24-npr/24-npr.pdf
http://graphics.cs.cmu.edu/courses/15-466-f18/notes/npr.html

== 多边形技术(Polygonal Techniques)
=== Sources of Three-Dimensional Data
=== Tessellation and Triangulation
=== Consolidation
=== Triangle Fans, Strips, and Meshes
=== Simplification
=== Compression and Precision

== 曲线与曲面(Curves and Curved Surfaces)
=== Parametric Curves
=== Parametric Curved Surfaces
=== Implicit Surfaces
=== Subdivision Curves
=== Subdivision Surfaces
=== Efficient Tessellation

== 管线优化(Pipeline Optimization)
=== Profiling and Debugging Tools
=== Locating the Bottleneck
=== Performance Measurements
=== Optimization
=== Multiprocessing

== 加速算法(Acceleration Algorithms)
=== Spatial Data Structures
==== 层次包围盒(Bounding Volume Hierarchies)
==== BSP树(BSP Tree)
Binary Space Partitioning Tree, 二叉空间分割树
类似于画家算法，BSP树可以方便地将表面由后往前地在屏幕上渲染出来，特别适用于场景中对象固定不变，仅视点移动的情况。
BSP树的一个有趣特性是，如果用一种特定的方式遍历，树的几何内容可以从任何角度进行前后排序。这个排序可以近似轴对齐，精确对齐多边形BSP。而BVH与之不同，BVH通常不包含任何形式的排序。

BSP树有两大类别，分别是为轴对齐(Axis-Aligned)BSP树和多边形对齐(Polygon-Aligned)BSP树。

参考:
https://en.wikipedia.org/wiki/Binary_space_partitioning
http://web.cs.wpi.edu/~matt/courses/cs563/talks/bsp/bsp.html
http://archive.gamedev.net/archive/reference/programming/features/bsptree/bsp.pdf
https://twobithistory.org/2019/11/06/doom-bsp.html
https://yilingui.xyz/attachments/spatial_ds--bsp_tree-octree-kd-tree.pdf

==== 四叉树(Quad Tree)
四叉树主要应用于二维空间例如地形等，八叉树主要应用于三维空间例如渲染裁切等。

参考:
https://en.wikipedia.org/wiki/Quadtree

==== 八叉树(Oct Tree)
vs. bsp and quadtree
https://stackoverflow.com/questions/99796/when-to-use-binary-space-partitioning-quadtree-octree

参考:
https://en.wikipedia.org/wiki/Octree

==== kd树(k-dimensional Tree)
The k-d tree is a binary tree in which every node is a k-dimensional point.

参考:
https://en.wikipedia.org/wiki/K-d_tree
https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/kdtrees.pdf
https://zhuanlan.zhihu.com/p/127022333

==== 场景图(Scene Graphs)
BVH、BSP树和八叉树都是使用某种形式的树来作为基本的数据结构，它们的具体区别在于各自是如何进行空间分割和几何体的存储，且均是以层次的形式来保存几何物体。然而三维场景的绘制不仅仅是几何体。

渲染三维场景不仅仅只是渲染出几何图形，对动画，可见性，以及其它元素的控制，往往需要通过场景图来完成。Scene Graph是组织和管理三维虚拟场景的一种数据结构，是一个有向无环图(DAG)。

场景图是一个面向用户的树结构，可以通过纹理、变换、细节层次、渲染状态(例如材质属性)、光源以及其它任何合适的内容进行扩充。它由一棵以深度优先遍历来渲染整个场景的树来表示。

参考:
https://en.wikipedia.org/wiki/Scene_graph
http://archive.gamedev.net/archive/reference/programming/features/scenegraph/index.html

=== 裁剪技术(Culling Techniques)
=== 背面裁剪(Backface Culling)
基本思想: 不需要对背面进行处理
可以在screen space或者eye space中进行。

=== 视锥裁剪(View Frustum Culling)
视锥裁剪操作位于应用程序阶段(CPU)，这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围体中，而且几乎所有包围体都是以层次形式聚集在一起。
除了层次包围体，其他的空间数据结构同样也可以用于视锥裁剪，包括八叉树和BSP树。但是当渲染动态场景时，这些方法便会显得不够灵活，不如层次包围体。

=== 入口裁剪(Portal Culling)
对建筑物模型来说，很多裁剪方面的算法可以归结为入口裁剪。
其基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口(如门或者窗户)进行视锥裁剪。当遍历入口的时候，就减小视锥。
因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展。

=== 细节与小三角形裁剪(Detail and Small Triangle Culling)
细节裁剪是一种通过牺牲质量换取速度的技术。
其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。且当视点停下来的时候，通常禁止细节裁剪。
考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪(Screen-Size Culling)。另外，细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。
细节裁剪还可以作为一种简化的LOD技术来实现，其中一个LOD是整个模型，另外一个LOD是空物体。

=== 遮挡剔除(Occlusion Culling)
有多种遮挡剔除算法:
• Hardware Occlusion Queries 硬件遮挡查询
• Hierarchical Z-Buffering 层次Z缓冲
• Occlusion Horizons 遮挡地平线
• Occluder Shrinking 遮挡物收缩
• Frustum Growing 视锥扩张
• Virtual occluder 虚拟遮挡物算法
• Shaft Occlusion Culling 轴遮挡裁剪
• The HOM algorithm 层次遮挡映射算法
• Ray Space Occlusion Culling 射线空间遮挡剔除

=== 裁剪系统(Culling Systems)

=== 层次细节(Level of Detail)
细节层次(Level of Detail, LOD)的基本思想是当物体对渲染出图像贡献越少，使用越简单的形式来表达该物体。
https://images.nvidia.com/geforce-com/international/comparisons/rise-of-the-tomb-raider/alt/rise-of-the-tomb-raider-level-of-detail-interactive-comparison-001-very-high-vs-low-alt.html

LOD的切换(LOD Switching)
LOD的选取(LOD Selection)
时间临界LOD渲染(Time-Critical LOD Rendering)

=== 虚拟几何体(Virtual Geometry)
virtual geometry 技术的核心思路是仅渲染玩家能看到的细节，具体实现方式包括:

传统LOD由CPU计算切换，而virtual geometry 直接在GPU上决策:
使用 Compute Shader 或 Mesh Shader(DX12/Vulkan)动态剔除不可见三角面。
例如: Nanite(UE5)通过 虚拟化微多边形 实现无级LOD。

=== 大型场景渲染(Rendering Large Scenes)

== 高效阴影(Efficient Shading)
=== Deferred Shading
==== 概念
延迟渲染(Deferred Rendering)/延迟着色(Deferred Shading)是将着色计算延迟到深度测试之后进行处理的一种渲染方法。
延迟着色的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开，能够在渲染拥有成百上千光源的场景的同时依然保持很高的帧率，给拥有大量光源的场景提供了很多可能性。

正向渲染(Forward Rendering)/正向着色(Forward Shading)是渲染物体的一种非常直接的方式，在场景中根据所有光源照亮一个物体之后再渲染下一个物体，以此类推。其基本思路是先进行着色再进行深度测试。正向着色的主要缺点是光照计算跟场景复杂度和光源个数有很大关系。

延迟渲染(Deferred Rendering)将所有物体都先绘制到屏幕空间的缓冲(即Gbuffer/Geometric Buffer，几何缓冲区)中，再逐光源对该缓冲进行着色，避免了因计算被深度测试丢弃的片元的着色产⽣的不必要的开销。

算法复杂度: n个物体m光源，正向渲染复杂度是O(m*n)，延迟渲染复杂度则为O(n+m)。

延迟渲染的缺点:
• 内存开销较大。
• 透明物体的渲染存在问题，此时需要结合正向渲染进行渲染。
• 对多重采样抗锯齿(MultiSampling Anti-Aliasing, MSAA)的支持不友好，主要是因为需要开启MRT。

参考:
https://www.zhihu.com/question/1895926773939679270

==== G-Buffer
Geometric Buffer，几何缓冲区，主要存储每个像素对应的位置Position，法线Normal，漫反射颜色Diffuse Color以及其它材质参数。根据这些信息，就可以在二维空间中对每个像素进行光照处理。

==== 过程
1. 几何处理阶段: 渲染所有的几何/颜色数据到G-buffer
2. 光照处理阶段: 使用G-buffer计算场景的光照

==== 延迟渲染的改进
常见的两种改进方法:
1. 将存取的G-Buffer数据结构最小化，例如Light Pre-Pass(即Deferred Lighting)，即延迟光照;
2. 将多个光照组成一组，然后一起处理，例如Tile-Based Deferred Rendering，即分块延迟渲染。

==== 延迟光照

参考:
http://diaryofagraphicsprogrammer.blogspot.com/2008/03/light-pre-pass-renderer.html

==== 分块延迟渲染

==== 参考
https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting

=== Decal Rendering
=== Tiled Shading
=== Clustered Shading
=== Deferred Texturing
=== Object and Texture-Space Shading

== 虚拟现实与增强现实(Virtual and Augmented Reality)
Equipment and System Overview
Physical Elements
APIs and Hardware
Rendering Techniques

== 相交测试方法(Intersection Test Methods)
GPU-Accelerated Picking
Definitions and Tools
Bounding Volume Creation
Geometric Probability
Rules of Thumb
Ray/Sphere Intersection
Ray/Box Intersection
Ray/Triangle Intersection
Ray/Polygon Intersection
Plane/Box Intersection
Triangle/Triangle Intersection
Triangle/Box Intersection
Bounding-Volume/Bounding-Volume Intersection
View Frustum Intersection
Line/Line Intersection
Intersection between Three Planes

== 图形硬件(Graphics Hardware)
Rasterization
Massive Compute and Scheduling
Latency and Occupancy
Memory Architecture and Buses
Caching and Compression
Color Buffering
DepthCulling, Testing, and Buffering
Texturing
Architecture
Case Studies
Ray Tracing Architectures

== API
=== opengl
https://www.khronos.org/registry/OpenGL/specs/es/

GLM(OpenGL Mathematics):
https://github.com/g-truc/glm
GLM 是第三方库，专为 OpenGL 和图形编程设计，但因其与 GLSL 的高度兼容性，是 OpenGL 开发中的“标准数学工具包”。

=== vulkan
link:./vulkan.asc[vulkan]

=== skia
https://github.com/google/skia

=== bgfx
https://github.com/bkaradzic/bgfx

=== angle
https://github.com/google/angle
https://chromium.googlesource.com/angle/angle

=== WebGPU
https://gpuweb.github.io/gpuweb/
https://github.com/google/dawn

== project
=== render
https://www.zhihu.com/question/24786878
https://bellard.org/TinyGL/
https://github.com/ssloy/tinyrenderer/
https://github.com/ssloy/tinyrenderer/wiki
https://github.com/ssloy/tinyraytracer/
https://github.com/ssloy/tinyraytracer/wiki
https://github.com/skywind3000/mini3d/blob/master/mini3d.c
https://www.scratchapixel.com/
https://gitlab.freedesktop.org/mesa
Global Illumination: https://www.kevinbeason.com/smallpt/
https://github.com/mmp/pbrt-v3
https://github.com/NVIDIAGameWorks/Falcor
https://github.com/google/filament

=== engine
https://github.com/godotengine/godot

=== shader
https://developer.valvesoftware.com/wiki/Shader

=== Computer Vision and Image Processing
https://github.com/opencv/opencv
http://www.graphicsmagick.org/

=== sratch
==== draw line
- Bresenham’s Line Drawing Algorithm
https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm
https://supercodepower.com/docs/toy-renderer/day2-draw-line

==== draw triangle
https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling
https://supercodepower.com/docs/toy-renderer/day3-draw-triangle
https://skywind.me/blog/archives/2594
https://groups.csail.mit.edu/graphics/classes/6.837/F98/Lecture7/triangles.html

== tool
=== renderdoc
https://renderdoc.org/

=== Nsight
https://developer.nvidia.com/tools-overview

=== GPA
https://gpuopen.com/archived/gpu-perfstudio/

=== renderman
https://renderman.pixar.com/product/

== Conference/Paper
=== GDC
https://candycat1992.github.io/2022/06/11/graphics-talks/

== AI
=== 发展
https://zhuanlan.zhihu.com/p/673931753

=== 概念
- nerf(Neural Radiance Field)
神经辐射场

- 3dgs(3D Gaussian Splatting)
三维高斯飞溅技术

- text-to-image
https://github.com/Stability-AI/stablediffusion
https://github.com/black-forest-labs/flux

== 参考
- https://www.zhihu.com/tardis/zm/ans/2311690807
- https://www.zhihu.com/question/41468803/answer/2192393510
- https://www.zhihu.com/question/26720808/answer/761502017
- https://www.microsoft.com/en-us/research/articles/book-recommendation-computer-graphics/
- https://github.com/HW140701/Book-list-of-computational-geometry-and-computer-graphics/blob/main/README_zh.md

- 《Fundamentals of Computer Graphics, 5th》

- 《Computer Graphics - Principles and Practice 3rd》

- 《Real-Time Rendering 4rd》
https://www.realtimerendering.com/
https://github.com/QianMo/Real-Time-Rendering-4th-Bibliography-Collection

-《Tricks of the 3D Game Programming Gurus - Advanced 3D Graphics and Rasterization》
-《Computer Graphics from Scratch》

- 《GPU Gems》

- https://renderwonk.com/publications/
- https://www.pbrt.org/
- 《Physically Based Rendering: From Theory to Implementation 4th》
- https://github.com/kanition/pbrtbook

- 《Realistic Ray Tracing 2nd》

- 几何:
- https://www.zhihu.com/question/513726207
- 《Computational Geometry Algorithms and Applications, 3rd》
- 《Geometric Tools for Computer Graphics》 中:《计算机图形学几何工具算法详解》
- 《Polygon Mesh Processing》
- https://www.cs.cmu.edu/~kmcrane/Projects/DDG/

- GAMES101:
视频: https://www.bilibili.com/video/BV1X7411F744/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html
注意: games101使用右手坐标系

- GAMES102:
视频: https://www.bilibili.com/video/BV1NA411E7Yr/
课件: http://staff.ustc.edu.cn/~lgliu/Courses/GAMES102_2020/default.html

- GAMES103:
视频: https://www.bilibili.com/video/BV12Q4y1S73g/
课件: https://games-cn.org/games103/

- GAMES104:
视频: https://www.bilibili.com/video/BV1oU4y1R7Km/

- GAMES105:
视频: https://www.bilibili.com/video/BV1GG4y1p7fF/

- GAMES106:
视频: https://www.bilibili.com/video/BV1Uo4y1J7ie/

- GAMES201:
视频: https://www.bilibili.com/video/BV1ZK411H7Hc
课件: https://yuanming.taichi.graphics/teaching/2020-games201/

- GAMES202:
视频: https://www.bilibili.com/video/BV1YK4y1T7yY/
课件: https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html

- 太极图形:
https://space.bilibili.com/1779922645

- https://kesen.realtimerendering.com/

- https://github.com/luisnts/awesome-computer-graphics

- CMU:
http://graphics.cs.cmu.edu/?page_id=16

- stanford:
https://graphics.stanford.edu/courses/

- MIT:
https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/

- 中科大《数字几何处理》
https://www.bilibili.com/video/BV1B54y1B7Uc/

- 《Digital Modeling of Material Appearance》

- 《High Dynamic Range Imaging: Acquisition, Display, and Image-Based Lighting 2nd》

- 《Advanced Global Illumination, 2nd》

- 《Realistic Image Synthesis Using Photon Mapping》

- 《Fluid Simulation for Computer Graphics, 2nd》
