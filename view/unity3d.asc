= unity3d
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:hardbreaks-option:
<<<

== 编辑器结构
=== 文件目录

    Assets
        保留目录: https://docs.unity3d.com/Manual/SpecialFolders.html
    Library
        根据Assets目录下的游戏资源生成的中间文件
        IL指令会被编译到Library/ScripAssemblies/Assembly-CSharp.dll等文件中
        可以使用ILSpy工具对dll进行反编译
    Logs
    Packages
        要使用到的包
    ProjectSetttings
    Temp
        Library生成过程中产生的临时文件
    UserSettings
        本地工程的一些配置信息

    只需要把Assets、Packages、ProjectSetttings上传到SVN或Git。

    特殊的工程目录:
    https://blog.uwa4d.com/archives/USparkle_Addressable2.html

=== 视图

    Project视图
        项目的资源文件
        https://docs.unity3d.com/Manual/ProjectView.html
    Hierarchy视图
        保存游戏对象及其关系
        游戏对象可以保存在场景或者prefab中，场景和prefab则保存在project视图中
        https://docs.unity3d.com/Manual/Hierarchy.html
    Inspector视图
        属性
        https://docs.unity3d.com/Manual/UsingTheInspector.html
    Scene视图
        顶部的导航栏、左边的侧栏、右上角的坐标系控制器、正中间的游戏对象的编辑视图
    Game视图
        https://docs.unity3d.com/Manual/GameView.html
    导航栏视图
        https://docs.unity3d.com/Manual/Toolbar.html
        中间部分: 运行/关闭游戏、暂停游戏、逐帧播放游戏

    Unity 编辑模式下视角切换物体/游戏对象的方法:
        基本视角切换:
            选中物体后按 F 键 (Frame Selected)
            双击聚焦: 在 Hierarchy 窗口中双击物体名称
        视角环绕物体:
            聚焦物体后按住 Alt 键 + 鼠标左键拖动可以环绕观察
            按住 Alt 键 + 鼠标右键拖动可以缩放视角
        多物体视角切换:
            选中多个物体后按 F 键，视角会调整到能显示所有选中物体
        视角预设功能:
            保存视角位置:
                调整好视角后，点击场景视图右上角的相机图标
                选择 Save Camera Position 保存当前视角
            快速切换预设视角:
                使用数字键 1、2、3 等切换已保存的视角位置
                通过 Ctrl/Cmd + 数字键 保存新视角位置
        其它实用技巧:
            按 Shift + F 可以让视角跟随选中的物体（在移动物体时特别有用）
            在 2D 模式下，按 Ctrl/Cmd + Shift + F 可以快速对齐视图到选中物体
            使用场景视图右上方的方向小工具可以快速切换到标准视角（前、后、左、右等）
            按 Z 键可以切换物体轴心点与中心点的显示方式

=== Q&A

    Q: gizmos的作用与使用场景
    https://docs.unity3d.com/ScriptReference/Gizmos.html

    Q: UNITY_EDITOR宏
    https://docs.unity3d.com/Manual/scripting-symbol-reference.html

    Q: meta文件
    meta 文件是 Unity 为项目中的每个资源文件自动生成的配套文件，包含该资源在 Unity 中的导入设置和引用信息。
    作用:
        资源导入设置: 存储资源导入时的各种参数配置
        GUID 标识: 为每个资源分配全局唯一标识符
        文件依赖关系: 记录资源之间的引用关系
        资源类型识别: 告诉 Unity 如何处理该文件

=== ID
==== ClassID
https://docs.unity3d.com/Manual/ClassIDReference.html

作用:

    标识 Unity 内置的组件/资源类型

特点:

    Unity 内部定义的整数常量
    每个 Unity 内置类型有唯一的 ClassID
    例如:
        GameObject: 1
        Transform: 4
        MonoBehaviour: 114
        Texture2D: 28

Q: Unity 非内置类型有 ClassID 吗?
不会有新的 ClassID，但它们共享一个通用的 ClassID，对于自定义脚本，即 114 (MonoBehaviour)。Unity 通过 m_Script 字段（包含脚本的 guid 和 fileID）来区分和加载具体的非内置脚本类型，而不是为每个非内置类型分配一个独特的 ClassID。
Classes defined from scripts will always have class ID 114.

==== GUID FileID InstanceID
[cols="1,1,2,3", options="header"]
|===
| Identifier | Scope           | Persistence           | Example Use Case
| GUID       | Asset file      | Project-wide          | Tracking textures/prefabs in .meta
| FileID     | Object in asset | Asset-structure-based | Referencing a material inside an FBX
| InstanceID | Runtime object  | Session-only          | Fast GameObject lookup in gameplay
|===

At Edit Time:
Unity uses GUID + FileID to reference assets (e.g., a prefab links to a material via {GUID, FileID}).

At Runtime:
Unity converts GUID + FileID pairs into InstanceIDs for efficient access.

=== 参考
https://docs.unity3d.com/Manual/unity-editor.html

== Packages and package management
入口: Window > Package Management > Package Manager
https://docs.unity3d.com/Manual/PackagesList.html
https://docs.unity3d.com/Manual/FeatureSets.html

== asset
=== 概要
https://docs.unity3d.com/Manual/assets-and-media.html
https://learn.unity.com/tutorial/assets-resources-and-assetbundles
https://cloudycliff.github.io/post/unity_asset_best_practice_0/
https://blog.uwa4d.com/archives/USparkle_Addressable1.html
https://blog.uwa4d.com/archives/USparkle_Addressable2.html
https://blog.uwa4d.com/archives/USparkle_Addressable3.html

https://docs.unity3d.com/Manual/AssetWorkflow.html

Q: 如何查找资源引用?

=== 导入
https://docs.unity3d.com/Manual/import-assets.html

使用脚本管理导入:
https://docs.unity3d.com/Manual/ScriptedImporters.html
https://docs.unity3d.com/ScriptReference/AssetPostprocessor.html

==== AssetMetadata
https://docs.unity3d.com/Manual/AssetMetadata.html

=== Resources目录
可以在Assets下的任何目录下，并且可以有任意多份。
所有Resources目录下的文件都会直接打进一个特殊的Bundles中，并且在游戏启动时，会生成一个序列化映射表，并加载进内存里。
https://blog.uwa4d.com/archives/USparkle_Addressable2.html

适用场景:
某些资源是项目整个生命周期都必须要用的
有些很重要，但是却不怎么占内存的
不怎么需要变化，并且不需要进行平台差异化处理的
用于系统启动时候最小引导的

=== StreamingAssets目录
https://docs.unity3d.com/Manual/StreamingAssets.html
Unity发布程序或者游戏，资源随包出去的，只有2个: Resources目录，以及StreamingAssets。
这个目录的下的文件，都会原封不动的复制到最终的APK或者iOS的包内。

适用场景:
StreamingAssets适合存放那些不需要运行时修改但需要随包体一起发布的原始资源文件。

=== The Asset Database
https://docs.unity3d.com/Manual/AssetDatabase.html
https://docs.unity3d.com/ScriptReference/AssetDatabase.html

=== AssetBundle
==== 概要
https://docs.unity3d.com/Manual/AssetBundlesIntro.html

https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a7
https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a9

==== Layout
https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a7

==== Loading AssetBundles
https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html
https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html

==== Loading Assets From AssetBundles
https://docs.unity3d.com/ScriptReference/AssetBundle.html

- LoadAsset (LoadAssetAsync)
- LoadAllAssets (LoadAllAssetsAsync)
- LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)

===== Low-level loading details
nityEngine.Object loading is performed off the main thread: an Object's data is read from storage on a worker thread. Anything which does not touch thread-sensitive parts of the Unity system (scripting, graphics) will be converted on the worker thread. For example, VBOs will be created from meshes, textures will be decompressed, etc.
From Unity 5.3 onward, Object loading has been parallelized. Multiple Objects are deserialized, processed and integrated on worker threads. When an Object finishes loading, its Awake callback will be invoked and the Object will become available to the rest of the Unity Engine during the next frame.
The synchronous AssetBundle.Load methods will pause the main thread until Object loading is complete. They will also time-slice Object loading so that Object integration does not occupy more than a certain number of milliseconds of frame time. The number of milliseconds is set by the property Application.backgroundLoadingPriority:
ThreadPriority.High: Maximum 50 milliseconds per frame
ThreadPriority.Normal: Maximum 10 milliseconds per frame
ThreadPriority.BelowNormal: Maximum 4 milliseconds per frame
ThreadPriority.Low: Maximum 2 milliseconds per frame.
From Unity 5.2 onwards, multiple Objects are loaded until the frame-time limit for Object loading is reached. Assuming all other factors are equal, the asynchronous variants of the asset loading APIs will always take longer to complete than the comparable synchronous version due to the minimum one-frame delay between issuing the asynchronous call and the object becoming available to the Engine.

===== AssetBundle依赖
https://docs.unity3d.com/Manual/AssetBundles-Dependencies.html

Q: 循环依赖？

===== AssetBundle manifest文件
https://docs.unity3d.com/ScriptReference/AssetBundleManifest.html

===== asset进bundle
https://docs.unity3d.com/Manual/AssetBundles-Preparing.html

===== AssetBundle变体(AssetBundleVariant)

==== xasset
https://github.com/xasset/xasset

==== YooAsset
https://github.com/tuyoogame/YooAsset

==== The Addressable Asset System
https://docs.unity3d.com/Manual/com.unity.addressables.html

缺点:
https://www.cnblogs.com/LiuOcean-Blog/p/wei-shen-me-pao-qi-le-addressable.html

==== asset graph
https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html

==== 参考
https://zhuanlan.zhihu.com/p/660510471

== script
=== scripting-backends
==== JIT与AOT
JIT: Just-In-Time，程序运行过程中进行转译
AOT: Ahead-Of-Time，提前将IL转译成机器码并且存储在文件中，此文件不能完全独立运行
完全静态编译: 只支持少数平台，基于AOT进一步生成所有的机器码

==== mono
解决C#的跨平台问题(在mono之前，C#只在windows平台上使用)。

开发模式下使用的是mono:
https://docs.unity3d.com/Manual/Mono.html

在游戏发布后自动将DLL转换成IL2CPP的方式。

==== IL2CPP
- unity采用IL2CPP的原因

    为了解决mono的问题，unity推出了il2cpp, 将c#转成c/c++代码，进而编译出native二进制代码。
    C#的一些高级特性，比如垃圾回收，线程等，则都实现到il2cpp runtime库(il2cpp vm)上。

    Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成
    Mono版本授权受限，换IL2CPP，IL2CPP VM是完全自己开发的组件，从而解决了授权问题
    提高运行效率，换成IL2CPP以后，程序编译成了硬件目标机器指令，运行效率提升

- 垃圾回收
The Boehm-Demers-Weiser conservative C/C++ Garbage Collector (bdwgc, also known as bdw-gc, boehm-gc, libgc)
https://github.com/ivmai/bdwgc
基本原理是在new和delete时记录引用关系，在收集垃圾的时候进行扫描，卸载无用的垃圾内存。

- 源码
unity自带源码位置:
    windows: Editor\2022.3.32f1\Editor\Data\il2cpp
    OSX: Contents/Frameworks/il2cpp/build
https://github.com/4ch12dy/il2cpp/
https://www.lfzxb.top/il2cpp-all-in-one/

- 参考
https://docs.unity3d.com/Manual/IL2CPP.html
https://blog.unity.com/topic/il2cpp
https://blog.unity.com/search?q=il2cpp
https://blog.unity.com/engine-platform/an-introduction-to-ilcpp-internals

==== coreclr
https://blog.unity.com/engine-platform/porting-unity-to-coreclr

==== 扩展
https://github.com/jacksondunstan/UnityNativeScripting

==== 参考
https://docs.unity3d.com/Manual/scripting-backends.html

=== ExecutionOrder
https://docs.unity3d.com/Manual/ExecutionOrder.html

- 多个脚本的执行顺序
Project Settings -> Script Execution Order
DefaultExecutionOrder attribute:
https://docs.unity3d.com/2022.3/Documentation/ScriptReference/DefaultExecutionOrder.html
RuntimeInitializeOnLoadMethodAttribute:
https://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html

- +UniTask执行顺序
https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae

=== coroutine
==== 概览
https://blog.matheusamazonas.net/posts/coroutines_async_await

==== unity coroutines
https://docs.unity3d.com/Manual/Coroutines.html
https://docs.unity3d.com/Manual/ExecutionOrder.html#Coroutines

vs. async/await:
https://discussions.unity.com/t/differences-between-async-await-c-and-coroutines-unity3d/680771

==== UniTask
===== 概览
https://github.com/Cysharp/UniTask
https://neuecc.medium.com/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd
https://stackoverflow.com/questions/78519132/async-method-vs-unitask-return
https://github.com/Cysharp/UniTask?tab=readme-ov-file#async-void-vs-async-unitaskvoid

===== 超时
https://github.com/Cysharp/UniTask?tab=readme-ov-file#timeout-handling
注意事项:
UniTask has .Timeout, .TimeoutWithoutException methods however, if possible, do not use these, please pass CancellationToken. Because .Timeout work from external of task, can not stop timeoutted task. .Timeout means ignore result when timeout. If you pass a CancellationToken to the method, it will act from inside of the task, so it is possible to stop a running task.
https://github.com/Cysharp/UniTask/issues/218

===== 取消
https://github.com/Cysharp/UniTask/?tab=readme-ov-file#cancellation-and-exception-handling

===== 生命周期
销毁时机:
异步方法完成
取消或中断

===== Forget()
- 概念
当调用UniTask.Forget()时，实际上是启动了一个异步任务，但调用者立即"遗忘"了这个任务，不再对其进行显式的等待或管理。这意味着从调用Forget()的那一刻起，这个异步任务就开始在后台独立运行，调用者不会因为这个任务未完成而被阻塞等待。

- 潜在的问题
(1)资源释放
由于调用者不再跟踪这个异步任务，它可能会在后台持续运行，即使在某些情况下它已经不再需要。如果这个异步任务引用了一些资源(如数据库连接、文件句柄等)，并且没有正确地释放这些资源，就可能导致资源泄漏。
例如，如果异步任务中打开了一个文件进行写入，但没有在任务完成时关闭文件，而调用者又无法知道任务何时完成，就可能导致文件一直处于打开状态，占用系统资源。
(2)异常处理
如果异步任务在运行过程中出现错误，调用者可能无法察觉。因为调用者已经"遗忘"了这个任务，不会捕获任何可能由这个任务抛出的异常。这可能导致程序出现未预期的行为或错误，并且难以调试或者确定问题的根源。
此时，建议捕获异常。

- 适用场景
UniTask.Forget()通常适用于那些不需要立即结果、对结果不敏感或者可以在后台持续运行而不影响程序主要逻辑的异步任务。例如，日志记录、后台数据同步等任务。

- 注意事项
在使用UniTask.Forget()时，应该确保异步任务不会导致严重的资源泄漏或意外的副作用。如果异步任务涉及到重要的资源管理或可能产生严重错误，应该考虑使用其他方式来管理异步任务的生命周期，如等待任务完成、使用取消令牌等。
同时，应该对异步任务进行适当的错误处理，例如在异步任务中使用try-catch块来捕获异常，并采取适当的措施进行处理，以避免异常被忽略而导致程序出现不可预测的行为。

- 实现
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskExtensions.cs
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskVoid.cs

===== 源码分析
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/IUniTaskSource.cs

=== 序列化
https://docs.unity3d.com/Manual/script-serialization.html

使用场景:
https://docs.unity3d.com/Manual/script-serialization-how-unity-uses.html

配置:
Project Settings -> Editor -> Asset Serialization -> Mode 推荐使用Force Text，方便查看，不会影响最终游戏的发布效率

格式描述:
https://docs.unity3d.com/Manual/FormatDescription.html

序列化嵌套:
基础类型以及数组等支持序列化，但有些类型不支持序列化，例如字典、List<List<T>>等，需要包装在类里。

序列化引用

序列化继承

=== 脚本属性(Attributes)
- 公共/非公共属性
非公共属性: 默认情况下，非公共属性(private或protected)不会在Inspector中显示。
[SerializeField]: 用于在Inspector中显示非公共属性。
[HideInInspector]: 用于隐藏公共属性，使其不在Inspector中显示。

- 序列化属性

- Header属性

- 编辑模式下执行脚本

- 枚举序列化别名

- 必须包含的组件

- 其它UI扩展面板

- 可选择属性

- 自定义属性

- 参考
https://docs.unity3d.com/Documentation/Manual/unity-attributes.html
https://github.com/teebarjunk/Unity-Built-In-Attributes

=== 通过脚本操作对象和组件
DontDestoryOnLoad():
https://docs.unity3d.com/ScriptReference/Object.DontDestroyOnLoad.html

=== 参考
https://docs.unity3d.com/Manual/ScriptingSection.html

== API
=== 类层次
https://docs.unity3d.com/400/Documentation/ScriptReference/20_class_hierarchy.html

=== Object
https://docs.unity3d.com/Manual/class-Object.html
https://docs.unity3d.com/ScriptReference/Object.html

=== GameObject
https://docs.unity3d.com/Manual/GameObjects.html
https://docs.unity3d.com/ScriptReference/GameObject.html
游戏对象

=== Component
https://docs.unity3d.com/ScriptReference/Component.html
游戏组件

游戏组件与游戏对象的关系

游戏组件的种类

=== MonoBehaviour
==== 简介
https://docs.unity3d.com/Manual/class-MonoBehaviour.html
https://docs.unity3d.com/ScriptReference/MonoBehaviour.html
游戏脚本

继承关系:
MonoBehaviour ――――――▷ Behaviour ――――――▷ Component ――――――▷ Object

Q: MonoBehaviour vs. ScriptableObject
继承关系:
ScriptableObject ――――――▷ Object

==== 生命周期
===== 执行顺序
https://docs.unity3d.com/Documentation/Manual/execution-order.html

===== 初始化和销毁
Awake()/OnDestory()、OnEnable()/OnDisable()、OnApplicationQuit()

Awake(): 脚本首次被初始化时调用，整个生命周期只会执行一次
OnEnable(): 脚本被启动时调用，整个生命周期会执行多次
OnApplicationQuit(): 程序退出时调用
OnDisable(): 脚本被关闭时调用，整个生命周期会执行多次
OnDestory(): 脚本被销毁时调用，整个生命周期只会执行一次

===== 二次初始化
OnEnable()后会调用Reset(), 然后调用Start()方法。

Reset()运行模式下不会执行，通常用来做一些编辑器下的初始化工作，尽量使用UNITY_EDITOR的宏将其包裹起来。

为什么会有Start()呢？
Awake() vs. Start()
https://stackoverflow.com/questions/34652036/awake-and-start
https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html
https://docs.unity3d.com/ScriptReference/MonoBehaviour.Start.html

===== 固定更新FixedUpdate()
默认每0.02秒调用一次，可以在Editor->Project Settings->Time里配置。

FixedUpdate()底层依赖Update(), 会在当前帧的Update()前执行。
如果帧率稳定，表现较好；如果帧率不稳定，FixedUpdate()则会表现糟糕。

通过设置最大间隔时间参数Maximum Allowed Timestep，便不会出现一帧内执行太多次的FixedUpdate()。

一般物理相关的更新都放在FixedUpdate()中。

===== 内置协程回调
IEnumerator

yield return:

    yield return null 等待一帧
    yield return StartCoroutine(CallSomething())
    yield return new WaitForSeconds(5)
    yield return new WaitForFixedUpdate()

与UniTask比较:
https://medium.com/@burakzgen/unity-tips-6-b47d3af4b9ff

内置协程回调相比于UniTask，几乎没什么优势，一般不太建议使用。

===== 脚本逻辑更新
Update()
LateUpdate()

Update is called once per frame and is the main function for frame updates.

LateUpdate is called once per frame, after Update has finished. Any calculations performed in Update will have completed when LateUpdate begins. A common use for LateUpdate would be a following third-person camera. If you make your character move and turn inside Update, you can perform all camera movement and rotation calculations in LateUpdate. This will ensure that the character has moved completely before the camera tracks its position.

https://docs.unity3d.com/Manual/execution-order.html#UpdateOrder

===== 渲染
逻辑更新结束后就进入场景渲染了、之后是Gizmo渲染、以及GUI渲染。
https://docs.unity3d.com/Documentation/Manual/execution-order.html#Rendering

=== Transform
https://docs.unity3d.com/Manual/ScriptingTransform.html
https://docs.unity3d.com/ScriptReference/RectTransform.html

=== Vectors
https://docs.unity3d.com/Manual/VectorCookbook.html

=== Quaternion
https://docs.unity3d.com/Manual/class-Quaternion.html

=== ScriptableObject
https://docs.unity3d.com/Manual/class-ScriptableObject.html

Q: ScriptableObject vs. MonoBehaviour

=== Time and frame rate management
https://docs.unity3d.com/Manual/TimeFrameManagement.html

=== Mathf
https://docs.unity3d.com/Manual/class-Mathf.html

=== Random
https://docs.unity3d.com/Manual/class-Random.html

=== Debug
https://docs.unity3d.com/Manual/class-Debug.html

=== Gizmos and Handles
https://docs.unity3d.com/Manual/GizmosAndHandles.html

=== 参考
https://docs.unity3d.com/ScriptReference/

== UI
=== NGUI
NGUI vs. UGUI
https://zhuanlan.zhihu.com/p/445999150

=== UGUI
原生
如果UGUI和NGUI选一个，选UGUI

==== 游戏界面
- Text组件

- 富文本
UGUI支持富文本，但只支持简单的标签，无法支持图文混排。

- 描边和阴影
- 动态字体
- 字体花屏

- Text Mesh Pro
TextMesh Pro (TMP) 是 Unity 官方推出的高级文本渲染系统，用于替代传统的 UnityEngine.UI.Text，提供更清晰、更灵活的文本显示方案。它广泛应用于 UI 文本 和 3D 世界文本，支持丰富的排版、动态字体效果和高性能渲染。
https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.html

    TMP 的核心组件:
        TextMeshProUGUI
            用于 UI 系统（Canvas），继承自 UnityEngine.UI.Graphic。
            适用于 HUD、菜单、对话框等 UI 元素。
        TextMeshPro
            用于 3D 场景（如漂浮文字、3D 游戏中的标签）。
            继承自 MeshRenderer，直接渲染在 3D 空间。

- SDF字体
Signed Distance Field，有向距离场。与Text的位图原理不太一样，保存的是文本每个点相对于文字边缘的距离。
https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/FontAssetsSDF.html

- 图文混排
- 样式
- 文字fallback
- 点击事件
- Image组件
- Raw Image组件
- Button组件
- Toggle组件
- Scroll View组件
- Slider组件
- Scrollbar组件
- Dropdown组件(下拉选单)
- InputField组件

==== 界面布局
- Rect Transform组件
- 拉伸
- 自动布局
- 文本自适应
- Layout Element组件
- Layout Group组件
- Content Size Filter组件

==== Canvas组件
- 概念
Canvas组件是UI的基础画布，所有UI元素必须放在Canvas对象下面，并且支持嵌套。
Canvas支持3种绘制方式: Overlay(最上层)、Camera与World Space(3D布局)。
其中，用得最多的是Camera，它可以把正交摄像机投影出来的UI元素绘制在Canvas面板上。
3D界面则使用透视摄像机让UI达到更好的交互效果。

- UI摄像机
- 3D界面
- 自适应UI
- Canvas与3D排序

- 裁剪
UGUI提供了两种裁剪方式:
一种是Mask裁剪，优点是可以裁剪出任意形状的UI，缺点是需要额外占用一个Draw Call
另一种是矩形裁剪，Rect Mask 2D并不会额外占用一个Draw Call，应尽可能使用这种方式来裁剪

- 裁剪粒子

==== Atlas图集
- 创建Atlas
- 读取Atlas
- Variant
- 监听加载事件

- 多图集管理

==== 事件系统
- Graphic Raycaster组件
- UI事件
- UI事件管理
- UnityAction和UnityEvent
- C#事件系统
- 3D事件
- K帧动画(关键帧动画)
- 使用Scroll Rect组件制作游戏摇杆
- 点击区域优化

==== API
- RaycastResult
https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.RaycastResult.html
获取:
https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.EventSystem.html#UnityEngine_EventSystems_EventSystem_RaycastAll_UnityEngine_EventSystems_PointerEventData_System_Collections_Generic_List_UnityEngine_EventSystems_RaycastResult__

=== UI Toolkit
设计目标是替代UGUI，UGUI的最大问题是效率低。
当前还没有UGUI成熟。
自Unity 2021.2起，UI Toolkit被官方内置在Unity中，与UGUI的地位相当。

vs. UGUI
https://docs.unity3d.com/Manual/UI-system-compare.html

- 性能
- 使用
- (当前)不足
- 推荐使用场景

=== IMGUI
早期的UI系统，运行时效率非常低下
编辑模式下的UI通常比较简单，且不太在意效率，因此目前IMGUI被广泛应用在编辑器UI中
https://docs.unity3d.com/ScriptReference/UnityEngine.IMGUIModule.html

=== FGUI
跨平台
https://www.fairygui.com/
https://github.com/fairygui

=== 参考
https://www.lfzxb.top/personal-ui-framework-consider/

== 2D游戏开发

=== Sprites
==== Sprite Renderer组件
- 渲染原理
- 渲染排序

- 裁剪
SpriteRender与 Particl System 都可以使用 Sprite Mask 进行裁剪。
裁剪的原理是使用 Shader 的模板测试。

- 2D帧动画

- 2D骨骼动画
IK反向运动: 改动子节点影响父节点

- 精灵资源库

==== 像素风
==== 精灵形状
==== 精灵编辑器

=== Tile地图
https://docs.unity3d.com/Manual/tilemaps/tilemaps-landing.html

=== 2D物理系统
https://docs.unity3d.com/Manual/2d-physics/2d-physics.html

Unity 2D和3D项目的物理引擎均基于PhysX。

- Collider 2D组件
- Rigidbody 2D组件
- 碰撞事件
- 碰撞方向
- 触发器监听
- 复合碰撞体
- Effectors 2D组件
- 关节
- 物理材质与恒定力
- 计算区域

=== 2D game development in URP
https://docs.unity3d.com/Manual/2d-urp-landing.html

== 3D游戏开发
=== Renderer
- Mesh Renderer(网格渲染器)
- Skinned Mesh Renderer(蒙皮网格渲染器)
- Particle System(粒子系统)
- Trail Renderer(拖尾渲染器)
- Line Renderer(线渲染器)
- Terrain(地形)

=== 游戏对象和资源
- 静态对象
勾选static

- 标记(tag)
个游戏对象只能设置一个独有的标记

- 层
层通常需要和LayerMask配合使用

- Prefab
https://docs.unity3d.com/Manual/Prefabs.html

- Prefab嵌套
https://docs.unity3d.com/Manual/NestedPrefabs.html

- Prefab和游戏对象

- 实例化

- 游戏资源
Unity使用的资源可以分为外部资源和内部资源。
内部资源: unity中创建的资源，如Prefab、场景、材质球、动画剪辑、RenderTexture等；
外部资源: 通过第三方工具产生的资源，如贴图、模型、声音、视频等。
Unity并不会直接使用外部资源，而是将它们生成为另一份资源来使用，好处是可以通过一些配置对原始资源进行加工。
引擎真正使用的资源被保存在Library/Artifacts/中，文件名是生成的资源的MD5名称。
常用的游戏资源类型:

    模型文件:
        文件后缀.fbx
        引擎中的对应类型是Mesh和AnimationClip
    贴图文件:
        文件后缀.bmp、.tif、.tga、.jpg、.png或.psd
        引擎中的对应类型是Texture、Texture2D、Sprite
    音频文件:
        .mp3、.ogg、.wav等
        引擎中的对应类型是AudioClip
    文本文件:
        .txt、.json、.yaml等
        引擎中的对应类型是TextAsset

- 场景
https://docs.unity3d.com/Manual/working-with-scenes.html

- 场景模板
场景模板管线: A Scene Template Pipeline script lets you execute custom code when you create a new scene from the template.
https://docs.unity3d.com/Manual/scene-templates.html

=== 动画系统

=== 3D物理系统
- 角色控制器(Charator Controller)
- 刚体物理(Rigibody Physics)
- 碰撞体(Collider)
- 关节(Joints)
- 衔接(Articulations)
- 布娃娃物理(Ragdoll Physics)
- 布料(Cloth)

=== 输入系统
- 射线
UI点击事件和点选模型在底层都是通过射线实现的。
检测点击事件就是检测点击的这条射线是否会与物体发生碰撞。

=== Transform组件
- 角色移动

=== 3D与2D结合
https://zhuanlan.zhihu.com/p/363965652

== 静态对象
作用: 提升性能
https://docs.unity3d.com/Manual/StaticObjects.html

=== 光照贴图

=== 反射探针

=== 遮挡剔除

=== 静态合批
https://docs.unity3d.com/Manual/static-batching.html
https://docs.unity3d.com/Manual/dynamic-batching.html

=== 导航网格

== graphics
=== render pipelines
==== 概念
https://docs.unity3d.com/Manual/render-pipelines.html
https://zhuanlan.zhihu.com/p/353687806

前向渲染: 适用于光源较少、透明物体较多的场景。
延迟渲染: 适用于光源数量较多的场景，但不适合透明物体，且需要较高的硬件性能。
前向渲染+: 结合了前向渲染和延迟渲染的优点，适合需要处理多个光源且仍需支持透明物体的场景。

===== 前向渲染(Forward Rendering)
- 概念

    前向渲染是传统的渲染方法。
    在前向渲染中，每个像素的渲染都涉及所有的光源。
    每个物体的每个表面会根据场景中所有的光源进行计算，这意味着渲染时会处理每个物体与光源的交互。

- 原理
每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区的信息: 颜色缓冲区与深度缓冲区。利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。
对于每个逐像素光源，都需要进行一次完整的渲染流程。
如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。

- 优点

    简单高效: 适合较少的光源和相对简单的场景。
    透明度支持: 前向渲染在处理透明物体时非常高效，因为它逐个像素进行计算。
    支持多种后处理效果: 可以与许多后处理效果(如光晕、景深等)很好地结合。
    硬件兼容性好: 对旧的硬件或低端设备有更好的支持。

- 缺点

    性能瓶颈: 如果场景中有很多光源，性能可能会下降，因为每个物体都需要计算所有光源的影响。
    难以处理复杂的光源交互: 当有很多动态光源时，前向渲染的性能会受到显著影响。

- 应用场景

    适合低光源、透明物体较多的场景，
    如一些移动设备上的游戏、VR项目，或者需要精细控制每个物体外观的场景。

- 设置

    TODO:
    Shader: 设置Pass的渲染标签

- 参考
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-universal-renderer.html#rendering-path-comparison
https://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html
https://docs.unity3d.com/Manual/PerPixelLights-BuiltIn.html

===== 延迟渲染(Deferred Rendering)
- 概念

    延迟渲染是一种不同于前向渲染的方法，它将渲染过程分为多个阶段，
    特别是在计算光照时，先将场景的几何信息(如位置、法线、颜色等)渲染到多个缓冲区(G-buffer)中，
    再在后续的步骤中计算光源的影响。
    这使得延迟渲染能够在渲染大量光源时，显著减少性能损失。

- 原理
延迟渲染是一种更古老的渲染方法，但由于前向渲染可能造成的瓶颈问题，近几年又流行起来。除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲(G-buffer)，其中 G 是英文 Geometry 的缩写。
G 缓冲区存储了所关心的表面（通常指的是离摄像机最近的表面）的其它信息，例如该表面的法线、位置、用于光照计算的材质属性等。
延迟渲染主要包含了两个Pass。在第一个Pass中，不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要通过深度缓冲区来实现。当发现一个片元是可见的，就把它的相关信息存储到G缓冲区中。然后，在第二个Pass中，利用G缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。
延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和使用的屏幕空间的大小有关。这是因为，需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张2D图像，计算实际上就是在这些图像空间中进的。
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/deferred-rendering-path.html#implementation-details

- 优点

    处理大量光源:
        延迟渲染非常适合具有大量光源的场景，因为所有光源的计算是在后期阶段统一进行的，与物体的数量无关。
    灵活的光照计算:
        光源不直接影响物体的渲染，可以更灵活地处理多个动态光源。
    适合现代硬件:
        在强大硬件上，延迟渲染能够提供更高的性能，尤其是在场景中有大量动态光源时。

- 缺点

    不适合透明物体:
        延迟渲染处理透明物体时非常困难，因为它依赖于 G-buffer 中的几何数据，透明物体的渲染需要特殊处理。
    内存消耗大:
        需要多个缓冲区来存储物体的几何信息，这会增加显存的消耗。
    对低端硬件性能要求较高:
        延迟渲染对硬件的要求较高，在低端设备上可能不太适用。

- 应用场景

    适合需要处理大量动态光源的场景，如大型开放世界游戏、具有多个光源的场景等。

- 设置

    TODO:

- 参考
https://docs.unity3d.com/Manual/RenderTech-DeferredShading.html

===== 前向渲染+(Forward+ Rendering)
概念:

    前向渲染+(也叫做 Forward+)是前向渲染和延迟渲染的结合，它在某些情况下可以获得两者的优点。
    前向渲染+ 通过将场景分割成多个区域(例如，基于摄像机视锥体的区域)，并为每个区域计算光源的影响，
    避免了每个物体都需要计算所有光源的情况。这使得它在处理多个光源时既高效又能提供较好的性能。

优点:

    减少计算量:
        它通过对光源进行分组，在计算时只考虑光源对视野中的物体的影响，避免了传统前向渲染的性能瓶颈。
    适应多光源场景:
        相比传统的前向渲染，前向渲染+ 可以更好地处理多光源场景，同时保留前向渲染的优势，如对透明物体的支持。

缺点:

    内存和复杂度:
        相较于传统的前向渲染，前向渲染+ 需要更多的内存和计算复杂度，
        因此在一些场景中可能不如传统前向渲染高效。

应用场景:

    适合在需要处理多个光源的同时，仍然保留前向渲染的灵活性和透明物体渲染的场景。

设置:

    TODO:

参考:
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html

===== 选择哪种渲染路径
总体来说，需要根据游戏发布的目标平台来选择渲染路径。如果当前显卡不支持所选的渲染路径，那么 Unity 会自动使用比其低一级的渲染路径。

==== SRP(Scriptable Render Pipeline)
SRP(可编程管线)
基于SRP，Unity开发了URP(通用渲染管线)与HDRP(高清渲染管线)。
https://docs.unity3d.com/Manual/scriptable-render-pipeline-introduction.html

- SRP Core

- 摄像机组件工具
Free Camera组件
Camera Switcher组件

- Look Dev

- Render Graph Viewer

- 对URP的展望

==== URP(Universal Render Pipeline)
===== 概览
Unity自2021版本不再维护内置渲染管线，而是使用URP完全代替它。
https://docs.unity3d.com/Manual/universal-render-pipeline.html
https://docs.unity3d.com/Manual/com.unity.render-pipelines.universal.html

===== 调试与修改

===== vs. 内置渲染管线
内置管线:
https://docs.unity3d.com/Manual/built-in-render-pipeline.html

===== 升级着色器

===== LightMode

===== Shader Graph
- 简介
https://www.zhihu.com/question/278425453

===== Renderer Pipeline Asset
- Rendering
- Qaulity
- Lighting
- Shadows
- Post-processing

- 参考
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/universalrp-asset.html

===== Renderer Pipeline Asset Data
Opaque Layer Mask 不透明的遮罩层
Transparent Layer Mask 半透明的遮罩层
Rendering Path: 前向渲染、前向渲染+、延迟渲染
Depth Priming Mode: 深度预处理模式
Depth Texture Mode: 深度图复制时机
Native Render Pass: 是否启动原生渲染，启动后可以在shader里进行混合编程，但OpenGL ES2不支持。
Transparent Receive Shadows: 是否在透明物体上绘制阴影。
Post Processing: 是否启用后处理，后处理配置文件也可以单独创建。
Stencil: 是否覆盖模板缓冲值
Intermediate Texture: 是否通过中间纹理进行渲染。

===== URP Global Settings
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-global-settings.html

===== Universal Renderer
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-universal-renderer.html

===== URP Renderer Feature
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-renderer-feature.html

==== HDRP(High Definition Render Pipeline)
https://docs.unity3d.com/Manual/high-definition-render-pipeline.html

==== SRP Batch
- 不透明物体绘制

- 半透明物体绘制

- Early-Z

- Alpha Test

- Alpha Blend

- Set Pass Call与Draw Call

- SRP Batch原理
可以减少Set Pass Call的数量，但无法减少Draw Call的数量

==== 渲染技术
===== Blinn-Phong光照计算
===== PBR光照计算
===== 阴影
===== 渲染数据传递
===== SRP流程
===== GPU渲染管线
===== 前向渲染流程
===== 多摄像机与Final Blit
===== ScriptableRenderPass

==== 自定义渲染管线
===== 参与渲染的对象
===== MVP矩阵计算
===== Render Objects
===== Rendering Layer Mask
===== 自定义 Render Feature
===== 裁剪与层
===== UI部分模糊
===== 降低分辨率不包含UI

==== Render Graph
Render Graph是一种用于管理和优化渲染流程的技术，广泛应用于实时渲染和游戏引擎中。它通过图形化的方式描述渲染任务的依赖关系，帮助开发者更高效地组织渲染管线。

1. 核心元素
节点(Node): 每个节点代表一个渲染任务，如绘制场景、应用后处理效果等。
边(Edge): 边表示任务间的依赖关系，确保任务按正确顺序执行。
资源(Resource): 渲染过程中使用的纹理、缓冲区等资源。

2. 主要优势
依赖管理: 自动处理任务间的依赖，避免手动管理。
资源优化: 自动复用和释放资源，减少内存占用。
模块化设计: 便于扩展和维护，适合复杂渲染管线。

3. 工作流程
定义节点和依赖: 明确每个渲染任务及其依赖关系。
构建图结构: 将节点和依赖关系转化为图。
执行渲染: 按图顺序执行任务，确保依赖关系得到满足。

4. 应用场景
游戏引擎: 如Unity、Unreal Engine等，用于管理复杂渲染管线。
实时渲染: VR、AR等需要高效渲染的场景。
后处理效果: 如Bloom、SSAO等，依赖关系复杂的效果。

5. 工具与库
FrameGraph: 用于Vulkan的Render Graph库。
RDG(Render Dependency Graph): Unreal Engine中的实现。
Unity SRP(Scriptable Render Pipeline): 支持Render Graph的模块化渲染管线。

参考:
https://zhuanlan.zhihu.com/p/24181086877

=== 相机
==== 概览
https://docs.unity3d.com/Manual/CamerasOverview.html

==== cinemachine
https://docs.unity3d.com/Packages/com.unity.cinemachine@3.1/manual/index.html

=== color
https://docs.unity3d.com/Manual/graphics-color.html

- color space
https://docs.unity3d.com/Manual/LinearLighting.html
gamma color space is the historically standard format, linear color space rendering gives more precise results.
Is there a reason to ever use gamma color space?
Only when you're targeting old hardware or old graphics APIs. OpenGL ES 2.0 and WebGL 1.0 don't support linear space, besides that gamma can be faster than linear on old mobile devices.
对于需要更真实光照效果的项目，建议使用Linear颜色空间；而对于更注重性能和兼容性的项目，Gamma颜色空间可能是一个更好的选择。

- high dynamic range
https://docs.unity3d.com/Manual/HDR.html

=== 光照
==== 概览
https://docs.unity3d.com/Manual/LightingOverview.html
https://docs.unity3d.com/Manual/LightingInUnity.html

==== Lighting configuration workflow
https://docs.unity3d.com/Manual/lighting-configuration-workflow.html

==== Light sources
https://docs.unity3d.com/Manual/lighting-light-sources.html

==== Direct and indirect lighting
https://docs.unity3d.com/Manual/direct-and-indirect-lighting.html

==== Shadows
https://docs.unity3d.com/Manual/Shadows.html

==== Reflections
https://docs.unity3d.com/Manual/reflections-landing.html

==== Lighting in URP
https://docs.unity3d.com/Manual/urp/lighting-landing.html

==== Lighting in the Built-In Render Pipeline
https://docs.unity3d.com/Manual/lighting-birp.html

==== Lighting reference
https://docs.unity3d.com/Manual/lighting-reference.html

=== 纹理
https://docs.unity3d.com/Manual/Textures-landing.html

=== 材质
https://docs.unity3d.com/Manual/Materials.html

=== shader
==== 分类
1 Shaders that are part of the graphics pipeline are the most common type of shader. They perform calculations that determine the color of pixels on the screen. In Unity, you usually work with this type of shader by using Shader objects.
2 Compute shaders perform calculations on the GPU, outside of the regular graphics pipeline.
3 Ray tracing shaders perform calculations related to ray tracing.

==== vs. 传统Shader
Unity Shader != 真正的Shader
在传统Shader里，只可以编写特定类型Shader，而在Unity Shader里，可以在同一个文件里同时包含需要的顶点着色器和片元着色器代码。
在传统Shader里，无法设置一些渲染设置，例如是否开启混合，深度测试等。在Unity Shader中，通过一行特定指令就可以完成这些设置。
在传统Shader里，需要编写冗长的代码来设置着色器的输入和输出，在Unity Shader中，只需要在特定语句块中声明一些属性，就可以依靠材质来方便地改变这些属性。

==== Unity Shader的形式
- 表面着色器(Surface Shader)
Unity自己创造的一种着色器代码类型。它需要的代码量很少，Unity在背后做了很多工作，但渲染的代价较大。
表面着色器在本质上就是顶点、片元着色器，它们看起来很不像是因为表面着色器是Unity在顶点/片元着色器上层为开发者提供 的一层抽象封装，但在背后，Unity还是会把它转化成包含一个多Pass的顶点/片元着色器。可以在UnityShader的导入设置面板中单击show generated cocde按钮来查看生成的真正的顶点／片元着色器代码。可以说，从本质上来讲，Unity Shader只有有两种形式: 顶点/片元着色器和固定函数着色器(在Unity 5.2以后的版本中，固定函数着色器 也会在背后被转化成顶点/片元着色器，因此从本质上来说Unity中只存在顶点/片元着色器)。

- 顶点/片元着色器(Vertex/Fragment Shader)

- 固定函数着色器(已废弃)
由于现在绝大多数GPU都支待可编程的渲染管线，这种固定管线的编程方式已经逐渐被抛弃。实际上，在Unity 5.2中，所有固定函数着色器都会在背后被Unity编译成对应的顶点/片元着色器，因此真正意义上的固定函数着色器已经不存在了。

==== 与 CG/HLSL 之间的关系
UnityShader是用ShaderLab语言编写的，但对于表面着色器和顶点/片元着色器，可以在ShaderLab内部嵌套CG/HLSL语言来编写这些着色器代码。这些CG/HLSL代码是嵌套在CGPROG RAM和ENDCG之间的。由于CG和DX9风格的HLSL从写法上来说儿乎是同一种语言，因此在Unity里CG和HLSL是等价的。

==== 数学基础
二维笛卡尔坐标系:

    在屏幕映射时，OpenGL y轴朝上，DirectX y轴朝下。

三维笛卡尔坐标系:

    unity使用左手坐标系。

坐标空间:

    模型空间，世界空间，观察空间，裁剪空间，屏幕空间。
    其中，仅观察空间中unity使用右手坐标系，其它均使用左手坐标系。
    除了这些最重要的坐标空间，实际开发中也会遇到其它空间:
        例如切线空间(tangent space, 通常用于法线映射):
            https://www.zhihu.com/question/23706933

内置变量:

    变换矩阵、摄像机和屏幕参数

==== 光照
===== 概念
- 光源
Directional Light(方向光)
Spot Light(聚光灯)
Point Light(点光源)
Area Light(面光源)

- 吸收和散射
高光反射(specular)表示物体表面是如何反射光线的
漫反射(diffuse)表示有多少光线会被折射、吸收和散射出表面

- 着色
着色(shading)指的是，根据材质属性(如漫反射屈性等)、光源信息(如光源方向、辐照度等)，使用一个等式去计算沿某个观察方向的出射度的过程。这个等式称为光照模型Lighting Model)。
不同的光照模型有不同的目的。例如，一些用于描述粗糙的物体表面，一些用于描述金属表面等。

- BRDF光照模型
BRDF(双向反射分布函数，Bidirectional Reflectance Distribution Function)是描述光线如何从表面反射的数学模型，广泛应用于计算机图形学中的光照计算。它定义了入射光与出射光之间的关系，帮助模拟真实世界中的光照效果。

===== 标准光照模型
====== 概念
虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。实际上，在BRDF理论被提出之前，标准光照模型就已经被广泛使用了。

在1975年，著名学者裴祥风(Bui Tuong Phong)提出了标准光照模型背后的基本理念。标准光照模型只关心直接光照(direct light)，也就是那些直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线。

虽然标准光照模型仅仅是一个经验模型，也就是说，它并不完全符合真实世界中的光照现象。但由于它的易用性、计算速度和得到的效果都比较好，因此仍然被广泛使用。

- vs. PBR
PBR 基于物理原理，能够提供更加真实和一致的光照和材质表现，适用于现代图形学中的高质量渲染。PBR 考虑了多个物理因素，如能量守恒、金属度、粗糙度、反射率等，确保了物体与环境的交互符合真实世界的物理定律。
标准光照模型: 通常更简单、计算量较小，适合早期图形学应用，但在材质和光照的模拟方面没有 PBR 真实和一致。

====== 环境光(ambient)
- 作用
模拟场景中间接光照的全局基础亮度，避免完全黑暗的区域。

- 关键点
与光源和视角无关，是恒定值。
常用于补足未被直接光源照亮的区域。

====== 自发光(emissive)
- 作用
使材质自身发光（如霓虹灯、屏幕），不受外部光源影响。

- 关键点
不参与光照计算，直接叠加到最终颜色。
在延迟渲染中可能需要特殊处理（如作为光源）

====== 漫反射(diffuse)
- 物理原理
光线均匀散射到所有方向，表现材质的"基础颜色"。

- 视觉表现
柔和均匀

- 计算复杂度
低（仅点积）

- 典型用途
布料、粗糙表面

- 计算公式(Lambert 模型)
ifdef::env-github[]
```math
I_{\text{diffuse}} = k_d \cdot I_{\text{light}} \cdot (\mathbf{L} \cdot \mathbf{N})
```
*参数说明*：
- $k_d$：材质的漫反射系数（颜色/贴图）。
- $I_{\text{light}}$：光源强度。
- $\mathbf{L}$：归一化的光线方向向量（从表面点到光源）。
- $\mathbf{N}$：归一化的表面法线向量。
- $(\mathbf{L} \cdot \mathbf{N})$：点积（clamped 到 `[0,1]`）。
endif::[]
ifndef::env-github[]
stem:[I_{\text{diffuse}} = k_d \cdot I_{\text{light}} \cdot (\mathbf{L} \cdot \mathbf{N})]
*参数说明*：
- latexmath:[k_d]：材质的漫反射系数（颜色/贴图）。
- latexmath:[I_{\text{light}}]：光源强度。
- latexmath:[\mathbf{L}]：归一化的光线方向向量（从表面点到光源）。
- latexmath:[\mathbf{N}]：归一化的表面法线向量。
- latexmath:[(\mathbf{L} \cdot \mathbf{N})]：点积（clamped 到 `[0,1]`）。
endif::[]

- 关键点
与观察方向无关，仅取决于光线与法线的夹角。
背面光照（点积 < 0）时通常忽略。

====== 高光反射(specular)
- 物理原理
光线在光滑表面上的镜面反射，形成亮斑(高光)。

- 视觉表现
明亮光斑

- 计算复杂度
高（需反射/半角向量）

- 典型用途
金属、光滑塑料

====== Phong模型
TODO:

====== Blinn-Phong模型
这种模型有很多局限性。首先，有很多重要的物理现象无法用 Blinn-Phong 模型表现出来，例如菲涅耳反射(Fresnel reflection)。其次，Blinn-Phong 模型是各项同性(isotropic)的，也就是说，当固定视角和光源方向旋转这个表面时，反射不会发生任何改变。但有些表面是具有各向异性(anisotropic)反射性质的，例如拉丝金屈、毛发等。

====== 逐像素还是逐顶点
光照模型使用的数学公式，那么在哪里计算这些光照模型呢？通常来讲，有两种选择：在片元着色器中计算，也被称为逐像素光照(per-pixel lighting)；在顶点着色器中计算，也被称为逐顶点光照(per-vertex lighting)。

在逐像素光照中，以每个像素为基础，得到它的法线（可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的），然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为Phong着色(Phong shading)，也被称为Phong插值或法线插值着色技术。这不同于之前讲到的Phong光照模型。

与之相对的是逐顶点光照，也被称为高洛德着色(Gouraud shading)。在逐顶点光照中，在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。由于顶点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小千逐像素光照。但是，由于逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有非线性的计算（例如计算高光反射时）时，逐顶点光照就会出问题。而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。

===== Unity中的环境光与自发光

===== 在Unity Shader中实现漫反射光照模型
====== 逐顶点
====== 逐像素
====== 半兰伯特模型

===== 在Unity Shader中实现高光反射光照模型
====== 逐顶点
====== 逐像素

===== 使用Unity内置的函数

===== Unity的渲染路径

===== Unity的光源类型
unity一种支持4种光源类型: 平行光、点光源、聚光灯和面光源(area light)。

- 平行光
平行光没有一个具体的位置，因此没有衰减的概念，即光照强度不会随着距离发生改变。
平行光可以放在场景中的任意位置。
平行光到场景中所有点的方向都是一样的。

- 点光源
点光源照亮的空间是有限的，它由空间的一个球体定义。
点光源是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。

- 聚光灯
照亮空间也是有限的，但不再是简单的球体，而是由空间中的一块锥形区域定义。
聚光灯可以用于表示由一个特定位置出发，向特定方向延伸的光。

===== Unity的光照衰减
- 用于光照衰减的纹理
- 使用数学公式计算衰减

===== Unity的阴影
====== 阴影是如何实现的
在实时渲染中，最常使用的是一种名为 Shadow Map 的技术。它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。Unity 使用的就是这种技术。

====== 不透明物体的阴影
====== 使用帧调试器查看阴影绘制过程
====== 统一管理光照衰减和阴影
====== 透明度物体的阴影

==== 纹理
===== 单张纹理
- 纹理属性

===== 凹凸映射(bump mapping)
====== 实现原理

    凹凸映射通常使用以下两种方式之一:
        高度图(Height Map):
            灰度图像表示表面高度变化
            亮色区域表示"凸起"，暗色区域表示"凹陷"
        法线图(Normal Map):
            RGB图像直接存储法线方向
            R、G、B通道分别对应法线的X、Y、Z分量

====== 高度纹理

====== 法线纹理
- 模型空间的法线纹理(object-space normal map)
• 实现简单，更加直观。甚至都不需要模型原始的法线和切线等信息，也就是说，计算更少。生成它也非常简单，而如果要生成切线空间下的法线纹理，由于模型的切线一般是和UV方向相同，因此想要得到效果比较好的法线映射就要求纹理映射也是连续的。
• 在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。

- 切线空间的法线纹理(tangent-space normal map)
• 自由度很高。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其它模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果。
• 可进行UV动画。比如，可以移动一个纹理的UV坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果。原因同上。这种UV动画在水或者火山熔岩这种类型的物体上会经常用到。
• 可以重用法线纹理。比如一个砖块，仅使用一张法线纹理就可以用到所有的6个面上。
• 可压缩。由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此我们可以仅存储XY方向，而推导得到Z方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值，不可压缩。
切线空间在很多情况下都优于模型空间，而且可以节省美术人员的工作。

====== 实践
====== Unity中的法线纹理类型

===== 渐变纹理(ramp texture)

===== 遮罩纹理(mask texture)
dota2:
https://help.steampowered.com/zh-cn/faqs/view/299C-D7F9-09A5-98B6

===== 立方体纹理

===== 渲染纹理

===== 程序纹理

==== 透明效果
===== 渲染顺序
===== Unity Shader的渲染顺序
===== 透明度测试(alpha test)
===== 透明度混合(alpha blending)
===== 开启深度写入的半透明效果
===== ShaderLab的混合命令
===== 双面渲染的透明效果

==== 动画
===== 纹理动画
===== 顶点动画

==== 屏幕后处理效果(screen post-processing effects)

==== shaders in URP
https://docs.unity3d.com/Manual/urp/shaders-in-universalrp.html
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/shaders-in-universalrp.html

==== 注意事项
- 避免不必要的计算
- 慎用分支和循环语句

==== 工具
===== Shader Graph
https://www.zhihu.com/question/475771378
注意: ShaderForge已废弃

==== 参考
https://docs.unity3d.com/Manual/Shaders.html
《Unity Shader入门精要》

=== virtual geometry(虚拟几何体)
https://docs.unity.cn/cn/tuanjiemanual/Manual/VirtualGeometry.html

Q: 局限性/限制？

=== 参考
https://docs.unity3d.com/Manual/Graphics.html
https://docs.unity3d.com/cn/current/Manual/Graphics.html

== physical
刚体
碰撞体

=== 参考
https://docs.unity3d.com/Manual/PhysicsSection.html

== 动画
=== 概念
- 模型动画与非模型动画

    模型动画:
        顶点动画与骨骼动画
    非模型动画:
        非模型动画指的是不依赖3D网格模型或骨骼系统的动画技术，主要包括以下几种类型:
        帧动画/2D精灵动画、粒子系统、程序化动画如水面波动、着色器动画、矢量动画等。

- Spine与Unity骨骼动画
Spine 和 Unity 的骨骼动画系统是两种不同的工具，分别用于 2D 和 3D 动画制作与集成。
Spine与Unity骨骼动画的区别:
[cols="1,1,1", options="header"]
|===
| 特性               | Spine                             | Unity 骨骼动画
| *主要用途*         | 专为 2D 骨骼动画设计                | 主要用于 3D 骨骼动画，也支持 2D 动画
| *动画类型*         | 2D 骨骼动画                        | 3D 骨骼动画为主，2D 骨骼动画为辅
| *工具链*           | 独立的 Spine 编辑器                | Unity 内置的 Animator 和动画工具
| *性能优化*         | 轻量级，适合移动端                  | 依赖项目复杂度，3D 动画可能较重
| *集成性*           | 需要导入 Spine 运行时库到 Unity     | 完全集成在 Unity 引擎中
| *学习曲线*         | 专注于 2D 动画，学习曲线较低         | 需要掌握 Unity 的动画系统和工具链
| *适用场景*         | 2D 游戏、移动端游戏                 | 3D 游戏、2D/3D 混合项目
|===

=== 动画文件
1. Animation（旧版动画系统）
适用场景：简单的动画播放，适合小型项目或非人形动画（如物体移动、旋转等）。
核心组件：Animation 组件 + .anim 动画片段。

2. Animator（新版动画系统，Mecanim）
适用场景：复杂动画逻辑（如角色状态机、混合动画、人形动画重定向）。
核心组件：Animator 组件 + Animator Controller（状态机） + Animation Clip。

使用新版动画，也不一定必须创建Animator Controller文件，通过Playable的方式也可以使用代码处理动画。

=== 制作动画
内部动画
外部动画(如FBX、GLTF等)

=== 动画事件

=== timeline
https://docs.unity3d.com/Manual/com.unity.timeline.html

🔹 timeline缺点
1. 性能开销
Playables API 底层开销：相比直接使用 Animator 或代码控制动画，Timeline 会带来额外性能负担，尤其在低端设备上。
不适合高频更新动画（如实时战斗动作）。
2. 动态控制较弱
运行时修改受限：虽然可以动态绑定对象，但时间轴结构（如轨道、Clip）不能在运行时动态修改。
条件分支困难：难以实现“根据玩家选择播放不同剧情”的逻辑，需配合代码（如 PlayableDirector.Pause() + 脚本跳转）。
3. 复杂动画混合的局限性
混合精度不足：复杂动画混合（如上半身攻击 + 下半身跑步）仍需依赖 Animator Layer 或代码。
不支持物理动画（如布娃娃效果）。
4. 学习成本与工作流问题
陡峭的学习曲线：需掌握 Playables API、Track 类型、Signal 系统 等概念。
版本兼容性：不同 Unity 版本的 Timeline 功能可能有差异（如 2019 后新增的 Track 类型）。
5. 调试困难
问题难以定位：如果动画未播放，可能原因包括绑定丢失、Clip 配置错误、权重问题等，需逐项排查。

🔹 Timeline vs. 替代方案
需求场景	Timeline	Animator	代码控制（Coroutine/DOTween）	Cinemachine
过场动画/剧情序列	✅ 最佳	❌ 不适用	⚠️ 需手动同步	✅ 配合使用
角色动画混合	✅	✅ 更灵活	❌ 复杂	❌ 不适用
高频实时动画（如战斗）	❌ 性能差	✅ 推荐	✅ 直接控制	❌ 不适用
动态条件分支	⚠️ 需配合代码	✅ 状态机	✅ 灵活	❌ 不适用

🔹 使用建议
适合 Timeline 的场景：
    电影式叙事、固定剧情动画。
    需要音画同步的过场（如对话 + 镜头切换）。
    快速原型设计（无需代码编排动画）。
避免 Timeline 的场景：
    需要高频更新的实时动画。
    复杂的状态机逻辑（用 Animator 更合适）。
    完全动态生成的动画（如程序化关卡）。

🔹 优化技巧
减少 活跃轨道数量 以降低性能开销。
使用 Signal Receiver 替代频繁的 Update 检测。
结合 Animator 处理复杂动画混合。

🔹 总结
Timeline 是 Unity 中强大的叙事和动画编排工具，特别适合线性内容，但在动态控制和性能敏感场景下需谨慎使用。合理搭配 Animator、DOTween 或代码控制，可以最大化其价值。

=== DOTween
补间动画(Tweening)
https://github.com/Demigiant/dotween

=== Slate
Slate 是一个流行的剧情动画（Cinematic）和序列化任务（Sequencing）插件，主要用于制作游戏中的过场动画、任务流程、对话系统等交互式内容。它提供可视化的时间轴（Timeline）编辑功能，类似于 Unity 官方的 Timeline 工具，但更轻量且专注于游戏逻辑的序列化控制。
https://slate.paradoxnotion.com/

=== 参考
https://docs.unity3d.com/Manual/AnimationSection.html

== 导航
https://docs.unity3d.com/Manual/com.unity.ai.navigation.html

== 持久化

== 资源管理
=== 编辑器模式
- 游戏资源

- 加载资源

- 卸载资源
Resources.UnloadAsset()
Resources.UnloadUnusedAssets()

- 创建与修改资源

- 创建与修改游戏对象

- reimport
Q: reimport本质上是干什么的？
Q: 什么时候需要reimport?

=== 运行模式
- 参与打包的资源

- Resources

- 通过脚本计算依赖

- StreamingAssets

- 场景资源
只需要将场景添加到Build Settings中就可以参与打包了。

=== AssetBundle
- 设置AB

- 设置依赖

- 纯脚本打包

- 差异打包

- AB压缩格式

- 加载AB

- 内存与卸载

- 场景AB

- CDN下载流程

- 加载流程

- 多进程AB构建

=== 代码编译
ScriptAssemblies/Assembly-CSharp.dll

- Plugins
Plugins目录下的代码会编译到Assembly-CSharp-firstpass.dll中，修改逻辑代码就不再同时编译这部分代码了。
Plugins目录下的代码是优先编译的，Assembly-CSharp.dll可以调用它们，但是它们不能反向调用Assembly-CSharp.dll。

- Assembly

- Editor
Assembly-CSharp-Editor.dll

- IL2CPP

- AB中的脚本

- 热更新代码

=== Shader编译
- 打包与运行

- Shader重复打包

- Shader宏

- Shader与AB包

- Shader打包剥离

=== 美术资源管理
- 版本管理
- 材质丢失
- 协作开发与多工程
- 美术资源生成

== 自动化与打包
=== 自动化设置资源
- 设置贴图格式
默认贴图格式是Automatic

- 动画控制器
应该禁止使用Animation Controller文件

- 设置模型格式

- 导出动画文件

- 生成角色Prefab

- 生成场景

- 场景dirty状态

- 自动生成UI图集

- 更换Shader残留宏

- 自动生成变种收集器

- 剔除顶点色

=== Build(构建)相关
https://docs.unity3d.com/Documentation/ScriptReference/BuildOptions.html

- android
https://docs.unity3d.com/Documentation/Manual/android-build-settings.html
Q: Script Debugging作用是?

=== 自动化打包
- 打包过程中的事件

- 打包机的选择
建议windows打包机构建windows和android包，macOS构建iOS和macOS包。

- 打包后自动压缩
- 调用shell脚本
- 命令行打开工程
- 脚本化打包参数
- Jenkins

=== 平台
==== andorid
https://docs.unity3d.com/Documentation/Manual/android-building-and-delivering.html
Q: APK vs. AAB(Android App Bundle)

== 热重载
hot reload
https://www.bilibili.com/video/BV14X4y1y7mB/?vd_source=8390cf4acc81f67e6df66ea39d1fc6fe

== 热更新
=== 概览
https://zhuanlan.zhihu.com/p/535748877

=== hybridclr
https://hybridclr.doc.code-philosophy.com/docs/intro
https://github.com/focus-creative-games/inspect_hybridclr
https://github.com/focus-creative-games/hybridclr

- 基于AOT(本地机器代码执行)+Interpreter(IL解释执行)使用同一个内存数据对象，没有跨域访问的问题。
xLua或ILRuntime热更方案都有一条原则，尽量减少与Unity C#层的交互，但是这种交互又避免不了而且量大，比如要在逻辑热更代码里面访问Unity C#的GameObject对象数据，最终在运行的时候，GameObject会在AOT模式下的原生内存数据结构对象。由于xLua或ILRuntime有自己的虚拟机，所以不能直接访问原生GameObject数据对象，往往要把访问里面的数据包装成函数，这样性能开销就大大的增加了。而hybrid是在IL2CPP模式下的解释执行，直接可以访问原生的数据对象。

- 逻辑代码更新后(1.0版本到2.0版本)，如果发布新版本2.0(重新安装新版本的app)，可以直接把更新的逻辑，直接使用AOT编译出来，不用解释执行，从而获得AOT的性能。
而基于xLua, ILRuntime的热更方案开发的代码(1.0版本到2.0版本)，用户即使重新安装2.0客户端后，还是解释执行，新版本的性能无法达到AOT的性能级别。

- 相比传统的Lua或ILRuntime热更，能更新任意部分的代码。
不用像Lua或ILRuntime一样，分热更代码+框架代码，框架代码有bug还不能热更。

=== MISC
https://zhuanlan.zhihu.com/p/676793950
https://mp.weixin.qq.com/s/5xfq-EveRWmBnHMfC-icRA

== 多语言

== framework
=== gf
https://github.com/EllanJiang/GameFramework
https://www.lfzxb.top/gameframework-all/

=== et
https://github.com/egametang/ET
https://github.com/egametang/ET/tree/master/Book
https://www.lfzxb.top/et-all/

=== ecs(entity component system)
https://en.wikipedia.org/wiki/Entity_component_system
https://developer.unity.cn/projects/677ca79dedbc2a001f135aec
https://developer.unity.cn/projects/677cd9d4edbc2a001eac2828
https://indienova.com/indie-game-development/gdc-overwatch-gameplay-architecture-and-netcode/
https://blog.codingnow.com/eo/ecs/

=== dots(data-oriented tech stack)
https://unity.com/dots

=== 参考
https://www.zhihu.com/question/268285328

== 库
=== 寻路
https://github.com/recastnavigation/recastnavigation

=== 行为树
https://github.com/meniku/NPBehave

== 工具
=== stack trace

==== Stack trace logging
https://docs.unity3d.com/Manual/StackTrace.html

缺点:

    only to debug.
    Limit the type of messages that display a stack trace.

==== StackTrace Class
https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stacktrace

缺点:

    It will not give stack traces for inlined method calls.
    If compiled in release mode, it will probably not have file and line numbers.
    there may be an odd platform it doesn’t support.

参考:
https://discussions.unity.com/t/how-to-get-a-reliable-stack-trace-in-release-build/

==== Release中的文件名、方法名、行号？
- 方法1: csharp StackTrace Class + Assembly带上PDB
https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly.load?view=net-9.0#system-reflection-assembly-load(system-byte()-system-byte())

- 方法2: Unity 2023.1 and later
https://docs.unity3d.com/Manual/il2cpp-managed-stack-traces.html

参考:
https://discussions.unity.com/t/il2cpp-missing-line-numbers-in-stack-trace/
https://discussions.unity.com/t/file-and-line-numbers-in-stack-trace/
https://stackoverflow.com/questions/72258670/c-sharp-get-the-calling-methods-line-number-class-file-and-method-name-etc
https://www.lfzxb.top/il2cpp-linenumber-recover/

=== unit test
https://docs.unity3d.com/Manual/testing-editortestsrunner.html

=== roslyn
https://docs.unity3d.com/Manual/roslyn-analyzers.html

=== Visual Studio
https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html

=== SRDebugger
https://www.stompyrobot.uk/tools/srdebugger/
https://www.stompyrobot.uk/tools/srdebugger/documentation/
SRDebugger除了日志，还提供选项、系统信息等功能

=== 日志
- SRDebugger

- android
android studio: https://developer.android.com/studio/debug/logcat?hl=zh-cn

== 扩展
=== package
==== vs. plugin
https://forum.unity.com/threads/unity-plugin-vs-unity-package.263003/

==== rider
https://docs.unity3d.com/Manual/com.unity.ide.rider.html
pausepoints:
https://blog.jetbrains.com/dotnet/2020/06/11/introducing-unity-pausepoints-for-rider/

=== 插件
https://docs.unity3d.com/Manual/Plugins.html

=== 编辑器扩展
https://docs.unity3d.com/Manual/ExtendingTheEditor.html
Unity 编辑器扩展允许开发者自定义 Unity 编辑器界面，创建专用工具来提升工作流程效率。

核心类:

    EditorWindow - 创建自定义窗口
    Editor - 自定义组件检视面板
    PropertyDrawer - 自定义属性绘制器
    MenuItem - 添加菜单项

关键特性:

    使用 UnityEditor 命名空间
    脚本必须放在 Editor 文件夹中
    在编辑器模式下运行

== 性能优化
=== 概要
https://docs.unity3d.com/Manual/UnderstandingPerformance.html
https://docs.unity3d.com/Manual/analysis.html

=== Profiler
https://docs.unity3d.com/Manual/Profiler.html
https://docs.unity3d.com/ScriptReference/Profiling.Profiler.html

android: https://docs.unity3d.com/Manual/android-profile-on-an-android-device.html
adb forward tcp:34999 localabstract:Unity-{insert bundle identifier here}

Q: Unity.Profiling vs. UnityEngine.Profiling?
https://discussions.unity.com/t/what-the-different-between-unity-profiling-and-unityengine-profiling/

=== UWA
https://www.uwa4d.com/
UWA GOT (Game Optimization Toolkit) 本地性能分析工具，支持 PC/Android/iOS
UWA Pipeline 云端自动化测试，多设备并行测试
UWA Localization 本地化性能分析，适用于海外版本优化
UWA Deep Memory 深度内存分析，检测泄漏和冗余资源

=== Frame Debugger
https://docs.unity3d.com/Manual/FrameDebugger.html
https://docs.unity3d.com/Manual/FrameDebugger-landing.html

=== perfdog
https://perfdog.qq.com/helpCenter

=== burst
- 概要
Burst 是一个高性能的 C# 编译器，专门用于优化计算密集型任务。
它将 C# 代码直接编译为高度优化的本地机器码(Native Code)，绕过传统的 .NET 运行时(如 Mono 或 IL2CPP)。
Burst 使用 LLVM 作为后端编译器，生成针对特定 CPU 架构优化的机器码，支持 SIMD(单指令多数据流)指令集，以加速并行计算。

- vs. IL2CPP

    Burst
        Burst 适用于需要大量计算的场景，如物理引擎、动画系统、粒子系统、AI 算法、音频处理等。
        它特别适合与 Unity 的 Job System 和 ECS 结合使用，以实现高性能的多线程并行计算。
        Burst 通常用于游戏的核心逻辑部分，以提升整体性能。
    IL2CPP
        IL2CPP 适用于所有 Unity 项目，特别是在需要 AOT 编译的平台上(如 iOS、WebGL 等)。
        IL2CPP 通常用于整个项目的编译，而不仅仅是特定的计算任务。

- 核心功能

    高性能编译
        将 C# 代码编译为高度优化的本地机器码
        避免了传统 C# 代码通过 .NET 运行时(如 Mono 或 IL2CPP)执行时的性能开销。
    SIMD 优化
        支持单指令多数据流(SIMD)指令集，并行处理多个数据点，从而大幅提升计算密集型任务的性能。
    与 Unity Job System 集成
        与 Unity 的 Job System 紧密集成，能够将多线程任务并行化，充分利用多核 CPU。
    跨平台支持
        支持多种平台(如 Windows、macOS、Linux、iOS、Android 等)，能够根据目标平台的硬件特性生成优化的机器码。

- 参考
https://docs.unity3d.com/Manual/com.unity.burst.html

=== API/库/框架
==== string
- Unity ZString
https://github.com/Cysharp/ZString
https://neuecc.medium.com/zstring-zero-allocation-stringbuilder-for-net-core-and-unity-f3163c88c887
栈上分配: struct避免堆分配
可扩展缓冲区: 初始使用栈空间，超量时切换至数组
Span操作: 直接操作内存，避免接口调用开销

- zstring
https://github.com/871041532/zstring

==== Cysharp
https://github.com/Cysharp

=== 参考
https://docs.unity3d.com/Manual/analysis.html
https://docs.unity3d.com/Manual/graphics-performance-profiling.html
https://www.bilibili.com/read/readlist/rl511863?spm_id_from=333.1369.opus.module_collection.click

== 团结引擎
https://docs.unity.cn/cn/tuanjiemanual/Manual/intro.html

- 注意事项
微信小游戏不能使用多线程:
https://developer.unity.cn/ask/question/672c2e45edbc2a4e04a81cee

== tutorial
https://catlikecoding.com/unity/tutorials/
https://www.youtube.com/playlist?list=PLPV2KyIb3jR4GH32npxmkXE-AHnlamcdG

== project
https://github.com/Unity-Technologies

== 源码
https://www.zhihu.com/question/270076640
https://github.com/Unity-Technologies/UnityCsReference

== 项目规范
https://www.zhihu.com/question/3854922557/answer/57599729291

== AI
https://unity.com/ai
Unity Muse
Unity Sentis

== 参考
《Unity3D游戏开发》第3版 宣雨松
https://docs.unity3d.com/Manual/index.html
https://unity.com/how-to#ebooks-for-programmers
https://developer.unity.cn/u/unityji-zhu-bo-ke?tab=article