= RocketMQ
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com
<<<

== 概览

=== MQ
- 作用: 解耦，削峰，异步
- 缺点: 给系统增加了复杂性

- 什么时候可以考虑使用MQ？

    数据驱动的任务依赖
    上游不关心下游执行结果
    异步返回执行时间较长

- 什么时候不太会使用MQ？

    上游比较关注执行结果，通常采用RPC

=== 设计理念
- 简单

    如NameServer没有使用业界常用的zookeeper:
    因为topic路由信息无须在集群间保持强一致，保持最终一致性

- 高效

    如引入文件组概念，组内单个大小文件固定，方便引入内存映射机制，存储基于顺序写

- 容忍设计缺陷

    消息重复问题由消费者实现幂等

=== Kafka and RabbitMQ
https://support.huaweicloud.com/intl/en-us/productdesc-hrm/hrm-pd-005.html
https://www.infoq.cn/article/s*RvY8D1jrNIsfOJylPE

=== 不足
目前开源版本的RocketMQ broker是没有主从自动切换的。如果Master挂了，那就写不进去了。然后slave只能提供只读的功能。当然如果topic在多个主节点上都创建了，虽然不会完全写不进去，但是对单分片顺序消费的场景，还是会产生影响。

Q: 会丢失消息吗?

=== 概念
https://github.com/apache/rocketmq/blob/develop/docs/cn/concept.md

=== 特性
https://github.com/apache/rocketmq/blob/develop/docs/cn/features.md

== NameServer

- 启动流程

- 路由注册/删除/发现

== 消息发送

- 发送方式: sync(同步), async(异步), oneway(单向)

- 生产者启动流程

- 消息发送基本流程

- 细节问题

消息批量发送
message id

消息发送-msg id

== 消息存储

- 发送方式: sync(同步), async(异步), oneway(单向)  

- 生产者启动流程

- 消息发送基本流程

- 细节问题

负载机制
异常机制
消息批量发送
message id

== 消息消费

== 实战

=== 消息重试

=== 消息重复与幂等性

=== 集群

=== 顺序消息

=== 定时消息

=== 事务消息

== 参考
https://github.com/apache/rocketmq/tree/develop/docs/cn
https://github.com/apache/rocketmq/