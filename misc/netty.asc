= 了解netty
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:toclevels: 5
:homepage: http://orientye.com
<<<

== 概览

=== 特点
参考: https://netty.io/index.html

netty5.0已经废弃:
主要原因: The major change of using a ForkJoinPool increases complexity and has not
demonstrated a clear performance benefit. Also keeping all the branches in sync is quite some work without a real need for it as there is nothin in current master which I think justifies a new major release.
参考: https://github.com/netty/netty/issues/4466

=== java nio
https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html

- Buffer
- Channel
- Selector

nio2:
https://stackoverflow.com/questions/25537675/java-what-exactly-is-the-difference-between-nio-and-nio-2

== 线程模型
=== reactor单线程
- 所有IO操作在同一个NIO线程上完成

[source, java]
----
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
ServerBootstrap b = new ServerBootstrap();
b.group(bossGroup)
 .channel(NioServerSocketChannel.class)
 ...
----

=== reactor多线程
- 一个acceptor线程用于监听服务端，接受客户端的TCP连接请求
- 一个NIO线程池, 这些NIO线程负责消息的读取, 编解码，发送
- 一个连接只对应一个NIO线程

[source, java]
----
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
ServerBootstrap b = new ServerBootstrap();
b.group(bossGroup)
 .channel(NioServerSocketChannel.class)
 ...
----

=== 主从reactor多线程
- 主reactor线程池: acceptor线程池
- 从reactor线程池(sub reactor线程池)
- acceptor线程池仅用于客户端的登录，握手和安全认证，一旦连接建立成功，便将链路注册到subreactor线程池的IO线程上，由IO线程负责后续的IO操作

[source, java]
----
EventLoopGroup bossGroup = new NioEventLoopGroup(4);
EventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap b = new ServerBootstrap();
b.group(bossGroup, workerGroup)
 .channel(NioServerSocketChannel.class)
 ...
----

=== Netty线程开发最佳实践
- 时间可控的简单业务直接在 IO 线程上处理
    如果业务非常简单，执行时间非常短，不需要与外部交互、访问数据库和磁盘，不需要等待其它资源，则建议直接在业务ChannelHandler中执行，不需要再启业务的线程或者线程池。避免线程上下文切换，也不存在线程并发问题。

- 复杂和时间不可控业务建议投递到后端业务线程池统一处理
    对于此类业务，不建议直接在业务ChannelHandler中启动线程或者线程池处理，建议将不同的业务统一封装成 Task，统一投递到后端的业务线程池中进行处理。
    过多的业务ChannelHandler会带来开发效率和可维护性问题，不要把Netty当作业务容器，对于大多数复杂的业务产品，仍然需要集成或者开发自己的业务容器，做好和Netty 的架构分层。

- 业务线程避免直接操作ChannelHandler
    对于ChannelHandler，IO线程和业务线程都可能会操作，因为业务通常是多线程模型，这样就会存在多线程操作ChannelHandler。为了尽量避免多线程并发问题，建议按照 Netty自身的做法，通过将操作封装成独立的Task由NioEventLoop统一执行，而不是业务线程直接操作。

参考: https://www.infoq.cn/article/netty-threading-model

== EventLoop和EventLoopGroup
- EventLoop与EventLoopGroup:
    NioEventLoopGroup实际上是个线程池
    一个EventLoopGroup包含一个或者多个EventLoop

- EventLoop与Thread:
    一个EventLoop在它的生命周期内只有一个Thread绑定
    EnventLoop处理的I/O事件都将在它专有的Thread上进行

- EventLoop与Channel:
    一个Channel在它的生命周期内只注册于一个EventLoop
    每个EventLoop负责处理一个或多个Channel

== Bytebuf

== Channel

== Unsafe

== ChannelPipeline

== ChannelHandler

== 优化
https://www.infoq.cn/article/netty-million-level-push-service-design-points
