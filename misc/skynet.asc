= 了解skynet
:hardbreaks-option:
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com
<<<

== 设计思想
设计综述: https://blog.codingnow.com/2012/09/the_design_of_skynet.html
框架: https://github.com/cloudwu/skynet/wiki/GettingStarted#%E6%A1%86%E6%9E%B6-framework
网络: https://github.com/cloudwu/skynet/wiki/GettingStarted#%E7%BD%91%E7%BB%9C
服务: https://github.com/cloudwu/skynet/wiki/GettingStarted#%E6%9C%8D%E5%8A%A1-service
消息: https://github.com/cloudwu/skynet/wiki/GettingStarted#%E6%B6%88%E6%81%AF-message
外部服务: https://github.com/cloudwu/skynet/wiki/GettingStarted#%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1--external-service
集群: https://github.com/cloudwu/skynet/wiki/GettingStarted#%E9%9B%86%E7%BE%A4-cluster

- 我们编写好的c文件，在编译成so库以后，在某个时机，调用该so库api的句柄，会被加载到一个modules列表中，一般这样的模块会被要求定义4种接口create，init，signal和release。 我们要创建一个新的，运行该业务逻辑的上下文环境时，则从modules列表中，找到对应的so库句柄，并且调用create接口，创建一个该类业务模块的数据实例，并且创建一个上下文环境（context），引用该类业务的接口和数据实例，该context会被存放在一个统一存放context的列表中，这种context被称之为服务。

- 一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。

- skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，从全局消息队列中pop出一个次级消息队列时，其他线程是拿不到同一个服务，并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的。

- socket线程、timer线程甚至是worker线程，都有可能会往指定服务的次级消息队列中push消息，push函数内有加一个自旋锁，避免同时多条线程同时向一个次级消息队列push消息的惨局。

- 从上面讨论可以得出如下结论，我们所写的不同的业务逻辑，可以运行在不同的独立的沙盒环境中，他们之间是通过消息队列来进行交互的。worker、timer和socket线程里运行的模块，都有机会向特定的服务push消息，他们是消息的生产者，而worker线程内的模块，同时也是消息的消费者（确切的说，应该是那些服务）
注意：服务模块要将数据，通过socket发送给客户端时，并不是将数据写入消息队列，而是通过管道从worker线程，发送给socket线程，并交由socket转发。此外，设置定时器也不走消息队列，而是直接将在定时器模块，加入一个timer_node。其实这样也很好理解，因为timer和socket线程内运行的模块并不是这里的context，因此消息队列他们无法消费。

- 此外，上面的论述，只涉及到c服务模块，并未讨论lua服务的内容，我们所有的lua服务，均是依附于一个叫snlua的c模块来运行的，lua服务每次收到一个消息，就会产生一个协程（事实上，skynet每个服务均有一个协程池，lua服务收到消息时，会优先去池子里取一个协程出来，这里为了理解方便，就视为收到一个消息，就创建一个协程吧），并通过协程执行注册函数，这些内容会在后面进行讨论。

参考: https://note.youdao.com/ynoteshare1/index.html?id=9d2b8a03fdd9cd4947ca4128d30af420&type=note#/

== 源码结构
- 3rd目录  https://github.com/cloudwu/skynet/tree/master/3rd
lua语言支持; jemalloc等

- skynet-src目录  https://github.com/cloudwu/skynet/tree/master/skynet-src
包含skynet最核心机制的模块，包括逻辑入口、加载C服务代码的skynet_module模块、运行和管理服务实例的skynet_context模块、skynet消息队列、定时器和socket模块等

- service-src目录  https://github.com/cloudwu/skynet/tree/master/service-src
依附于skynet核心模块的c服务，如用于日志输出的logger服务，用于运行lua脚本snlua的c服务等

- lualib-src目录   https://github.com/cloudwu/skynet/tree/master/lualib-src
提供C层级的api调用，如调用socket模块的api，调用skynet消息发送，注册回调函数的api，甚至是对C服务的调用等，并导出lua接口，供lua层使用

- lualib目录  https://github.com/cloudwu/skynet/tree/master/lualib
包含调用lua服务的辅助函数，方便应用层调用skynet的一些基本服务；包含对一些c模块或lua模块调用的辅助函数

- service目录  https://github.com/cloudwu/skynet/tree/master/service
lua层服务，依附于snlua这个c服务，这个目录包含skynet lua层级的一些基本服务，比如启动lua层级服务的bootstrap服务，gate服务，供lua层创建新服务的launcher服务等

- 目录层次:

----
    ┌─────────────┐           ┌─────────────┐
    │  service    │           │   lualib    │
    └─────────────┘           └─────────────┘
    ┌─────────────┐           ┌─────────────┐
    │service-src  │           │  lualib-src │
    └─────────────┘           └─────────────┘
                ┌─────────────┐        
                │  skynet-src │ 
                └─────────────┘
                ┌─────────────┐        
                │     3rd     │          
                └─────────────┘
----

== 核心元素
=== 服务
https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_server.h
https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_server.c
[source,c]
----
struct skynet_context {
        void * instance;
        struct skynet_module * mod;
        void * cb_ud;
        skynet_cb cb;
        struct message_queue *queue;//专属次级消息队列
        FILE * logfile;
        uint64_t cpu_cost;      // in microsec
        uint64_t cpu_start;     // in microsec
        char result[32];
        uint32_t handle;
        int session_id;
        int ref;
        int message_count;
        bool init;
        bool endless;
        bool profile;

        CHECKCALLING_DECL
};
----

=== 模块
https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_module.h
https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_module.c
[source,c]
----
struct skynet_module {
        const char * name;
        void * module; //so库的dl句柄
        skynet_dl_create create;
        skynet_dl_init init;
        skynet_dl_release release;
        skynet_dl_signal signal;
};
----

=== 消息
https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_mq.h
https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_mq.c

[source,c]
----
struct message_queue {
	struct spinlock lock;
	uint32_t handle;
	int cap;
	int head;
	int tail;
	int release;
	int in_global;
	int overload;
	int overload_threshold;
	struct skynet_message *queue;
	struct message_queue *next;
};

struct global_queue {
	struct message_queue *head;
	struct message_queue *tail;
	struct spinlock lock;
};
----

Q: 为什么是两级消息队列 有哪些不足

skynet 的消息调度: https://blog.codingnow.com/2012/09/the_design_of_skynet.html

- 生产
向一个服务发送消息的本质，就是向该服务的次级消息队列里push消息，多个worker线程可能会同时向同一个服务的次级消息队列push一个消息，次级消息队列push和pop操作，都有加一个spinlock，从而保证了线程安全。

- 消费
整个worker线程的消费流程是：
a) worker线程每次，从global_mq中弹出一个次级消息队列，如果次级消息队列为空，则该worker线程投入睡眠，timer线程每隔2.5毫秒会唤醒一条睡眠中的worker线程，并重新尝试从全局消息队列中pop一个次级消息队列出来，当次级消息队列不为空时，进入下一步
b) 根据次级消息的handle，找出其所属的服务（一个skynet_context实例）指针，从次级消息队列中，pop出n条消息（受weight值影响），并且将其作为参数，传给skynet_context的cb函数，并调用它
c) 当完成callback函数调用时，就从global_mq中再pop一个次级消息队列中，供下一次使用，并将本次使用的次级消息队列push回global_mq的尾部
d) 返回第a步

=== lua层消息处理
https://github.com/cloudwu/skynet/blob/master/lualib/skynet.lua

 消息-lua层消息处理

lualib/skynet.lua

raw_dispatch_message()
    skynet.PTYPE_RESPONSE ！=1  其他服务发过来的消息

-- skynet.lua
local function raw_dispatch_message(prototype, msg, sz, session, source, ...)
    -- skynet.PTYPE_RESPONSE = 1, read skynet.h
    if prototype == 1 then
        ... -- 暂不讨论，直接忽略
    else
        local p = proto[prototype]    -- 找到与消息类型对应的解析协议
        if p == nil then

... --error 处理

            return
        end
        local f = p.dispatch  -- 获取消息处理函数，可以视为该类协议的消息回调函数
        if f then
            local ref = watching_service[source]
            if ref then
                watching_service[source] = ref + 1
            else
                watching_service[source] = 1
            end
            local co = co_create(f)   -- 如果协程池内有空闲的协程，则直接返回，否则创建一个
新的协程，该协程用于执行该类协议的消息处理函数dispatch
            session_coroutine_id[co] = session
            session_coroutine_address[co] = source
            suspend(co, coroutine.resume(co, session,source, p.unpack(msg,sz, ...)))  -- 
启动并执行协程，将结果返回给suspend
        else
            unknown_request(session, source, msg, sz, proto[prototype].name)
        end
    end
end

 消息-lua层消息处理

lualib/skynet.lua

【1】 发起一个同步rpc调用，向目标服务的次级消息队列插入一个消息
【2】挂起当前协程，yield_call里的coroutine_yield(“CALL”, session)使得当前协程挂起，并在此时suspend执行记录
session为key，协程地址为value，将其写入一个table session_id_coroutine中，此时协程等待对方返回消息
【3】当目标服务返回结果时，先根据session找到先前挂起的协程地址，然后通过resume函数唤醒他，此时call返回结果，一次
同步rpc调用就结束了。

【1】根据消息的类型，找到对应的先前注册好的消息解析协议
【2】获取一个协程（如果协程池中有空闲的协程，则直接获取，否则重新创建一个），并让该协程执行消息处理协议的回调函数
dispatch
【3】启动并执行协程，将协程执行的结果返回给suspend函数，返回结果，就是一个coroutine挂起的原因，这个suspend函数，
就是针对coroutine挂起的不同原因，做专门的处理

== 网络
https://github.com/cloudwu/skynet/blob/master/skynet-src/socket_server.c
[source,c]
----
struct socket {
        uintptr_t opaque;
        struct wb_list high;
        struct wb_list low;
        int64_t wb_size;
        struct socket_stat stat;
        volatile uint32_t sending;
        int fd;
        int id;
        uint8_t protocol;
        uint8_t type;
        uint16_t udpconnecting;
        int64_t warn_size;
        union {
                int size;
                uint8_t udp_address[UDP_ADDRESS_SIZE];
        } p;
        struct spinlock dw_lock;
        int dw_offset;
        const void * dw_buffer;
        size_t dw_size;
};

struct socket_server {
        volatile uint64_t time;
        int recvctrl_fd;
        int sendctrl_fd;
        int checkctrl;
        poll_fd event_fd;
        int alloc_id;
        int event_n;
        int event_index;
        struct socket_object_interface soi;
        struct event ev[MAX_EVENT];
        struct socket slot[MAX_SOCKET];
        char buffer[MAX_INFO];
        uint8_t udpbuffer[MAX_UDP_PACKAGE];
        fd_set rfds;
};
----

== 启动

- 由c main函数启动

- main() https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_main.c

[source,c]
----
    skynet_globalinit(); //线程局部存储，主要记录各个线程类型
    skynet_env_init(); //初始化全局lua_state, 保存一些全局的key, value

    luaL_initcodecache(); //https://github.com/cloudwu/skynet/wiki/CodeCache
    struct lua_State *L = luaL_newstate();
    luaL_openlibs(L);	// link lua lib

    //配置相关
    config.thread =  optint("thread",8);
    config.module_path = optstring("cpath","./cservice/?.so");
    config.harbor = optint("harbor", 1);
    config.bootstrap = optstring("bootstrap","snlua bootstrap");
    config.daemon = optstring("daemon", NULL);
    config.logger = optstring("logger", NULL);
    config.logservice = optstring("logservice", "logger");
    config.profile = optboolean("profile", 1);

    lua_close(L);

    skynet_start(&config);
    skynet_globalexit(); //清理工作
----

- skynet_start() https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_start.c

[source,c]
----
    skynet_harbor_init(config->harbor);
    skynet_handle_init(config->harbor);
    skynet_mq_init();
    skynet_module_init(config->module_path);
    skynet_timer_init();
    skynet_socket_init();
    skynet_profile_enable(config->profile);

    bootstrap(ctx, config->bootstrap);

    start(config->thread);

    // harbor_exit may call socket send, so it should exit before socket_free
    skynet_harbor_exit();
    skynet_socket_free();
----

- bootstrap() https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_start.c

[source,c]
----
    int sz = strlen(cmdline);//(cmdline 对应缺省配置：snlua bootstrap)
	char name[sz+1];
	char args[sz+1];
	int arg_pos;
	sscanf(cmdline, "%s", name);  
	arg_pos = strlen(name);
	if (arg_pos < sz) {
		while(cmdline[arg_pos] == ' ') {
			arg_pos++;
		}
		strncpy(args, cmdline + arg_pos, sz);
	} else {
		args[0] = '\0';
	}
	struct skynet_context *ctx = skynet_context_new(name, args);
	if (ctx == NULL) {
		skynet_error(NULL, "Bootstrap error : %s\n", cmdline);
		skynet_context_dispatchall(logger);
		exit(1);
	}
----

- snlua服务 https://github.com/cloudwu/skynet/blob/master/service-src/service_snlua.c

[source,c]
----
int snlua_init(struct snlua *l, struct skynet_context *ctx, const char * args) {
    int sz = strlen(args);
    char * tmp = skynet_malloc(sz);
    memcpy(tmp, args, sz);
    skynet_callback(ctx, l , launch_cb);
    const char * self = skynet_command(ctx, "REG", NULL);
    uint32_t handle_id = strtoul(self+1, NULL, 16);
    // it must be first message
    skynet_send(ctx, 0, handle_id, PTYPE_TAG_DONTCOPY,0, tmp, sz);
    return 0;
}
----

- bootstrap.lua https://github.com/cloudwu/skynet/blob/master/service/bootstrap.lua

    最后调用skynet.newservice启动在config.start字段指定的脚本服务，这个就是逻辑入口点。

- start() https://github.com/cloudwu/skynet/blob/master/skynet-src/skynet_start.c

[source,c]
----
    pthread_t pid[thread+3];

    create_thread(&pid[0], thread_monitor, m);
    create_thread(&pid[1], thread_timer, m);
    create_thread(&pid[2], thread_socket, m);

    for (i=0;i<thread;i++) {
        create_thread(&pid[i+3], thread_worker, &wp[i]);
    }

    for (i=0;i<thread+3;i++) {
        pthread_join(pid[i], NULL); 
    }
----

== 实例
https://github.com/cloudwu/skynet_sample

== 参考
https://github.com/cloudwu/skynet/wiki
https://note.youdao.com/ynoteshare1/index.html?id=9d2b8a03fdd9cd4947ca4128d30af420&type=note#/
