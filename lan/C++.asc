了解 C++

Ver 0.0.8

2021-02-04,  orient

blog:            http://orientye.com
微信公众号:   深入理解计算机系统

了解C++

●  history

●  变量 函数

●  机器级表示

●  object-oriented

●  template GP TMP

●  STL

●  11/14/17/20

●  并发

●  性能优化

●  工程实践

history

●  Unix & C（1970年左右）

c99, c11标准

●  C++（1980年左右）

●  94年STL， 98/ 03/ 11/ 14/ 17/ 20

●  why

变量

●  逻辑： 
        标识符
        类型  https://en.cppreference.com/w/cpp/types (basic types, RTTI, type traits) 
        值
        POD:  https://en.cppreference.com/w/cpp/named_req/PODType

●  物理
       内存

●  运算
       sizeof,  &

●  指针变量

●  数组

●  引用

●  复合类型

●  修饰符

函数

●  本质

●  参数， 返回值

●  调用规则
      https://en.wikipedia.org/wiki/X86_calling_conventions

●  构造函数与析构函数

●  copy constructor， copy assignment operator
    move constructor,  move assignment operator

●  修饰符

机器级表示

●  《CSAPP》  chapter3

object-oriented

●  C++对象模型

●  封装

●  继承(继承，多重继承，虚拟继承  参考《InsideThe C++Model Object 》3.4)

●  多态
CRTP：
https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
https://fuzhe1989.github.io/2018/04/21/crtp/

template&GP

●  
●  
●  
●  

TMP

●  
●  
●  
●  

STL

• Container

• Iterator

• Algorithm

• Adaptor

• Functor

• Allocator

STL-container

Container

• Sequence Container
  

vector    deque       list(以及forward_list)    array

• Associative Container
– map multimap set  multiset 
– unordered_map unordered_multimap
– unordered_set unordered_multiset

• data structure & impletation
• vector:    push_back/[]/emplace/emplace_back/at
• map:       find/[]/insert/at/emplace

STL-iterator

Iterator

• what and why

• 种类

• 失效问题

Input Iterator, Output Iterator, Forward Iterator(例如forward_list), Bidirectional 

Iterator, Random access Iterator

STL-algorithm

Algorithm

https://en.cppreference.com/w/cpp/algorithm
• ranges::   (c++20)

STL-adaptor

Adaptor

容器适应器：

栈(Stack) 
  

队列(Queue) 

stack<vector> s1; 
stack<list > s2;
stack<deque> s3; 

vector 不能用来实现 queue，  pop_front!
queue<list> q1; 
queue<deque> q2; 

优先级队列(Priority Queue)

迭代器适应器（如逆向迭代器(Reverse Iterator) ）

函数适应器（如ptr_func）

list 不能用来实现priority_queue， pop 中用到堆排序时是要求randomaccess iterator
priority_queue<vector, less> pq1; 
priority_queue<deque, greater> pq2; 

STL-functor

Functor  

class Person  
{  
public:  
    Person();  
  
    Person(string _firstname, string _lastname)   {  
        this->FirstName = _firstname;  
        this->LastName = _lastname;  
    }  
public:  
    string FirstName;  
    string LastName;  
};  
class PersonCriterion  
{  
public:  
    bool operator()(const Person& p1, const Person& p2)    {  
        return p1.LastName < p2.LastName ||(!(p2.LastName<p1.LastName) && p1.FirstName<p2.FirstName);  
    }  
};  
int main( int argc, char* argv[])  
{  
    set<Person, PersonCriterion> colls;  
    colls.insert(Person("Tom","James"));  
    colls.insert(Person("Mike","James"));  
    colls.insert(Person("Jane","Bush"));  
    colls.insert(Person("Bill","Gates"));  
  
    std::set<Person, PersonCriterion>::iterator iter;  
    for ( iter = colls.begin(); iter!=colls.end(); ++iter)  {         
        Person p = (Person)(*iter);       
        cout<< p.FirstName<<"  "<<p.LastName<<endl;  
    }         
    getchar();  
    return 1;  
}  

C++11

https://en.cppreference.com/w/cpp/11

重要特性:

●  auto, decltype

●  lambla

●  右值, move,  foward

●  std::function, std::bind

●  shared_ptr, weak_ptr,  unique_ptr

●  线程

●  utility: https://en.cppreference.com/w/cpp/utility

C++11-lambla

lambla == 匿名函数
lambla vs. closure
caputure

https://en.cppreference.com/w/cpp/language/lambda

https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/stubs/callback.h

C++11-shared_ptr/weak_ptr/unique_ptr

Q: 是否线程安全

std::enable_shared_from_this        shared_from_this/weak_from_this
  

C++14

https://en.cppreference.com/w/cpp/14

C++17

https://en.cppreference.com/w/cpp/17

C++20

https://en.cppreference.com/w/cpp/20

并发-线程

参考：《了解concurrency》- c++部分

并发-协程

参考：《了解coroutine》- c++部分

性能优化

工程实践

https://google.github.io/styleguide/cppguide.html

Effective C++ 3rd
More effective C++
Effective Modern C++

工程实践-exception

https://google.github.io/styleguide/cppguide.html#Exceptions 

We do not use C++ exceptions.

Pros:
● Exceptions allow higher levels of an application to decide how to handle "can't happen" failures in deeply nested functions, without the 
obscuring and error-prone bookkeeping of error codes.
● Exceptions are used by most other modern languages. Using them in C++ would make it more consistent with Python, Java, and the C++ that 
others are familiar with.
● Some third-party C++ libraries use exceptions, and turning them off internally makes it harder to integrate with those libraries.
● Exceptions are the only way for a constructor to fail. We can simulate this with a factory function or an Init() method, but these require heap 
allocation or a new "invalid" state, respectively.
● Exceptions are really handy in testing frameworks.

Cons:
● When you add a throw statement to an existing function, you must examine all of its transitive callers. Either they must make at least the basic 
exception safety guarantee, or they must never catch the exception and be happy with the program terminating as a result. For instance, if f() calls 
g() calls h(), and h throws an exception that f catches, g has to be careful or it may not clean up properly.
● More generally, exceptions make the control flow of programs difficult to evaluate by looking at code: functions may return in places you don't 
expect. This causes maintainability and debugging difficulties. You can minimize this cost via some rules on how and where exceptions can be 
used, but at the cost of more that a developer needs to know and understand.
● Exception safety requires both RAII and different coding practices. Lots of supporting machinery is needed to make writing correct exception-
safe code easy. Further, to avoid requiring readers to understand the entire call graph, exception-safe code must isolate logic that writes to 
persistent state into a "commit" phase. This will have both benefits and costs (perhaps where you're forced to obfuscate code to isolate the 
commit). Allowing exceptions would force us to always pay those costs even when they're not worth it.
● Turning on exceptions adds data to each binary produced, increasing compile time (probably slightly) and possibly increasing address space 
pressure.
● The availability of exceptions may encourage developers to throw them when they are not appropriate or recover from them when it's not safe 
to do so. For example, invalid user input should not cause exceptions to be thrown. We would need to make the style guide even longer to 
document these restrictions!

noexcept
https://google.github.io/styleguide/cppguide.html#noexcept

推荐资源

https://github.com/MattPD/cpplinks

