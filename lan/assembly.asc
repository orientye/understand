= 了解assembly
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 概念
=== 语法格式
Intel, AT&T, 各种汇编器可能有自己独特语法格式(例如NASM)

==== Intel vs. AT&T
[format="csv", options="header", separator=#]
|===
名称                       #    Intel                      # AT&T	                         # 说明
寄存器名	               # rax	                       # %rax	                         # AT&T在寄存器前加%
操作数顺序	               # 目标数在前mov rax, rdx	        # 目标数在后mov %rdx, %rax	        # 将rdx的值赋给rax
立即数                     # 原样mov rax, 6	               # 数字前加$mov $6, %rax	           #  将6赋给rax
十六进制立即数	            # 开头加0结尾加H，例如012H	      # 开头加0x，例如0x12	              # 十六进制数12
访问内存长度表示	        # 开头加BYTE/WORD/DWORD PTR	     # 结尾加b,w,l,q	                #   分别表示字节 字 双字 四字
|===

=== 指令集
▪ CISC: complex instruction set computer, 复杂指令系统, 例如X86
▪ RISC: reduced instruction set computer, 精简指令系统, 例如ARM

▪ X86
    https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
    Volume 2

▪ ARM
    https://developer.arm.com/documentation/ddi0602/latest
    https://developer.arm.com/documentation/

== x86_64汇编

注意: 以下一般针对linux平台, windows等平台可能会略有区别。

=== 寻址模式
.Image source: Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) 3.3
image::img/assembly/operand-forms.png[]

    Global Symbol     MOVQ x, %rax
    Immediate         MOVQ $56, %rax
    Register          MOVQ %rbx, %rax
    Indirect          MOVQ (%rsp), %rax
    Base-Relative     MOVQ -8(%rbp), %rax
    Complex           MOVQ -16(%rbx,%rcx,8), %rax

=== 寄存器

==== 通用寄存器
16个通用寄存器

    %rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp, %rsp, %r8-r15

调用者保存(caller-save)
    
    %rax, %rcx, %rdx, %rdi, %rsi, %rsp, %r8-r11
    Q: 为什么可变参数需要调用者保存呢？
    A: 因此调用者知道参数的个数, 类型, 被调方并"不清楚"，所以适合调用方来保存与清栈

被调用者保存(callee-save)

    %rbx, %rbp, %r12-r15

%rdi, %rsi, %rdx, %rcx, %r8, and %r9用于前6个参数

%rax用作函数返回值(<=64位整数, 如果更大, 例如结构体, 则使用堆栈) 
注意: %rax也表示浮点数的参数个数, 有的情况下放在%al里
参考: https://stackoverflow.com/questions/54165346/integer-describing-number-of-floating-point-arguments-in-xmm-registers-not-passe

%rsp指向栈顶

%rbp:
In 32-bit x86, the base pointer (formerly %ebp, now %rbp) was used to keep track of the base of the current stack frame, and a called function would save the base pointer of its caller prior to updating the base pointer to its own stack frame. With the advent of the 64-bit architecture, this has been mostly eliminated, save for a few special cases when the compiler cannot determine ahead of time how much stack space needs to be allocated for a particular function (see Dynamic stack allocation).
参考: https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

此外, 某些指令隐含着使用相关寄存器, 例如IMUL会使用参数乘以%rax的值

==== 其它寄存器

=== 函数调用

==== System V ABI Calling Convention
▪ 参数

    %rdi, %rsi, %rdx, %rcx, %r8, and %r9用于前6个参数(整数或指针)
    %xmm0-%xmm7用于float和double用于前8个浮点参数(整数或指针)
    其它则在栈上, 入栈顺序: 从右到左
    如果调用具有变长参数的函数(例如printf)，调用前将%rax设置成浮点数参数个数

▪ 返回值
    
    %rax

▪ 栈清理

    调用者清理

▪ 栈

    栈是一般从高地址到低地址向下生长的。%rsp是栈指针，指向栈顶元素，%rbp是栈基指针，指向栈底。

▪ 进栈

    push %rax
    等价于
    subq $8, %rsp
    movq %rax, (%rsp)

▪ 出栈

    pop %rax
    等价于
    movq (%rsp), %rax
    addq $8, %rsp

▪ 丢弃元素

    修改%rsp的值即可, 例如addq $8, %rsp

▪ 一个函数堆栈帧示例

.Image source: https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf#chapter.10
image::img/assembly/stack-frame-example.png[]

==== red zone
red zone是一段128字节的区域，从rsp向低地址延伸。
在red zone上存放数据是安全的，不会被系统调用或者中断所覆盖。
这里说的是在不改变rsp的前提下用相对于rsp的地址的直接内存写的情况。如果进行函数调用，那还是有可能覆盖掉red zone的。

red zone的存在是为了一种特殊的优化。如果一个函数在生命周期内不调用任何其它函数，那么就可以忽略掉其栈帧的创建(rbp的变化)。
局部变量和参数可以使用rsp的相对地址进行访问，而不是rbp。
此外：
局部变量的总大小不应超过 128 字节。
函数是叶子函数(不调用其它任何函数)。
函数不修改rsp寄存器；否则就不可能用相对rsp的地址去访问内存了。
通过向前挪动rsp，你依然可以获得可以分配数据的比128字节大的空闲空间。

==== linux kernel interface
1. User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.
2. A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.
3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments, no argument is passed directly on the stack.
5. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.
6. Only values of class INTEGER or class MEMORY are passed to the kernel.
系统调用: https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux

==== 参考
https://en.wikipedia.org/wiki/X86_calling_conventions
https://docs.microsoft.com/zh-cn/cpp/build/x64-calling-convention
https://wizardforcel.gitbooks.io/re-for-beginners/content/Part-VI/Chapter-64.html
https://stackoverflow.com/questions/4429398/why-does-windows64-use-a-different-calling-convention-from-all-other-oses-on-x86/

=== 指令
- move lea

    lea: load effective address

- push pop

    PUSHQ %rax等价于
        SUBQ $8, %rsp
        MOVQ %rax, (%rsp)
    POPQ %rax等价于
        MOVQ (%rsp), %rax
        ADDQ $8, %rsp

- call leave ret

    call Label         Push return address and jump to label
    call *Operand      Push return address and jump to specified location
    leave              Set %rsp to %rbp, then pop top of stack into %rbp
    ret                Pop return address from stack and jump there

- endbr64 endbr32

    https://stackoverflow.com/questions/56905811/what-does-the-endbr64-instruction-actually-do
    Control-flow Enforcement Technology (CET)技术:
    https://www.intel.com/content/www/us/en/developer/articles/technical/technical-look-control-flow-enforcement-technology.html

== C与汇编
=== C调用汇编
==== 内嵌汇编
==== 外嵌汇编
=== 汇编调用C
https://0xax.github.io/asm_7/

== 实战

=== 例1
[source, c]
----
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
----

[source, assembly]
----
multstore:
    pushq   %rbx            # %rbx入栈
    movq    %rdx, %rbx      # 第三个参数即dest赋值给%rbx
    call    mult2           # 调用mult2
    movq    %rax, (%rbx)    # 返回值赋值给%rbx指向的地址
    popq    %rbx            # %rbx出栈
    ret
----

== 参考
https://www3.nd.edu/~dthain/compilerbook/compilerbook.pdf#chapter.10
https://github.com/0xAX/asm
https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
《System V Application Binary Interface AMD64 Architecture Processor Supplement》
https://wiki.osdev.org/System_V_ABI
《Low  Level Programming C, Assembly and Program Execution on Intel 64 Architecture》
https://cch123.gitbooks.io/duplicate/content/
http://www.egr.unlv.edu/~ed/assembly64.pdf
