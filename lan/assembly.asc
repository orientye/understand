= 了解assembly
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 概念
=== 语法格式
Intel, AT&T, 各种汇编器可能有自己独特语法格式(例如NASM)

==== Intel vs. AT&T
[format="csv", options="header", separator=#]
|===
名称                       #    Intel                      # AT&T	                         # 说明
寄存器名	               # rax	                       # %rax	                         # AT&T在寄存器前加%
操作数顺序	               # 目标数在前mov rax, rdx	        # 目标数在后mov %rdx, %rax	        # 将rdx的值赋给rax
立即数                     # 原样mov rax, 6	               # 数字前加$mov $6, %rax	           #  将6赋给rax
十六进制立即数	            # 开头加0结尾加H，例如012H	      # 开头加0x，例如0x12	              # 十六进制数12
访问内存长度表示	        # 开头加BYTE/WORD/DWORD PTR	     # 结尾加b,w,l,q	                #   分别表示字节 字 双字 四字
|===

=== 指令集
x86-64, ARM

== x86_64汇编
https://github.com/0xAX/asm
https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
系统调用: https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux
https://www.cnblogs.com/lsgxeva/p/11176000.html

=== 寻址模式
.Image source: Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) 3.3
image::img/assembly/operand-forms.png[]

=== 寄存器

==== 通用寄存器
16个通用寄存器

    %rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp, %rsp, %r8-r15

调用者保存(caller-save)
    
    %rax, %rcx, %rdx, %rdi, %rsi, %rsp, %r8-r11
    Q: 为什么可变参数需要调用者保存呢？
    A: 因此调用者知道参数的个数, 类型, 被调方并"不清楚"，所以适合调用方来保存与清栈

被调用者保存(callee-save)

    %rbx, %rbp, %r12-r15

%rdi, %rsi, %rdx, %rcx, %r8, and %r9用于前6个参数, 超过个数或者超出64位大小的参数, 使用堆栈

%rax用作函数返回值(<=64位整数, 如果更大, 例如结构体, 则使用堆栈) 

%rsp指向栈顶

%rbp:
In 32-bit x86, the base pointer (formerly %ebp, now %rbp) was used to keep track of the base of the current stack frame, and a called function would save the base pointer of its caller prior to updating the base pointer to its own stack frame. With the advent of the 64-bit architecture, this has been mostly eliminated, save for a few special cases when the compiler cannot determine ahead of time how much stack space needs to be allocated for a particular function (see Dynamic stack allocation).
参考: https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

=== 函数调用
调用者保存
入栈顺序: 从右到左
linux/unix/macOS: %rdi, %rsi, %rdx, %rcx, %r8, and %r9用于前6个参数

https://xie.infoq.cn/article/4e927ec51b5a364f51e2ac944
https://wizardforcel.gitbooks.io/re-for-beginners/content/Part-VI/Chapter-64.html
https://stackoverflow.com/questions/4429398/why-does-windows64-use-a-different-calling-convention-from-all-other-oses-on-x86/
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

=== 指令
- endbr64/endbr32:
https://stackoverflow.com/questions/56905811/what-does-the-endbr64-instruction-actually-do
Control-flow Enforcement Technology (CET)技术:
https://www.intel.com/content/www/us/en/developer/articles/technical/technical-look-control-flow-enforcement-technology.html

== C/C++与汇编
=== 内嵌汇编
=== 外嵌汇编
=== 反汇编

== 参考
《Low  Level Programming C, Assembly and Program Execution on Intel 64 Architecture》
https://cch123.gitbooks.io/duplicate/content/
http://www.egr.unlv.edu/~ed/assembly64.pdf