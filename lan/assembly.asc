= 了解assembly
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 概念
=== 语法格式
Intel, AT&T, 各种汇编器可能有自己独特语法格式(例如NASM)

==== Intel vs. AT&T
[format="csv", options="header", separator=#]
|===
名称                       #    Intel                      # AT&T	                         # 说明
寄存器名	               # rax	                       # %rax	                         # AT&T在寄存器前加%
操作数顺序	               # 目标数在前mov rax, rdx	        # 目标数在后mov %rdx, %rax	        # 将rdx的值赋给rax
立即数                     # 原样mov rax, 6	               # 数字前加$mov $6, %rax	           #  将6赋给rax
十六进制立即数	            # 开头加0结尾加H，例如012H	      # 开头加0x，例如0x12	              # 十六进制数12
访问内存长度表示	        # 开头加BYTE/WORD/DWORD PTR	     # 结尾加b,w,l,q	                #   分别表示字节 字 双字 四字
|===

=== 指令集
x86-64, ARM

== x86_64汇编
https://github.com/0xAX/asm
https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
系统调用: https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux
https://www.cnblogs.com/lsgxeva/p/11176000.html

注意: 以下一般针对linux平台, windows等平台可能会略有区别。

=== 寻址模式
.Image source: Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) 3.3
image::img/assembly/operand-forms.png[]

=== 寄存器

==== 通用寄存器
16个通用寄存器

    %rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp, %rsp, %r8-r15

调用者保存(caller-save)
    
    %rax, %rcx, %rdx, %rdi, %rsi, %rsp, %r8-r11
    Q: 为什么可变参数需要调用者保存呢？
    A: 因此调用者知道参数的个数, 类型, 被调方并"不清楚"，所以适合调用方来保存与清栈

被调用者保存(callee-save)

    %rbx, %rbp, %r12-r15

%rdi, %rsi, %rdx, %rcx, %r8, and %r9用于前6个参数

%rax用作函数返回值(<=64位整数, 如果更大, 例如结构体, 则使用堆栈) 
注意: %rax也表示浮点数的参数个数, 有的情况下放在%al里
参考: https://stackoverflow.com/questions/54165346/integer-describing-number-of-floating-point-arguments-in-xmm-registers-not-passe

%rsp指向栈顶

%rbp:
In 32-bit x86, the base pointer (formerly %ebp, now %rbp) was used to keep track of the base of the current stack frame, and a called function would save the base pointer of its caller prior to updating the base pointer to its own stack frame. With the advent of the 64-bit architecture, this has been mostly eliminated, save for a few special cases when the compiler cannot determine ahead of time how much stack space needs to be allocated for a particular function (see Dynamic stack allocation).
参考: https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf

==== 其它寄存器

=== 函数调用

==== 常规函数调用
参数:
调用者保存
入栈顺序: 从右到左
linux/unix/macOS: %rdi, %rsi, %rdx, %rcx, %r8, and %r9用于前6个参数(整数或指针)
xmm0 to xmm7用于float和double, 其它则在栈上

栈:
栈是一般从高地址到低地址向下生长的。%rsp是栈指针，指向栈最底部(其实是平常所说的栈顶)元素。

进栈:
push %rax(8字节)等价于
subq $8, %rsp
movq %rax, (%rsp)

出栈:
pop %rax等价于:
movq (%rsp), %rax
addq $8, %rsp

丢弃元素:
要丢弃最后压入栈中的值，只需要修改%rsp的值即可, 例如addq $8, %rsp

==== linux kernel interface
1. User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.
2. A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.
3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments, no argument is passed directly on the stack.
5. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.
6. Only values of class INTEGER or class MEMORY are passed to the kernel.

https://en.wikipedia.org/wiki/X86_calling_conventions
https://xie.infoq.cn/article/4e927ec51b5a364f51e2ac944
https://wizardforcel.gitbooks.io/re-for-beginners/content/Part-VI/Chapter-64.html
https://stackoverflow.com/questions/4429398/why-does-windows64-use-a-different-calling-convention-from-all-other-oses-on-x86/
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

=== 指令
- endbr64/endbr32:
https://stackoverflow.com/questions/56905811/what-does-the-endbr64-instruction-actually-do
Control-flow Enforcement Technology (CET)技术:
https://www.intel.com/content/www/us/en/developer/articles/technical/technical-look-control-flow-enforcement-technology.html

== C/C++与汇编
=== 内嵌汇编
=== 外嵌汇编
=== 反汇编

== 参考
《System V Application Binary Interface AMD64 Architecture Processor Supplement》
https://wiki.osdev.org/System_V_ABI
《Low  Level Programming C, Assembly and Program Execution on Intel 64 Architecture》
https://cch123.gitbooks.io/duplicate/content/
http://www.egr.unlv.edu/~ed/assembly64.pdf
