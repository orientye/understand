= c#
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 概览
=== .NET实现

    .NET Framework
        原始 .NET。支持 Windows 和 Windows Server。
    Mono
        一个跨平台开放源码的 .NET Framework 实现。
    .NET (Core) -- 新式 .NET。
        .NET 的一个跨平台开放源代码实现，同时与 .NET Framework 保持极大的兼容。
    参考: https://learn.microsoft.com/en-us/dotnet/core/introduction#net-ecosystem

=== 版本
https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core

工程配置:
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version

=== 语言规范
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/readme

== 核心
=== 委托(delegate)
委托是持有一个或多个方法的对象。

两种方式调用委托:

    一种是像调用方法一样调用委托
    一种是使用委托的Invoke方法

多个方法与返回值:

    添加方法按顺序
    调用列表中最后一个方法返回的值即是委托调用的返回值

匿名方法与Lambda表达式:

    MyDel del = delegate(int x) { return x + 1; } ;     //匿名方法，不推荐
    MyDel del =         (int x) => { return x + 1; } ;  //Lambda，推荐

vs-event-Action-Func:
https://stackoverflow.com/questions/5600930/what-to-use-delegate-event-or-funct

Events:
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events/

Action:
https://learn.microsoft.com/en-us/dotnet/api/system.action

Func:
https://learn.microsoft.com/en-us/dotnet/api/system.func-2

使用指南:

    需要返回值吗？
        需要 -> 用 Func<..., [ReturnType]>
        不需要（void） -> 用 Action<...>
    需要实现一个事件吗？
        是 -> 用 event 关键字包装一个委托（通常用 EventHandler 或 EventHandler<TEventArgs>）。
        否（只是回调或传递方法） -> 直接使用 Action<> 或 Func<>。
    预定义的 Func/Action 参数不够用（超过16个）或需要非常明确的名称？
        是 -> 自定义 delegate（这种情况极其罕见）。
        否 -> 使用 Func<>/Action<>。

=== 特性(attribute)
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes/
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/global

=== 反射(reflection)
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes/

https://learn.microsoft.com/en-us/dotnet/api/system.activator
https://stackoverflow.com/questions/6582259/fast-creation-of-objects-instead-of-activator-createinstancetype

https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/

=== 泛型(generic)
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-constraint
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/where-generic-type-constraint

=== expression-trees
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/expression-trees/

=== Q&A
==== const-vs-readonly
const: compile-time
readonly: runtime
static readonly
https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly-in-c
https://stackoverflow.com/questions/5142349/declare-a-const-array
《Effective C# 3rd》Item2

==== out-vs-ref
都是按引用传递参数
[cols="1,2,2", options="header"]
|===
| 特性        | `ref` 关键字               | `out` 关键字
| *初始化要求* | 必须初始化变量             | 可不初始化变量
| *方法内要求* | 可不赋值                   | *必须* 赋值
| *数据流向*  | 双向（输入+输出）          | 单向输出
| *典型用例*  | 交换变量、大型结构体修改   | 解析方法、多返回值
|===
https://stackoverflow.com/questions/388464/whats-the-difference-between-the-ref-and-out-keywords

==== internal-vs-private
https://stackoverflow.com/questions/3813485/internal-vs-private-access-modifiers

==== struct-vs-class
https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct
https://stackoverflow.com/questions/13049/whats-the-difference-between-struct-and-class-in-net

==== string-vs-stringbuilder
https://stackoverflow.com/questions/3069416/difference-between-string-and-stringbuilder-in-c-sharp

==== int[][] -vs- int[,]

    int[][] 锯齿数组:
        每一个元素本身是一个数组，但数组的长度可以不相同
    int[,] 二维数组:
        真正的二维数组，具有固定行数和列数

    锯齿数组(array of arrays/jagged arrays):
        优点: 灵活，支持不规则数组
        缺点: 访问速度较慢，内存开销较大
    多维数组(multi-dimensional arrays):
        优点: 访问速度快，内存开销小，缓存友好
        缺点: 必须是规则的矩形数组

==== properties
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties

==== 可为空类型
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-reference-types
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator

==== casting-and-type-conversions
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/safely-cast-using-pattern-matching-is-and-as-operators
《Effective C# 3rd》Item3
https://www.reddit.com/r/csharp/comments/179834u/when_to_parse_cast_or_convert/

==== 扩展方法(Extension Method)
在静态函数的第一个参数前加上 this 关键字时，实际上是在定义一个扩展方法。
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method

==== 程序集
https://learn.microsoft.com/en-us/dotnet/standard/assembly/

==== partial-classes-and-methods
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods

==== 默认值
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values

==== 接口
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces
For more information about explicit implementation, see Explicit Interface Implementation and Interface Properties:
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/interface-properties

==== the-object-type
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types#the-object-type

System.Object vs. object:
https://stackoverflow.com/questions/3070628/difference-between-object-and-object

box-and-unbox:
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing

anonymous-types:
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types
vs-dictionary:
https://stackoverflow.com/questions/29413942/c-sharp-anonymous-object-with-properties-from-dictionary
特点:
1. 简洁，快速构建和传递一些简单的数据结构，而不必为每个小的数据集合都定义一个专门的类。
2. 自动属性推断
编译器会根据初始化表达式中的属性名称和值自动推断出匿名类型的结构。
3. 不可变（通常情况下）
匿名类型的对象在创建后通常是不可变的，这意味着不能修改其属性的值。一旦创建了一个匿名类型的对象，它的属性值就被固定下来。这种不可变性可以带来一些好处，例如可以确保数据的一致性和线程安全性。
局限:
不能在方法外部定义，并且不能作为方法参数传递，也不能作为返回类型

==== dynamic
https://stackoverflow.com/questions/3442821/dynamic-vs-object-type
https://learn.microsoft.com/en-us/dotnet/api/system.dynamic

ExpandoObject:
https://learn.microsoft.com/en-us/dotnet/api/system.dynamic.expandoobject
https://stackoverflow.com/questions/1653046/what-are-the-true-benefits-of-expandoobject
https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-dynamic-expandoobject
vs-dictionary:
https://stackoverflow.com/questions/3522591/expandoobject-vs-dictionary-from-a-performance-point-of-view

==== partial
https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods

==== using
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using
当对象实现了 IDisposable 接口且需要及时释放资源时（如文件、网络连接、图形句柄等）时，
using 是 try-finally 的语法糖，以下代码等价:
[source, csharp]
----
// using 写法
using (var resource = new Resource()) { /* ... */ }

// 等价于 try-finally
Resource resource = new Resource();
try { /* ... */ }
finally { resource.Dispose(); }
----

== concurrency

=== parallel-programming
==== 概览
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/

==== Task Parallel Library (TPL)
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl

===== Data Parallelism
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library

===== Task-based Asynchronous Programming
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming

===== Dataflow
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library

===== Potential Pitfalls in Data and Task Parallelism
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism

==== Parallel LINQ (PLINQ)
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq

==== Data Structures for Parallel Programming
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/data-structures-for-parallel-programming

==== Custom Partitioners for PLINQ and TPL
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl

==== Lambda Expressions in PLINQ and TPL
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl

=== threading
==== 概览
https://learn.microsoft.com/en-us/dotnet/standard/threading/

==== create
https://learn.microsoft.com/en-us/dotnet/standard/threading/creating-threads-and-passing-data-at-start-time

==== pausing and interrupting
https://learn.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads

==== scheduling
https://learn.microsoft.com/en-us/dotnet/standard/threading/scheduling-threads

==== cancel
https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads

==== destory
https://learn.microsoft.com/en-us/dotnet/standard/threading/destroying-threads

==== best practice
https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices

==== threading objects and features
https://learn.microsoft.com/en-us/dotnet/standard/threading/threading-objects-and-features

==== memory-model
https://learn.microsoft.com/en-us/archive/msdn-magazine/2012/december/csharp-the-csharp-memory-model-in-theory-and-practice#thread-communication-patterns

=== Task
==== 概要
The Task Parallel Library (TPL) is based on the concept of a task, which represents an asynchronous operation. In some ways, a task resembles a thread or ThreadPool work item but at a higher level of abstraction. The term task parallelism refers to one or more independent tasks running concurrently. Tasks provide two primary benefits:

- More efficient and more scalable use of system resources.
Behind the scenes, tasks are queued to the ThreadPool, which has been enhanced with algorithms that determine and adjust to the number of threads. These algorithms provide load balancing to maximize throughput. This process makes tasks relatively lightweight, and you can create many of them to enable fine-grained parallelism.

- More programmatic control than is possible with a thread or work item.
Tasks and the framework built around them provide a rich set of APIs that support waiting, cancellation, continuations, robust exception handling, detailed status, custom scheduling, and more.

Task 相较于之前的模型的一个根本进步是，允许在操作启动后提供延续工作（即回调）。

==== Promise Task 与 Delegate Task
虽然这些术语不是官方命名，但在社区和框架设计讨论中广泛使用，用于区分Task的两种根本不同的用途。

[cols="1,4,4", options="header"]
|===
|特性	|Promise Task (未来型任务)	|Delegate Task (工作型任务)
|本质	|一个占位符，代表一个尚未完成的未来结果或操作。	|一个工作单元，包装了一个需要被执行的委托（方法）。
|创建方式	|Task.FromResult, Task.FromException, Task.FromCanceled, async 方法，TaskCompletionSource	|new Task(...), Task.Factory.StartNew, Task.Run
|是否包含工作	|否。它本身不包含要执行的代码；它只表示一个状态（完成、失败、取消）。	|是。它包含一个具体的 Action 或 Func<T> 委托。
|如何完成	|通过外部的 TaskCompletionSource.SetResult、SetException、SetCanceled 方法手动完成。	|通过在线程池线程（或自定义调度器）上执行其内部的委托来自动完成。
|典型来源	|I/O密集型操作（如HTTP请求、文件读写、数据库查询）、手动控制的异步操作。	|CPU密集型操作、需要在线程池中并行执行的计算。
|状态起点	|通常创建时就是 WaitingForActivation。	|创建时可能是 Created（冷任务），启动后变为 WaitingToRun。
|===

==== 创建
===== async方法
[source, csharp]
----
public async Task<int> AddAsync(int i, int j)
{
    await Task.Delay(100);
    return i + j;
}
----
the compiler rewrites our code so that a Task<int> is created and returned. When the method completes, the task completes.
main()与async:
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/main-command-line#async-main-return-values

===== TaskCompletionSource<TResult>
立即创建一个未完成的任务，并允许在未来的某个时间点手动将其置为完成、失败或取消状态。
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#tasks-without-delegates
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcompletionsource

===== Task.FromResult<TResult>(TResult)
立即创建一个已完成且带有确定结果的任务。
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.fromresult

===== 显式创建
默认使用 Task.Run: 对于绝大多数需要后台执行的工作，这是最简单、最安全、最高效的选择
如果需要高级配置，再考虑使用 Task.Factory.StartNew
几乎永远不要使用 new Task(): 冷任务、极少数需要精细控制调度时机的场景
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#creating-and-running-tasks-explicitly

===== 隐式创建
Parallel.Invoke(() => DoSomeWork(), () => DoSomeOtherWork());
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#creating-and-running-tasks-implicitly

===== 创建选项
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#task-creation-options
[source, csharp]
----
internal enum InternalTaskOptions
{
    /// <summary> Specifies "No internal task options" </summary>
    None,

    /// <summary>Used to filter out internal vs. public task creation options.</summary>
    InternalOptionsMask = 0x0000FF00,

    ContinuationTask = 0x0200,
    PromiseTask = 0x0400,

    /// <summary>
    /// The state object should not be returned from the AsyncState property.
    /// </summary>
    HiddenState = 0x0800,

    /// <summary>
    /// Store the presence of TaskContinuationOptions.LazyCancellation, since it does not directly
    /// translate into any TaskCreationOptions.
    /// </summary>
    LazyCancellation = 0x1000,

    /// <summary>Specifies that the task will be queued by the runtime before handing it over to the user.
    /// This flag will be used to skip the cancellationtoken registration step, which is only meant for unstarted tasks.</summary>
    QueuedByRuntime = 0x2000,

    /// <summary>
    /// Denotes that Dispose should be a complete nop for a Task.  Used when constructing tasks that are meant to be cached/reused.
    /// </summary>
    DoNotDispose = 0x4000
}
----

===== 参考
https://blog.stephencleary.com/2012/02/creating-tasks.html

==== Id
- id
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.id
Note that although collisions are very rare, task identifiers are not guaranteed to be unique.

- currentid
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.currentid
https://blog.stephencleary.com/2013/03/taskcurrentid-in-async-methods.html
https://stackoverflow.com/questions/14399232/the-task-currentid-returns-null-why

- debug
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#task-id

- 参考
https://blog.stephencleary.com/2014/06/a-tour-of-task-part-4-id.html
https://blog.stephencleary.com/2013/03/a-few-words-on-taskid-and.html
https://stackoverflow.com/questions/14399232/the-task-currentid-returns-null-why

==== 完成
===== 概览
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#waiting-for-tasks-to-finish

https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-threading-tasks-task#wait-for-a-task-to-complete

===== Task.wait()
locks the calling thread until the single class instance has completed execution.
内部实现: Task.InternalWait函数()
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs

===== Task.Result
[source, csharp]
----
    internal TResult GetResultCore(bool waitCompletionNotification)
    {
      if (!this.IsCompleted)
        this.InternalWait(-1, new CancellationToken());
      if (waitCompletionNotification)
        this.NotifyDebuggerOfWaitCompletionIfNecessary();
      if (!this.IsRanToCompletion)
        this.ThrowIfExceptional(true);
      return this.m_result;
    }
----
可见，与Task.wait()一样，内部也会调用Task.InternalWait函数()，会阻塞当前线程。

===== Task.GetAwaiter().GetResult()
https://stackoverflow.com/questions/17284517/is-task-result-the-same-as-getawaiter-getresult
https://devblogs.microsoft.com/dotnet/task-exception-handling-in-net-4-5/

===== continuation
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks

A continuation is a delegate that you can attach to a task and tell the task “run this when you’re done.” When the task completes, it will then schedule its continuations. The task that a continuation attaches to is called the “antecedent” task.

Continuations are important because they don’t block any threads. Instead of (synchronously) waiting for a task to complete, a thread may just attach a continuation for the task to run whenever it does complete. This is the essence of asynchrony, and the async/await system uses continuations whenever it deals with tasks.
https://blog.stephencleary.com/2015/01/a-tour-of-task-part-7-continuations.html

注意:
prefer await over ContinueWith. ContinueWith is useful when doing dynamic task parallelism, but in every other scenario, await is preferred.

内部实现: Task.ContinueWithCore函数()
进而调用ContinueWithTaskContinuation.Run():
internal sealed class ContinueWithTaskContinuation : TaskContinuation
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskContinuation.cs

===== await
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await

==== status
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.status
https://blog.stephencleary.com/2014/06/a-tour-of-task-part-3-status.html
It is natural to speak of I/O-based operations as “running” or “executing”, e.g., “the HTTP download is currently running”. However, there is no actual CPU code to be run, so Promise Tasks (such as an HTTP download task) will never enter the WaitingToRun or Running states. And yes, this means that a Promise Task may end in the RanToCompletion state without ever actually running. Well, it is what it is…
All Promise Tasks are created “hot”, meaning that the operation is in progress. The confusing part is that this “in-progress” state is actually called WaitingForActivation.

==== API
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task

- Task.AsyncState Property
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.asyncstate

- 组合
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#composing-tasks

- 链式调用
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#creating-task-continuations

- 取消
https://blog.stephencleary.com/2022/02/cancellation-1-overview.html
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/cancel-an-async-task-or-a-list-of-tasks
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/cancel-async-tasks-after-a-period-of-time

- exception
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library

- childTask
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#creating-detached-child-tasks
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#creating-child-tasks

- Yield()
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.yield
实现: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/YieldAwaitable.cs

- Task.RunSynchronously()
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.runsynchronously
Task.RunSynchronously() 是 Task 或 Task<TResult> 实例的一个方法。它强制一个已经被创建但尚未运行的"冷任务"（Cold Task）立即在当前线程上同步执行，而不是由线程池调度器去安排一个线程来异步执行它。
RunSynchronously 是一个相当高级和特殊的方法，在绝大多数日常开发中不会用到它。它的主要应用场景是在框架或库的内部，用于实现更精细的任务执行控制。
https://blog.stephencleary.com/2015/02/a-tour-of-task-part-8-starting.html

- ValueTask / ValueTask<T>
在 async/await 模式中，通常返回 Task 或 Task<T>。然而，每次调用一个返回 Task 的 async 方法时，即使操作是同步完成的（或者结果已经被缓存），运行时也会在堆上分配一个 Task 对象。对于性能极其敏感的场景，尤其是那些可能被每秒调用数百万次的方法，这些微小的、频繁的内存分配会带来显著的 GC 压力，从而影响整体性能。
ValueTask 和 ValueTask<T> 就是为了解决这个问题而诞生的。它们是一种可等待（awaitable） 的结构（struct），而不是引用类型（class）。
注意: 除非必要，尽量不要使用。
https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/

==== TaskScheduler
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler

https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-threading-tasks-taskscheduler

https://devblogs.microsoft.com/dotnet/configureawait-faq/#what-is-a-taskscheduler

==== ThreadPool
===== 概要
public static class ThreadPool:
https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool

QueueUserWorkItem(): 安全但开销大
UnsafeQueueUserWorkItem() - 高性能但需谨慎

实现:
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadPoolWorkQueue.cs

===== QueueUserWorkItem()
- 执行过程
捕获 (Capture): 在将工作项加入队列的瞬间，捕获当前线程的执行上下文。
存储 (Store): 将该上下文与工作项一起存储在线程池队列中。
还原 (Restore): 当线程池中的某个线程开始执行这个工作项时，它会首先还原之前捕获的执行上下文，然后再执行回调方法。

- 优点
确保了工作项在执行时，其环境与将它加入队列时的原始线程环境一致。例如，在一个 ASP.NET 请求中排队的工作项仍然可以访问 HttpContext.Current。

- 缺点
捕获和还原上下文需要成本。它涉及序列化、反序列化等操作，如果频繁调度大量的小型工作项，这个开销会变得显著。

===== UnsafeQueueUserWorkItem()
- 执行过程
不捕获 (No Capture)：将工作项加入队列时，不捕获当前执行上下文。
执行 (Execute)：当线程池线程执行该工作项时，它运行在当前线程现有的上下文中，而不是原始调用线程的上下文。

- 优点
性能更高。完全避免了上下文流动带来的开销，是调度工作项最快的方法。

- 缺点
不安全。如果回调代码依赖于执行上下文（例如，在 ASP.NET Core 之前的时代，代码试图读取 HttpContext.Current，会得到 null），它将会失败或产生不可预知的行为。这就是它被命名为 Unsafe 的原因 - 它不是指内存安全，而是指上下文安全。

- 实现
[source, csharp]
.https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/ThreadPoolWorkQueue.cs
----
public static bool QueueUserWorkItem(WaitCallback callBack) =>
            QueueUserWorkItem(callBack, null);

public static bool QueueUserWorkItem(WaitCallback callBack, object? state)
{
    if (callBack == null)
    {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.callBack);
    }

    ExecutionContext? context = ExecutionContext.Capture();

    object tpcallBack = (context == null || context.IsDefault) ?
        new QueueUserWorkItemCallbackDefaultContext(callBack!, state) :
        (object)new QueueUserWorkItemCallback(callBack!, state, context);

    s_workQueue.Enqueue(tpcallBack, forceGlobal: true);

    return true;
}

public static bool QueueUserWorkItem<TState>(Action<TState> callBack, TState state, bool preferLocal)
{
    if (callBack == null)
    {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.callBack);
    }

    ExecutionContext? context = ExecutionContext.Capture();

    object tpcallBack = (context == null || context.IsDefault) ?
        new QueueUserWorkItemCallbackDefaultContext<TState>(callBack!, state) :
        (object)new QueueUserWorkItemCallback<TState>(callBack!, state, context);

    s_workQueue.Enqueue(tpcallBack, forceGlobal: !preferLocal);

    return true;
}
----

==== SynchronizationContext(同步上下文)
===== 概念
异步函数能够回到正确的线程中，是因为使用了SynchronizationContext类。
该类早在.NET 2.0中就已存在，供BackgroundWorker等其它组件使用。
SynchronizationContext涵盖了在适当的线程上执行委托这一理念。
不同的执行环境使用不同的上下文。例如，某个上下文可能会从线程池中取出一个线程并执行给定的行为。

One aspect of SynchronizationContext is that it provides a way to queue a unit of work to a context. Note that this unit of work is queued to a context rather than a specific thread. This distinction is important, because many implementations of SynchronizationContext aren’t based on a single, specific thread. SynchronizationContext does not include a mechanism to determine if synchronization is necessary, because this isn’t always possible.

Another aspect of SynchronizationContext is that every thread has a “current” context. A thread’s context isn’t necessarily unique; its context instance may be shared with other threads. It’s possible for a thread to change its current context, but this is quite rare.

A third aspect of SynchronizationContext is that it keeps a count of outstanding asynchronous operations. This enables the use of ASP.NET asynchronous pages and any other host needing this kind of count. In most cases, the count is incremented when the current SynchronizationContext is captured, and the count is decremented when the captured SynchronizationContext is used to queue a completion notification to the context.

https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext#the-concept-of-synchronizationcontext

===== 重要函数

    // Dispatch work to the context.
    void Post(..); // (asynchronously)
    void Send(..); // (synchronously)
    // Keep track of the number of asynchronous operations.
    void OperationStarted();
    void OperationCompleted();
    // Each thread has a current context.
    // If "Current" is null, then the thread's current context is
    // "new SynchronizationContext()", by convention.
    static SynchronizationContext Current { get; }
    static void SetSynchronizationContext(SynchronizationContext);

===== 实现
https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext#the-implementations-of-synchronizationcontext

SynchronizationContext 的实际“上下文”尚未明确定义。不同的框架和宿主可以自由定义自己的上下文。了解这些不同的实现及其局限性，可以清楚地理解 SynchronizationContext 概念能够保证什么，以及不能保证什么。

====== WindowsFormsSynchronizationContext
WindowsFormsSynchronizationContext ( System.Windows.Forms.dll: System.Windows.Forms ) Windows 窗体应用将创建并安装一个 WindowsFormsSynchronizationContext 作为创建 UI 控件的任何线程的当前上下文。此 SynchronizationContext 使用 UI 控件上的 ISynchronizeInvoke 方法，该方法将委托传递给底层 Win32 消息循环。WindowsFormsSynchronizationContext 的上下文是单个 UI 线程。

所有排队到 WindowsFormsSynchronizationContext 的委托都会一次执行一个；它们由特定的 UI 线程按照排队顺序执行。当前实现会为每个 UI 线程创建一个 WindowsFormsSynchronizationContext。

====== DispatcherSynchronizationContext
DispatcherSynchronizationContext ( WindowsBase.dll: System.Windows.Threading ) WPF 和 Silverlight 应用程序使用 DispatcherSynchronizationContext，它将委托以“普通”优先级排队到 UI 线程的 Dispatcher。当线程通过调用 Dispatcher.Run 开始其 Dispatcher 循环时，此 SynchronizationContext 将被安装为当前上下文。DispatcherSynchronizationContext 的上下文是单个 UI 线程。

所有排队到 DispatcherSynchronizationContext 的委托都会按照排队顺序由特定的 UI 线程逐个执行。当前实现会为每个顶级窗口创建一个 DispatcherSynchronizationContext，即使它们共享同一个底层 Dispatcher。

====== Default (ThreadPool) SynchronizationContext
默认 (ThreadPool) SynchronizationContext ( mscorlib.dll: System.Threading ) 默认 SynchronizationContext 是一个默认构造的 SynchronizationContext 对象。按照惯例，如果线程的当前 SynchronizationContext 为 null，则它隐式地具有一个默认的 SynchronizationContext。

默认的 SynchronizationContext 将其异步委托排队到 ThreadPool，但其同步委托直接在调用线程上执行。因此，其上下文涵盖所有 ThreadPool 线程以及任何调用 Send 的线程。该上下文“借用”调用 Send 的线程，并将它们带入其上下文，直到委托完成。从这个意义上讲，默认上下文可以包含进程中的任何线程。

除非代码托管在 ASP.NET 中，否则默认 SynchronizationContext 会应用于 ThreadPool 线程。除非子线程设置了自己的 SynchronizationContext，否则默认 SynchronizationContext 也会隐式应用于显式子线程（Thread 类的实例）。因此，UI 应用程序通常有两个同步上下文：覆盖 UI 线程的 UI SynchronizationContext 和覆盖 ThreadPool 线程的默认 SynchronizationContext。

默认情况下，控制台应用程序和 Windows 服务中的所有线程都只具有默认的 SynchronizationContext。这会导致某些基于事件的异步组件失败。一种解决方案是创建一个显式子线程，并在该线程上安装 SynchronizationContext，以便为这些组件提供上下文。实现 SynchronizationContext 超出了本文的讨论范围，但 Nito.Async 库 ( nitoasync.codeplex.com ) 的 ActionThread 类可以用作通用的 SynchronizationContext 实现。

====== AspNetSynchronizationContext
AspNetSynchronizationContext ( System.Web.dll: System.Web [内部类] ) ASP.NET SynchronizationContext 在线程池线程执行页面代码时安装。当委托被加入到已捕获的 AspNetSynchronizationContext 队列中时，它会恢复原始页面的标识和文化，然后直接执行委托。即使委托是通过调用 Post 方法异步加入队列的，也会直接调用。

从概念上讲，AspNetSynchronizationContext 的上下文很复杂。在异步页面的生命周期内，上下文最初仅包含来自 ASP.NET 线程池的一个线程。异步请求启动后，上下文不再包含任何线程。异步请求完成后，执行其完成例程的线程池线程将进入上下文。这些线程可能是发起请求的线程，但更有可能是操作完成时恰好空闲的线程。

如果同一应用程序的多个操作同时完成，AspNetSynchronizationContext 将确保它们一次执行一个。它们可以在任何线程上执行，但该线程将具有原始页面的标识和文化。

一个常见的例子是在异步网页中使用的 WebClient。DownloadDataAsync 将捕获当前的 SynchronizationContext，并在该上下文中执行其 DownloadDataCompleted 事件。当页面开始执行时，ASP.NET 将分配一个线程来执行该页面中的代码。该页面可能会调用 DownloadDataAsync 然后返回；ASP.NET 会记录未完成的异步操作数量，因此它知道页面尚未完成。当 WebClient 对象下载完请求的数据后，它将在线程池线程上收到通知。该线程将在捕获的上下文中引发 DownloadDataCompleted 事件。上下文将保留在同一线程上，但会确保事件处理程序以正确的身份和文化运行。

===== 参考
https://learn.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext
https://devblogs.microsoft.com/dotnet/await-synchronizationcontext-and-console-apps/
https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext
https://devblogs.microsoft.com/dotnet/configureawait-faq/#what-is-a-synchronizationcontext

==== ExecutionContext(执行上下文)
https://learn.microsoft.com/en-us/dotnet/api/system.threading.executioncontext

vs. synchronizationcontext
https://devblogs.microsoft.com/dotnet/executioncontext-vs-synchronizationcontext/

==== 实现
- Task
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs

- Task<TResult>
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Future.cs

- TaskScheduler
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskScheduler.cs

==== custom/extend(定制与扩展)
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#custom-schedulers

https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming#custom-task-types

- Async Task Types in C#
https://github.com/dotnet/roslyn/blob/main/docs/features/task-types.md

=== coroutine
==== 概览
- asynchronous-programming-patterns
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/
Task-based Asynchronous Pattern (TAP), 即async/await模式
是异步编程模型的推荐方式，since .NET Framework 4
另外两种模式均不推荐:
Event-based Asynchronous Pattern (EAP)
Asynchronous Programming Model (APM) pattern (also called the IAsyncResult pattern)

- TAP 示例
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/

- TAP Pattern
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model#BKMK_Threads
https://www.zhihu.com/question/554133167
https://stackoverflow.com/questions/18013523/when-correctly-use-task-run-and-when-just-async-await
https://stackoverflow.com/questions/21879606/async-await-threading-internals

- EAP Pattern
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap

- APM Pattern
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm
https://devblogs.microsoft.com/dotnet/how-async-await-really-works/#in-the-beginning%E2%80%A6

- Implementing the Task-based Asynchronous Pattern
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern

- Consuming the Task-based Asynchronous Pattern
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern

==== async
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async

- 返回值
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-return-types
异步方法的返回类型: void/Task(可以认为是Task<void>)/Task<TResult>
对于一个异步方法，只有在作为事件订阅者时才应该返回void。在其他不需要特定返回值的情况下，最好将方法声明为返回Task。这样，调用者可以等待操作完成，以及探测失败情况等。

- 方法约束
所有参数都不能使用out或ref修饰符。这是因为这些修饰符是用于将通信信息返回给调用代码的；而且在控制返回给调用者时，某些异步方法可能还没有开始执行，因此引用参数可能还没有赋值。当然，更奇怪的是: 将局部变量作为实参传递给ref形参，异步方法可以在调用方法已经结束的情况下设置该变量。这并没有多大意义，所以编译器干脆禁止这么做。

==== await
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/await

- awaitable
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#12982-awaitable-expressions
https://devblogs.microsoft.com/dotnet/await-anything/

- await的约束
不能在catch或finally块、非异步匿名函数、lock语句块或不安全代码中使用。
这些约束条件是为了保证安全，特别是关于锁的约束。

==== 最佳实践
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios#important-info-and-advice
https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming
https://blog.stephencleary.com/2016/12/eliding-async-await.html

==== 实现
===== 原理
https://devblogs.microsoft.com/dotnet/how-async-await-really-works/
中文: https://zhuanlan.zhihu.com/p/661130031

https://learn.microsoft.com/en-us/shows/on-dotnet/writing-async-await-from-scratch-in-csharp-with-stephen-toub

https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios
http://www.xyting.org/2017/02/28/understand-async-await-in-depth.html
https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.iasyncstatemachine
https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext

https://devblogs.microsoft.com/dotnet/configureawait-faq/

在程序编译前，编译器会将异步方法转换为状态机，当 await 语句后面的任务没有完成时，状态机将执行到这一句并等待，而在等待的过程中，线程将去执行其它任务，不会一直阻塞在这里。一旦任务完成，状态机被推动到下一个状态，线程继续执行 await 语句到之后的代码。

===== 示例
[source, csharp]
----
namespace TestCoroutine
{
    internal class Program
    {
        static async Task<int> FuncAsync()
        {
            Func1();
            Func2();
            await Func3Async();
            await Func4Async();
            Func5();
            return 1;
        }

        static void Func1()
        {
            Console.WriteLine("Func1");
        }

        static void Func2()
        {
            Console.WriteLine("Func2");
        }

        static async Task<int> Func3Async()
        {
            Console.WriteLine("Func3Async Begin");
            await Task.Delay(1);
            Console.WriteLine("Func3Async End");
            return 1;
        }

        static async Task<int> Func4Async()
        {
            Console.WriteLine("Func4Async Begin");
            await Task.Delay(2);
            Console.WriteLine("Func4Async End");
            return 2;
        }

        static void Func5()
        {
            Console.WriteLine("Func5");
        }

        static async Task<int> Main(string[] args)
        {
            await FuncAsync();
            Console.WriteLine("Main 方法完成");
            return 0;
        }
    }
}
----
Q: 一旦FuncAsync开始执行，Func1()与Func2()是否一定会同时执行完毕？
Q: Func3Async()与Func4Async()如何被调度？
Q: Func5()还在main线程上执行吗？

===== Func3Async()反编译
以下是通过ILSpy反编译(推荐使用dnSpy)看到的结果:
[source, csharp]
----
[CompilerGenerated]
private sealed class <Func3Async>d__3 : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder<int> <>t__builder;

	private TaskAwaiter <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		int result;
		try
		{
			TaskAwaiter awaiter;
			if (num != 0)
			{
				Console.WriteLine("Func3Async Begin");
				awaiter = Task.Delay(1).GetAwaiter();
				if (!awaiter.IsCompleted)
				{
					num = (<>1__state = 0);
					<>u__1 = awaiter;
					<Func3Async>d__3 stateMachine = this;
					<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
					return;
				}
			}
			else
			{
				awaiter = <>u__1;
				<>u__1 = default(TaskAwaiter);
				num = (<>1__state = -1);
			}
			awaiter.GetResult();
			Console.WriteLine("Func3Async End");
			result = 1;
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult(result);
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}
----

- IAsyncStateMachine 接口
Func3Async 方法被编译成了一个实现了 IAsyncStateMachine 接口的类。这个接口提供了异步方法所需的机制，例如执行方法和处理状态转移的 MoveNext() 方法。

- <>1__state
这是状态机用来追踪执行流的状态变量。它帮助编译器追踪异步方法应该从哪个位置继续执行。例如，方法开始时，<>1__state 初始化的时候会被设置为 -1，这通过dnSpy可以看到:

    //     <FuncAsync>d__.<>1__state = -1;
    /* 0x00000265 06           */ IL_0011: ldloc.0
    /* 0x00000266 15           */ IL_0012: ldc.i4.m1
    /* 0x00000267 7D07000004   */ IL_0013: stfld     int32 TestCoroutine.Program/'<FuncAsync>d__0'::'<>1__state'

    ldc.i4.m1指令:
    https://learn.microsoft.com/zh-cn/dotnet/api/system.reflection.emit.opcodes.ldc_i4_m1

- AsyncTaskMethodBuilder<int> <>t__builder
AsyncTaskMethodBuilder 是一个结构体，用于内部管理异步方法的结果。它维护了一个 int 类型的任务，这意味着异步方法最终会返回一个 int 类型的结果。
<>t__builder 负责设置异步方法的结果（SetResult）、处理异常（SetException）以及报告完成（AwaitUnsafeOnCompleted）。

- TaskAwaiter <>u__1
存储 Task.Delay(1) 的 awaiter。TaskAwaiter 是一个结构体，用来等待异步任务的完成。如果任务尚未完成，状态机会保存当前的 awaiter，并且在任务完成后，恢复执行。

- MoveNext()
这是状态机的核心方法，负责推动异步方法的执行。它根据当前的状态（<>1__state）判断方法应该从哪里继续执行。状态机根据当前的状态执行下一步，或者在需要时等待异步任务的完成。
这个方法的执行流程大致如下：
初始时（num != 0），打印 "Func3Async Begin"，然后调用 Task.Delay(1)，并获取其 awaiter（等待器）。如果 Task.Delay 还没有完成，状态机会保存当前的 awaiter，并且将状态设置为 0，然后使用 AwaitUnsafeOnCompleted 调度后续操作。
当 Task.Delay 完成后，状态会恢复为 -1，然后继续执行方法的后续部分。
如果在执行过程中发生异常，状态机会将状态设置为 -2，并通过 <>t__builder.SetException 抛出异常。
如果执行成功，状态机会调用 <>t__builder.SetResult(result) 来设置结果。

Q: MoveNext()一般不会只执行一次，那么之后的MoveNext()是如何执行的呢？

===== FuncAsync()反编译
同上，以下是通过ILSpy反编译看到的结果:
[source, csharp]
----
[CompilerGenerated]
private sealed class <FuncAsync>d__0 : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder<int> <>t__builder;

	private TaskAwaiter<int> <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		int result;
		try
		{
			TaskAwaiter<int> awaiter;
			TaskAwaiter<int> awaiter2;
			if (num != 0)
			{
				if (num == 1)
				{
					awaiter = <>u__1;
					<>u__1 = default(TaskAwaiter<int>);
					num = (<>1__state = -1);
					goto IL_00dc;
				}
				Func1();
				Func2();
				awaiter2 = Func3Async().GetAwaiter();
				if (!awaiter2.IsCompleted)
				{
					num = (<>1__state = 0);
					<>u__1 = awaiter2;
					<FuncAsync>d__0 stateMachine = this;
					<>t__builder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine);
					return;
				}
			}
			else
			{
				awaiter2 = <>u__1;
				<>u__1 = default(TaskAwaiter<int>);
				num = (<>1__state = -1);
			}
			awaiter2.GetResult();
			awaiter = Func4Async().GetAwaiter();
			if (!awaiter.IsCompleted)
			{
				num = (<>1__state = 1);
				<>u__1 = awaiter;
				<FuncAsync>d__0 stateMachine = this;
				<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
				return;
			}
			goto IL_00dc;
			IL_00dc:
			awaiter.GetResult();
			Func5();
			result = 1;
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult(result);
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}
----
同理，<>1__state 初始化的时候会被设置为 -1。

===== Start()
https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asynctaskmethodbuilder.start

[source, csharp]
.AsyncTaskMethodBuilder.Start()
----
public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
{
    if (stateMachine == null)
    {
        throw new ArgumentNullException("stateMachine");
    }
    ExecutionContextSwitcher executionContextSwitcher = default(ExecutionContextSwitcher);
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
        ExecutionContext.EstablishCopyOnWriteScope(ref executionContextSwitcher);
        stateMachine.MoveNext();
    }
    finally
    {
        executionContextSwitcher.Undo();
    }
}
----

也就是说，Start()会调用stateMachine.MoveNext()。

===== AwaitUnsafeOnCompleted()
https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asynctaskmethodbuilder.awaitunsafeoncompleted

[source, csharp]
.AsyncTaskMethodBuilder.AwaitUnsafeOnCompleted()
----
public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine
{
    try
    {
        AsyncMethodBuilderCore.MoveNextRunner moveNextRunner = null;
        Action completionAction = this.m_coreState.GetCompletionAction(AsyncCausalityTracer.LoggingOn ? this.Task : null, ref moveNextRunner);
        if (this.m_coreState.m_stateMachine == null)
        {
            Task<TResult> task = this.Task;
            this.m_coreState.PostBoxInitialization(stateMachine, moveNextRunner, task);
        }
        awaiter.UnsafeOnCompleted(completionAction);
    }
    catch (Exception ex)
    {
        AsyncMethodBuilderCore.ThrowAsync(ex, null);
    }
}
----

可见，核心函数是GetCompletionAction()与UnsafeOnCompleted()。

===== GetCompletionAction()
[source, csharp]
.AsyncMethodBuilderCore.GetCompletionAction()
----
internal Action GetCompletionAction(Task taskForTracing, ref AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize)
{
    Debugger.NotifyOfCrossThreadDependency();
    ExecutionContext executionContext = ExecutionContext.FastCapture();
    Action action;
    AsyncMethodBuilderCore.MoveNextRunner moveNextRunner;
    if (executionContext != null && executionContext.IsPreAllocatedDefault)
    {
        action = this.m_defaultContextAction;
        if (action != null)
        {
            return action;
        }
        moveNextRunner = new AsyncMethodBuilderCore.MoveNextRunner(executionContext, this.m_stateMachine);
        action = new Action(moveNextRunner.Run);
        if (taskForTracing != null)
        {
            action = (this.m_defaultContextAction = this.OutputAsyncCausalityEvents(taskForTracing, action));
        }
        else
        {
            this.m_defaultContextAction = action;
        }
    }
    else
    {
        moveNextRunner = new AsyncMethodBuilderCore.MoveNextRunner(executionContext, this.m_stateMachine);
        action = new Action(moveNextRunner.Run);
        if (taskForTracing != null)
        {
            action = this.OutputAsyncCausalityEvents(taskForTracing, action);
        }
    }
    if (this.m_stateMachine == null)
    {
        runnerToInitialize = moveNextRunner;
    }
    return action;
}
----

===== UnsafeOnCompleted()
[source, csharp]
.TaskAwaiter.UnsafeOnCompleted()
----
public void UnsafeOnCompleted(Action continuation)
{
	TaskAwaiter.OnCompletedInternal(this.m_task, continuation, true, false);
}
----

[source, csharp]
.TaskAwaiter.OnCompletedInternal()
----
internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext)
{
    if (continuation == null)
    {
        throw new ArgumentNullException("continuation");
    }
    StackCrawlMark stackCrawlMark = StackCrawlMark.LookForMyCaller;
    if (TplEtwProvider.Log.IsEnabled() || Task.s_asyncDebuggingEnabled)
    {
        continuation = TaskAwaiter.OutputWaitEtwEvents(task, continuation);
    }
    task.SetContinuationForAwait(continuation, continueOnCapturedContext, flowExecutionContext, ref stackCrawlMark);
}
----
最终调用Task.SetContinuationForAwait()。

===== SetContinuationForAwait()
[source, csharp]
.Task.SetContinuationForAwait()
----
internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext, ref StackCrawlMark stackMark)
{
    TaskContinuation taskContinuation = null;
    if (continueOnCapturedContext)
    {
        SynchronizationContext currentNoFlow = SynchronizationContext.CurrentNoFlow;
        if (currentNoFlow != null && currentNoFlow.GetType() != typeof(SynchronizationContext))
        {
            taskContinuation = new SynchronizationContextAwaitTaskContinuation(currentNoFlow, continuationAction, flowExecutionContext, ref stackMark);
        }
        else
        {
            TaskScheduler internalCurrent = TaskScheduler.InternalCurrent;
            if (internalCurrent != null && internalCurrent != TaskScheduler.Default)
            {
                taskContinuation = new TaskSchedulerAwaitTaskContinuation(internalCurrent, continuationAction, flowExecutionContext, ref stackMark);
            }
        }
    }
    if (taskContinuation == null && flowExecutionContext)
    {
        taskContinuation = new AwaitTaskContinuation(continuationAction, true, ref stackMark);
    }
    if (taskContinuation != null)
    {
        if (!this.AddTaskContinuation(taskContinuation, false))
        {
            taskContinuation.Run(this, false);
            return;
        }
    }
    else if (!this.AddTaskContinuation(continuationAction, false))
    {
        AwaitTaskContinuation.UnsafeScheduleAction(continuationAction, this);
    }
}
----

Q: 例如AwaitTaskContinuation.UnsafeScheduleAction会将continuationAction放入线程池，那么continuationAction会在不同的线程上执行吗？

===== TaskContinuation及其子类
https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskContinuation.cs

internal abstract class TaskContinuation

internal class AwaitTaskContinuation : TaskContinuation, IThreadPoolWorkItem
internal sealed class SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation
internal sealed class TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation

internal sealed class ContinueWithTaskContinuation : TaskContinuation

===== 参考
https://www.cnblogs.com/xiaoxiaotank/p/14303803.html
https://summid.icu/index.php/2023/10/01/stasktutorials1/

==== 线程安全
===== 概念
使用异步方法时，一般对其中的线程切换几乎没有任何感知的。在 .NET 实现中，执行 await 语句之前和之后代码的线程是有可能不同的。虽然有线程切换，但一般不需要关心其中的细节，通常 .NET 已经帮忙完成了这些工作，.NET 会让结果看起来和单线程一致。

===== WPF
WPF 的主线程即 UI 线程中，拥有属于自己的 DispatcherSynchronizationContext，通过使用 DispatcherSynchronizationContext 执行延续方法，又能回到 UI 线程中。

[source, csharp]
----
public partial class MainWindow : Window
{
    public MainWindow()
    {
        Test();
        InitializeComponent();
    }
    
    private async void Test()
    {
        ShowTCurThreadInfo(Thread.CurrentThread, "Test Start");
        await TestAsync();
        ShowTCurThreadInfo(Thread.CurrentThread, "Test End");
    }

    private Task TestAsync()
    {
        return Task.Run(() =>
        {
            ShowTCurThreadInfo(Thread.CurrentThread, "TestAsync");
        });
    }

    private static void ShowTCurThreadInfo(Thread thread, string tag)
    {
        MessageBox.Show($"{tag} {nameof(thread.ManagedThreadId)}: {thread.ManagedThreadId}" +
                        $"\n{nameof(thread.ThreadState)}: {thread.ThreadState}");
    }
}
----

===== 控制台程序
在控制台应用程序中，默认的 SynchronizationContext 是 null，这与 UI 应用程序（WinForms、WPF）有根本区别。await 后的线程行为由线程池任意分配线程，不像 UI 应用程序会 marshall 回 UI 线程。

[source, csharp]
----
using System.Collections.Concurrent;

class Program
{
    static async Task Main(string[] args)
    {
        Console.WriteLine($"Main Start - Thread ID: {Thread.CurrentThread.ManagedThreadId}");

        // 保存原始的同步上下文
        var originalContext = SynchronizationContext.Current;
        
        try
        {
            // 1. 创建一个单线程的同步上下文
            var singleThreadContext = new SingleThreadSynchronizationContext();
            // 2. 将其设置为当前同步上下文
            SynchronizationContext.SetSynchronizationContext(singleThreadContext);
        
            // 3. 在这个上下文中运行异步代码
            await DoSomethingAsync();
        
            // 续延部分会在指定的同一个线程上运行
            Console.WriteLine($"Main After Await - Thread ID: {Thread.CurrentThread.ManagedThreadId}");
        }
        finally
        {
            // 恢复原始同步上下文
            SynchronizationContext.SetSynchronizationContext(originalContext);
        }
        Console.ReadLine();
    }

    static async Task DoSomethingAsync()
    {
        Console.WriteLine($"DoSomethingAsync Start - Thread ID: {Thread.CurrentThread.ManagedThreadId}");
        await Task.Delay(1000);
        Console.WriteLine($"DoSomethingAsync After Await - Thread ID: {Thread.CurrentThread.ManagedThreadId}");
    }
}

// 一个简单的单线程同步上下文实现
public class SingleThreadSynchronizationContext : SynchronizationContext
{
    private readonly BlockingCollection<(SendOrPostCallback, object?)> _queue = new();
    private readonly Thread _thread;

    public SingleThreadSynchronizationContext()
    {
        _thread = new Thread(RunOnCurrentThread) { IsBackground = true };
        _thread.Start();
    }

    public override void Post(SendOrPostCallback d, object? state)
    {
        _queue.Add((d, state));
    }

    public override void Send(SendOrPostCallback d, object? state)
    {
        // 简化实现，Send 可能也需要特殊处理
        Post(d, state);
    }

    private void RunOnCurrentThread()
    {
        // 设置这个循环线程本身的同步上下文为自己
        SetSynchronizationContext(this);

        Console.WriteLine($"Dedicated Thread Started - ID: {Thread.CurrentThread.ManagedThreadId}");

        foreach (var (callback, state) in _queue.GetConsumingEnumerable())
        {
            callback(state);
        }
    }

    public void Complete() => _queue.CompleteAdding();
}
----

===== UniTask
Why is UniTask(custom task-like object) required? Because Task is too heavy and not matched to Unity threading (single-thread). UniTask does not use threads and SynchronizationContext/ExecutionContext because Unity's asynchronous object is automaticaly dispatched by Unity's engine layer. It achieves faster and lower allocation, and is completely integrated with Unity.
https://github.com/Cysharp/UniTask?tab=readme-ov-file#basics-of-unitask-and-asyncoperation

==== 性能
===== 概览
https://learn.microsoft.com/en-us/archive/msdn-magazine/2011/october/asynchronous-programming-async-performance-understanding-the-costs-of-async-and-await

===== ValueTask
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask
https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/

===== Yield and Enumerator
- yield return
惰性求值 (Lazy Evaluation) / 按需生成
简化迭代器模式的实现
构建高效的数据处理管道 (LINQ-to-Objects 的基础)
https://learn.microsoft.com/en-us/answers/questions/2152913/yield-in-small-explanation-advantages

- async iterators
https://learn.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8
https://www.naveedulhaq.com/index.php/dot-net-core/combining-async-and-yield-in-c/

- 规范
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/yield
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1315-the-yield-statement

==== 参考
《深入理解C#》第三版 chapter15 使用async/await进行异步编程
https://devblogs.microsoft.com/pfxteam/
https://devblogs.microsoft.com/pfxteam/asyncawait-faq/

=== debug
https://learn.microsoft.com/en-us/visualstudio/debugger/debug-multithreaded-applications-in-visual-studio

== 内存

=== 参考
https://learn.microsoft.com/en-us/dotnet/standard/managed-code

== API
=== linq
https://learn.microsoft.com/en-us/dotnet/csharp/linq/

=== JSON
- newtonsoft
- system-text-json

=== attribute
https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute
https://learn.microsoft.com/en-us/dotnet/api/system.serializableattribute

FunctionName that called: CallerMemeberNameAttribute
Caller File: CallerFilePathAttribute
Caller Line Number: CallerLineNumberAttribute
https://stackoverflow.com/questions/72258670/c-sharp-get-the-calling-methods-line-number-class-file-and-method-name-etc

== 工具
=== roslyn
https://github.com/dotnet/roslyn
https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/

CSharpSyntaxWalker:
https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.csharpsyntaxwalker

=== codedom
https://stackoverflow.com/questions/7852926/microsoft-roslyn-vs-codedom
https://github.com/dotnet/runtime/tree/main/src/libraries/System.CodeDom

=== t4
https://en.wikipedia.org/wiki/Text_Template_Transformation_Toolkit
https://learn.microsoft.com/en-us/visualstudio/modeling/code-generation-and-t4-text-templates

=== online
https://dotnet.microsoft.com/en-us/platform/try-dotnet

=== 编译过程、IL、反编译等
ILSpy: https://github.com/icsharpcode/ILSpy/releases
dnSpy(推荐使用，功能更为强大): https://github.com/dnSpyEx/dnSpy

https://sharplab.io/

=== dotTrace

== 热更新(Hot Update)
- 反射、AssemblyLoadContext等

- Roslyn

- 插件架构

== 代码风格
https://google.github.io/styleguide/csharp-style.html
https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions
https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/

== source
https://github.com/dotnet/runtime

== 参考
https://github.com/thangchung/awesome-dotnet-core
https://learn.microsoft.com/en-us/dotnet/api/
https://wizardforcel.gitbooks.io/effective-csharp/