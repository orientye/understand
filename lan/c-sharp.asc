= c#
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 概览
=== .NET实现

    .NET Framework
        原始 .NET。 它提供对 Windows 和 Windows Server 的广泛功能的访问权限。
    Mono
        原始社区和开放源代码 .NET。 一个跨平台 .NET Framework 实现。
        积极支持 Android、iOS 和 WebAssembly。
    .NET (Core) -- 新式 .NET。
        .NET 的一个跨平台开放源代码实现
        针对云时代进行了反思，同时与 .NET Framework 保持极大的兼容。
        积极支持 Linux、macOS 和 Windows。
    参考: https://learn.microsoft.com/zh-cn/dotnet/core/introduction#net-ecosystem

== 核心
=== 委托
委托是持有一个或多个方法的对象。

两种方式调用委托：

    一种是像调用方法一样调用委托
    一种是使用委托的Invoke方法

多个方法与返回值:

    添加方法按顺序
    调用列表中最后一个方法返回的值即是委托调用的返回值

匿名方法与Lambda表达式:

    MyDel del = delegate(int x) { return x + 1; } ;     //匿名方法，不推荐
    MyDel del =         (int x) => { return x + 1; } ;  //Lambda，推荐

=== 特性(Attribute)
https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/reflection-and-attributes/

== concurrency

=== asynchronous-programming-patterns
https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/

Task-based Asynchronous Pattern (TAP), 即async/await模式
推荐方式
since .NET Framework 4

另外两种模式均不推荐:
Event-based Asynchronous Pattern (EAP)
Asynchronous Programming Model (APM) pattern (also called the IAsyncResult pattern)

=== parallel-programming
https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/

=== threading
https://learn.microsoft.com/en-us/dotnet/standard/threading/

=== coroutine
==== 概览
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/

https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model#BKMK_Threads

https://zhuanlan.zhihu.com/p/661130031
https://www.zhihu.com/question/554133167

https://stackoverflow.com/questions/18013523/when-correctly-use-task-run-and-when-just-async-await
https://stackoverflow.com/questions/21879606/async-await-threading-internals

==== 同步上下文
异步函数能够回到正确的线程中，是因为使用了SynchronizationContext类。
该类早在.NET 2.0中就已存在，供BackgroundWorker等其他组件使用。
SynchronizationContext涵盖了在适当的线程上执行委托这一理念。
不同的执行环境使用不同的上下文。例如，某个上下文可能会从线程池中取出一个线程并执行给定的行为。除了同步上下文以外还有很多上下文信息，但如果想知道异步方法是如何在正确的位置上执行的，就要牢记同步上下文。

==== 语法和语义
async修饰符在生成的代码中没有作用，但建议加上。
异步方法的返回类型: void/Task(可以认为是Task<void>)/Task<TResult>

对于一个异步方法，只有在作为事件订阅者时才应该返回void。在其他不需要特定返回值的情况下，最好将方法声明为返回Task。这样，调用者可以等待操作完成，以及探测失败情况等。

还有一个关于异步方法签名的约束：所有参数都不能使用out或ref修饰符。这么做是有道理的，因为这些修饰符是用于将通信信息返回给调用代码的；而且在控制返回给调用者时，某些异步方法可能还没有开始执行，因此引用参数可能还没有赋值。当然，更奇怪的是：将局部变量作为实参传递给ref形参，异步方法可以在调用方法已经结束的情况下设置该变量。这并没有多大意义，所以编译器干脆禁止这么做。

await的约束:
不能在catch或finally块、非异步匿名函数、lock语句块或不安全代码中使用。
这些约束条件是为了保证安全，特别是关于锁的约束。

==== 最佳实践
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios#important-info-and-advice
https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming

==== 实现
https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model#BKMK_Threads

async/await本质上只是一个语法糖，它并不产生线程，只是在编译时把语句的执行逻辑改了。

SynchronizationContext:
在线程切换过程中保存调用线程的上下文环境，在异步任务完成后使用此线程同步上下文执行后继代码。
https://learn.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext
[source, csharp]
----
public static void DoWork()
{
    //On UI thread
    var sc = SynchronizationContext.Current;

    ThreadPool.QueueUserWorkItem(delegate
    {
        //... async task：do work on ThreadPool
        sc.Post(delegate
        {
             // do work on the original context (UI)
        }, null);
    });
}
----

Task:
https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task

https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios
http://www.xyting.org/2017/02/28/understand-async-await-in-depth.html
https://www.cnblogs.com/brookshi/p/5240510.html
https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.iasyncstatemachine

==== 参考
《深入理解C#》第三版 chapter15 使用async/await进行异步编程
https://devblogs.microsoft.com/pfxteam/

=== API
https://learn.microsoft.com/en-us/dotnet/api/system.threading

=== Q&A
- await Task<T> and Task<T>.Result?
https://stackoverflow.com/questions/27464287/
https://stackoverflow.com/questions/32239661/

== 内存

== 工具
https://github.com/dotnet/roslyn

== 参考
https://github.com/thangchung/awesome-dotnet-core
https://learn.microsoft.com/en-us/dotnet/api/
https://wizardforcel.gitbooks.io/effective-csharp/