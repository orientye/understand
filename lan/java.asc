= java
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 历史
https://en.wikipedia.org/wiki/Java_version_history

== 基础
=== OOP

=== 泛型

=== 注解
https://www.geeksforgeeks.org/annotations-in-java/
https://docs.oracle.com/javase/tutorial/java/annotations/index.html

=== 异常

=== 反射

=== SPI
Service Provider Interface

== concurrency
=== 介绍
Threads are sometimes called lightweight processes, and most modern operating systems treat threads, not processes, as the basic units of scheduling.

Benefits of threads:
1. Exploiting multiple processors
2. Simplicity of modeling
A complicated, asynchronous workflow can be decomposed into a number of simpler, synchronous workflows each running in a separate thread, interacting only with each other at specific synchronization points.
3. Simplified handling of asynchronous events
4. More responsive user interfaces

Risks of threads:
1. Safety hazards
Thread safety can be unexpectedly subtle because, in the absence of sufficient synchronization, the ordering of operations in multiple threads is unpredictable and sometimes surprising.
2. Liveness hazards
safety means "nothing bad ever happens"
liveness concerns the complementary goal that "something good eventually happens"
For example, if thread A is waiting for a resource that thread B holds exclusively, and B never releases it, A will wait forever.
3. Performance hazards
When threads share data, they must use synchronization mechanisms that can inhibit compiler optimizations, flush or invalidate memory caches, and create synchronization traffic on the shared memory bus. All these factors introduce additional performance costs.

Threads are everywhere:
When the JVM starts, it creates threads for JVM housekeeping tasks (garbage collection, finalization) and a main thread for running the main method.
The AWT (Abstract Window Toolkit) and Swing user interface frameworks create threads for managing user interface events.
Timer creates threads for executing deferred tasks.
Component frameworks, such as servlets and RMI create pools of threads and invoke component methods in these threads.

=== 线程安全
If multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to fix it:
• Don’t share the state variable across threads;
• Make the state variable immutable; or
• Use synchronization whenever accessing the state variable.

什么是线程安全:
Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.
Example: a stateless servlet
[source, java]
----
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
----
Stateless objects are always thread-safe.

Atomicity原子性:
[source, java]
----
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = 0;
    public long getCount() { return count; }
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count; //not thread safe
        encodeIntoResponse(resp, factors);
    }
}
----
race conditions:
[source, java]
----
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance() {
        if (instance == null)
        instance = new ExpensiveObject();
        return instance;
    }
}
----

[source, java]
----
@ThreadSafe
public class CountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);
    public long getCount() { return count.get(); }
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }
}
----
Where practical, use existing thread-safe objects, like AtomicLong, to manage your class’s state.

Locking:
[source, java]
----
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
----
Code that would deadlock if intrinsic locks were not reentrant.

Guarding state with locks

Liveness and performance:
There is frequently a tension between simplicity and performance. When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.
Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or console I/O.

=== Sharing Objects
==== Visibility
可见性
always use the proper synchronization whenever data is shared across threads.
Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all threads see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lock.

Volatile variables:
Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when veryfing correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event (such as initialization or shutdown) has occurred.
Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.
You can use volatile variables only when all the following criteria are met:
• Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;
• The variable does not participate in invariants with other state variables;
and
• Locking is not required for any other reason while the variable is being accessed.

==== Publication and escape
Publishing an object means making it available to code outside of its current scope, such as by storing a reference to it where other code can find it, returning it from a nonprivate method, or passing it to a method in another class ...
An object that is published when it should not have been is said to have escaped.

==== Thread confinement
线程约束
• Ad-hoc thread confinement(特定目的线程约束)
The decision to use thread confinement is often a consequence of the decision to implement a particular subsystem, such as the GUI, as a single-threaded subsystem.
A special case of thread confinement applies to volatile variables.
建议:
Because of its fragility, ad-hoc thread confinement should be used sparingly; if possible, use one of the stronger forms of thread confinment (stack confinement or ThreadLocal) instead.
• Stack confinement
Stack confinement is a special case of thread confinement in which an object can only be reached through local variables.
Stack confinement (also called within-thread or thread-local usage, but not to be confused with the ThreadLocal library class) is simpler to maintain and less fragile than ad-hoc thread confinement.
• ThreadLocal
ThreadLocal provides get and set accessor methods that maintain a separate copy of the value for each thread that uses it, so a get returns the most recent value passed to set from the currently executing thread.
[source, java]
----
private static ThreadLocal<Connection> connectionHolder
    = new ThreadLocal<Connection>() {
        public Connection initialValue() {
            return DriverManager.getConnection(DB_URL);
        }
    };

public static Connection getConnection() {
    return connectionHolder.get();
}
----

==== Immutability
An object is immutable if:
• Its state cannot be modified after construction;
• All its fields are final;
• It is properly constructed (the this reference does not escape during construction).
[source, java]
.Immutable class built out of mutable underlying objects.
----
@Immutable
public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();
        public ThreeStooges() {
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
    }

    public boolean isStooge(String name) {
        return stooges.contains(name);
    }
}
----

Final fields:
Even if an object is mutable, making some fields final can still simplify reasoning about its state, since limiting the mutability of an object restricts its set of possible states. An object that is “mostly immutable” but has one or two mutable state variables is still simpler than one that has many mutable variables.
it is a good practice to make all fields private unless they need greater visibility, it is a good practice to make all fields final unless they need to be mutable.

==== Safe publication
Immutable objects can be used safely by any thread without additional synchronization, even when synchronization is not used to publish them.
To publish an object safely, both the reference to the object and the object’s state must be made visible to other threads at the same time. A properly constructed object can be safely published by:
• Initializing an object reference from a static initializer;
• Storing a reference to it into a volatile field or AtomicReference;
• Storing a reference to it into a final field of a properly constructed object; or
• Storing a reference to it into a field that is properly guarded by a lock.

Effectively immutable objects:
Objects that are not technically immutable, but whose state will not be modified after publication, are called effectively immutable.
Safely published effectively immutable objects can be used safely by any thread without additional synchronization.

Mutable objects:
The publication requirements for an object depend on its mutability:
• Immutable objects can be published through any mechanism;
• Effectively immutable objects must be safely published;
• Mutable objects must be safely published, and must be either thread-safe or guarded by a lock.

=== Composing Objects
Designing a thread-safe class
Instance confinement
Delegating thread safety
Adding functionality to existing thread-safe classes
Documenting synchronization policies

=== Building Blocks
==== Synchronized collections
java.util.Collections.synchronizedXxx factory methods

=== virtual thread
since JDK19, JDK 21(September 2023) release.
https://openjdk.org/jeps/444 JEP 444: Virtual Threads
https://openjdk.org/jeps/436 JEP 436: Virtual Threads (Second Preview)
https://openjdk.org/jeps/425 JEP 425: Virtual Threads (Preview)

=== API
- java.util.concurrent
- java.util.concurrent.locks
- java.util.concurrent.atomic

=== Q&A
servlet:
https://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreadi

=== 参考
《Java Concurrency in Practice》

== 热更新
- Javassist(Java Programming Assistant)
https://github.com/jboss-javassist/javassist

- Byte Buddy
https://github.com/raphw/byte-buddy

- java.lang.instrument.Instrumentation redefineClasses()

- 参考
https://www.zhihu.com/question/61040749

== JVM

== 性能优化

== 工具
=== lombok
https://projectlombok.org/
https://projectlombok.org/features/

=== maven
https://maven.apache.org/

=== 监控与分析
自带命令: jps、jstat、jstack、jmap
visualvm: https://visualvm.github.io/download.html

第三方在线监控工具:
arthas: https://github.com/alibaba/arthas/blob/master/README_CN.md
skywalking: https://github.com/apache/skywalking

== 参考
https://github.com/akullpp/awesome-java
https://docs.oracle.com/en/java/javase/index.html