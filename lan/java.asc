= java
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 历史
https://en.wikipedia.org/wiki/Java_version_history

== 基础
=== OOP

=== 泛型

=== 注解
https://docs.oracle.com/javase/tutorial/java/annotations/index.html

=== 异常

=== 反射

=== SPI
Service Provider Interface

== concurrency
=== 介绍
Threads are sometimes called lightweight processes, and most modern operating systems treat threads, not processes, as the basic units of scheduling.

Benefits of threads:
1. Exploiting multiple processors
2. Simplicity of modeling
A complicated, asynchronous workflow can be decomposed into a number of simpler, synchronous workflows each running in a separate thread, interacting only with each other at specific synchronization points.
3. Simplified handling of asynchronous events
4. More responsive user interfaces

Risks of threads:
1. Safety hazards
Thread safety can be unexpectedly subtle because, in the absence of sufficient synchronization, the ordering of operations in multiple threads is unpredictable and sometimes surprising.
2. Liveness hazards
safety means "nothing bad ever happens"
liveness concerns the complementary goal that "something good eventually happens"
For example, if thread A is waiting for a resource that thread B holds exclusively, and B never releases it, A will wait forever.
3. Performance hazards
When threads share data, they must use synchronization mechanisms that can inhibit compiler optimizations, flush or invalidate memory caches, and create synchronization traffic on the shared memory bus. All these factors introduce additional performance costs.

Threads are everywhere:
When the JVM starts, it creates threads for JVM housekeeping tasks (garbage collection, finalization) and a main thread for running the main method.
The AWT (Abstract Window Toolkit) and Swing user interface frameworks create threads for managing user interface events.
Timer creates threads for executing deferred tasks.
Component frameworks, such as servlets and RMI create pools of threads and invoke component methods in these threads.

=== 线程安全
If multiple threads access the same mutable state variable without appropriate synchronization, your program is broken. There are three ways to fix it:
• Don’t share the state variable across threads;
• Make the state variable immutable; or
• Use synchronization whenever accessing the state variable.

什么是线程安全:
Thread-safe classes encapsulate any needed synchronization so that clients need not provide their own.
Example: a stateless servlet
[source, java]
----
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
----
Stateless objects are always thread-safe.

Atomicity原子性:
[source, java]
----
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
    private long count = 0;
    public long getCount() { return count; }
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count; //not thread safe
        encodeIntoResponse(resp, factors);
    }
}
----
race conditions:
[source, java]
----
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;
    public ExpensiveObject getInstance() {
        if (instance == null)
        instance = new ExpensiveObject();
        return instance;
    }
}
----

[source, java]
----
@ThreadSafe
public class CountingFactorizer implements Servlet {
    private final AtomicLong count = new AtomicLong(0);
    public long getCount() { return count.get(); }
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }
}
----
Where practical, use existing thread-safe objects, like AtomicLong, to manage your class’s state.

Locking:
[source, java]
----
public class Widget {
    public synchronized void doSomething() {
        ...
    }
}
public class LoggingWidget extends Widget {
    public synchronized void doSomething() {
        System.out.println(toString() + ": calling doSomething");
        super.doSomething();
    }
}
----
Code that would deadlock if intrinsic locks were not reentrant.

Guarding state with locks

Liveness and performance:
There is frequently a tension between simplicity and performance. When implementing a synchronization policy, resist the temptation to prematurely sacrifice simplicity (potentially compromising safety) for the sake of performance.
Avoid holding locks during lengthy computations or operations at risk of not completing quickly such as network or console I/O.

=== Sharing Objects
Visibility可见性:
always use the proper synchronization whenever data is shared across threads.
Locking is not just about mutual exclusion; it is also about memory visibility. To ensure that all threads see the most up-to-date values of shared mutable variables, the reading and writing threads must synchronize on a common lock.

Volatile variables:
Use volatile variables only when they simplify implementing and verifying your synchronization policy; avoid using volatile variables when veryfing correctness would require subtle reasoning about visibility. Good uses of volatile variables include ensuring the visibility of their own state, that of the object they refer to, or indicating that an important lifecycle event (such as initialization or shutdown) has occurred.
Locking can guarantee both visibility and atomicity; volatile variables can only guarantee visibility.
You can use volatile variables only when all the following criteria are met:
• Writes to the variable do not depend on its current value, or you can ensure that only a single thread ever updates the value;
• The variable does not participate in invariants with other state variables;
and
• Locking is not required for any other reason while the variable is being accessed.

Publication and escape:
Publishing an object means making it available to code outside of its current scope, such as by storing a reference to it where other code can find it, returning it from a nonprivate method, or passing it to a method in another class ...
An object that is published when it should not have been is said to have escaped.

Thread confinement:
Ad-hoc thread confinement
Stack confinement
ThreadLocal

=== virtual thread
since JDK19, JDK 21(September 2023) release.
https://openjdk.org/jeps/444 JEP 444: Virtual Threads
https://openjdk.org/jeps/436 JEP 436: Virtual Threads (Second Preview)
https://openjdk.org/jeps/425 JEP 425: Virtual Threads (Preview)

=== API
- java.util.concurrent
- java.util.concurrent.locks
- java.util.concurrent.atomic

=== Q&A
servlet:
https://stackoverflow.com/questions/3106452/how-do-servlets-work-instantiation-sessions-shared-variables-and-multithreadi

=== 参考
《Java Concurrency in Practice》

== 热更新
- Javassist(Java Programming Assistant)
https://github.com/jboss-javassist/javassist

- Byte Buddy
https://github.com/raphw/byte-buddy

- java.lang.instrument.Instrumentation redefineClasses()

- 参考
https://www.zhihu.com/question/61040749

== JVM

== 性能优化

== 工具
=== lombok
https://projectlombok.org/
https://projectlombok.org/features/

=== maven
https://maven.apache.org/

=== 监控工具
自带命令: jps、jstat、jstack、jmap
visualvm: https://visualvm.github.io/download.html
第三方在线监控工具: arthas https://github.com/alibaba/arthas/blob/master/README_CN.md

== 参考
https://github.com/akullpp/awesome-java
https://docs.oracle.com/en/java/javase/index.html