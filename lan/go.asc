= go
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 程序结构
命名

    推荐驼峰式命名

包

    初始化

变量

    指针变量，在Go语言中，返回函数中局部变量地址是安全的

执行顺序

    import --> const --> var --> init() --> main()

== 数据类型

基础类型

    数值(整形 浮点 复数), 字符串, 布尔

复合类型

    数组 结构体

引用类型

    指针, 切片, 字典, 函数, 通道

接口类型

== 函数
形式

    func name(parameter-list) (result list) {
        body
    }

错误

    传播;
    重新尝试失败操作;
    输出错误信息并结束程序;
    只输出错误信息;
    忽略;

closure

defer

panic&recover

== 方法
形式

    func receiver name(parameter-list) (result list) {
        body
    }

    receiver: (变量名 变量类型) 无this, self

封装

    go语言只有一种控制可见性的手段: 大写首字母的标识符会从定义它们的包中被导出，小写字母则不会。
    最小封装单元是Package，而不是类型。

== 接口

[source, go]
----
package main
import "fmt"
type human struct {
    something string
}
type animal struct {
    whatever string
}
func (a *animal) Speak() string {
    return a.whatever
}
func (h *human) Speak() string {
    return h.something
}

type living interface {
    Speak() string
}
func AnyMethod(l living) {
    fmt.Println(l.Speak())
}

func main() {
    john := human{"I am john"}
    tom := animal{"Bow Bow"}
    
    AnyMethod(&john)
    AnyMethod(&tom)
}
----

== Goroutines-and-Channels

=== 概念
CSP

    communicating sequential processes
    Q: vs. Actor

goroutine

    go

channel

    ▪ create, send, recv, close
        ch := make(chan int) // ch has type 'chan int' 
        ch <- x // a send statement 
        x = <-ch // a receive expression in an assignment statement
        <-ch // a receive statement; result is discarded
        close(ch) 

    ▪ unbuffered/buffer
        ch = make(chan int) // unbuffered channel 
        ch = make(chan int, 0) // unbuffered channel 
        ch = make(chan int, 3) // buffered channel with capacity 3 

        unbuffered channels are sometimes called synchronous channels
        A buffered channel has a queue of elements

    ▪ select多路复用

race condition
 
Goroutines & Threads

    a goroutine's stack is not fixed; it grows and shrinks as needed.一般起始2K.
    m:n scheduling, multiplexes(or schedules) m goroutines on n OS threads

=== 实现
==== 结构
GPM结构:

    G: Goroutine，是一个待执行的任务
    M: 操作系统的线程，由操作系统的调度器调度和管理
    P: 处理器，可以被看做运行在线程上的本地调度器

G:
[source, go]
.https://github.com/golang/go/blob/master/src/runtime/runtime2.go
----
type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the //go:systemstack stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	stack       stack   // offset known to runtime/cgo
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic    *_panic // innermost panic - offset known to liblink
	_defer    *_defer // innermost defer
	m         *m      // current m; offset known to arm liblink
	sched     gobuf
	syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc
	syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc
	stktopsp  uintptr // expected sp at top of stack, to check in traceback
	// param is a generic pointer parameter field used to pass
	// values in particular contexts where other storage for the
	// parameter would be difficult to find. It is currently used
	// in four ways:
	// 1. When a channel operation wakes up a blocked goroutine, it sets param to
	//    point to the sudog of the completed blocking operation.
	// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed
	//    the GC cycle. It is unsafe to do so in any other way, because the goroutine's
	//    stack may have moved in the meantime.
	// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a
	//    closure in the runtime is forbidden.
	// 4. When a panic is recovered and control returns to the respective frame,
	//    param may point to a savedOpenDeferState.
	param        unsafe.Pointer
	atomicstatus atomic.Uint32
	stackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
	goid         uint64
	schedlink    guintptr
	waitsince    int64      // approx time when the g become blocked
	waitreason   waitReason // if status==Gwaiting

	preempt       bool // preemption signal, duplicates stackguard0 = stackpreempt
	preemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule
	preemptShrink bool // shrink stack at synchronous safe point

	// asyncSafePoint is set if g is stopped at an asynchronous
	// safe point. This means there are frames on the stack
	// without precise pointer information.
	asyncSafePoint bool

	paniconfault bool // panic (instead of crash) on unexpected fault address
	gcscandone   bool // g has scanned stack; protected by _Gscan bit in status
	throwsplit   bool // must not split stack
	// activeStackChans indicates that there are unlocked channels
	// pointing into this goroutine's stack. If true, stack
	// copying needs to acquire channel locks to protect these
	// areas of the stack.
	activeStackChans bool
	// parkingOnChan indicates that the goroutine is about to
	// park on a chansend or chanrecv. Used to signal an unsafe point
	// for stack shrinking.
	parkingOnChan atomic.Bool
	// inMarkAssist indicates whether the goroutine is in mark assist.
	// Used by the execution tracer.
	inMarkAssist bool
	coroexit     bool // argument to coroswitch_m

	raceignore    int8  // ignore race detection events
	nocgocallback bool  // whether disable callback from C
	tracking      bool  // whether we're tracking this G for sched latency statistics
	trackingSeq   uint8 // used to decide whether to track this G
	trackingStamp int64 // timestamp of when the G last started being tracked
	runnableTime  int64 // the amount of time spent runnable, cleared when running, only used when tracking
	lockedm       muintptr
	sig           uint32
	writebuf      []byte
	sigcode0      uintptr
	sigcode1      uintptr
	sigpc         uintptr
	parentGoid    uint64          // goid of goroutine that created this goroutine
	gopc          uintptr         // pc of go statement that created this goroutine
	ancestors     *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
	startpc       uintptr         // pc of goroutine function
	racectx       uintptr
	waiting       *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order
	cgoCtxt       []uintptr      // cgo traceback context
	labels        unsafe.Pointer // profiler labels
	timer         *timer         // cached timer for time.Sleep
	selectDone    atomic.Uint32  // are we participating in a select and did someone win the race?

	coroarg *coro // argument during coroutine transfers

	// goroutineProfiled indicates the status of this goroutine's stack for the
	// current in-progress goroutine profile
	goroutineProfiled goroutineProfileStateHolder

	// Per-G tracer state.
	trace gTraceState

	// Per-G GC state

	// gcAssistBytes is this G's GC assist credit in terms of
	// bytes allocated. If this is positive, then the G has credit
	// to allocate gcAssistBytes bytes without assisting. If this
	// is negative, then the G must correct this by performing
	// scan work. We track this in bytes to make it fast to update
	// and check for debt in the malloc hot path. The assist ratio
	// determines how this corresponds to scan work debt.
	gcAssistBytes int64
}
----

==== 调度
https://github.com/golang/go/blob/master/src/runtime/proc.go
参考: https://learnku.com/articles/41728
参考: https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/

==== 通信
https://github.com/golang/go/blob/master/src/runtime/chan.go
参考: https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/

== 包和工具
== 测试
== 反射
== 底层编程