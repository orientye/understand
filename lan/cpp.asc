= C++
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== history
https://en.cppreference.com/w/cpp/language/history

== criticism
https://en.wikipedia.org/wiki/Criticism_of_C%2B%2B
https://www.zhihu.com/question/1977143614883776265

== c
https://en.cppreference.com/w/c

== cpp
https://en.cppreference.com/w/cpp

== core
- 类型
https://en.cppreference.com/w/cpp/language/type
https://en.cppreference.com/w/cpp/types 

- 值
https://en.cppreference.com/w/cpp/language/value_category

          expression
            /    \
        glvalue   rvalue
          /  \    /   \
    lvalue   xvalue   prvalue

    Q: 函数调用表达式是左值还是右值？
    简单来讲:
        函数返回类型        值类别
        返回左值引用 T&     左值
        返回右值引用 T&&    右值
        返回非引用类型 T    纯右值

    Temporary materialization: (since c++17)
    https://en.cppreference.com/w/cpp/language/implicit_cast.html#Temporary_materialization

- 运算 (eg. sizeof, &)

- 指针变量

- 引用
https://en.cppreference.com/w/cpp/language/reference
左值引用、右值引用、前向引用(Forwarding Reference/Universal Reference)
通用引用(Universal Reference) 是 Scott Meyers 在《Effective Modern C++》中引入的通俗名称。

    前向引用/通用引用与右值引用:
        void f(Widget&& param); // rvalue reference; no type deduction
        Widget&& var1 = Widget(); // rvalue reference; no type deduction
        auto&& var2 = var1; // universal reference
        template<typename T> void f(std::vector<T>&& param); // rvalue reference
        template<typename T> void f(T&& param); // universal reference
    如果一个函数模板形参的类型为T&&，并且T需要被推导得知，或者如果一个对象被声明为auto&&，
    这个形参或者对象就是一个通用引用。
    如果类型声明的形式不是标准的type&&，或者如果类型推导没有发生，那么type&&代表一个右值引用。
    通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用。

- 引用折叠(reference collapsing)
https://en.cppreference.com/w/cpp/language/reference.html#Reference_collapsing

    表达式	折叠结果
    T& &	T&
    T& &&	T&
    T&& &	T&
    T&& &&	T&&
    只有当间接创建引用的引用时才会发生引用折叠，主要发生在：
        模板类型推导
        typedef 或 using 别名
        decltype 表达式
        auto 类型推导

    前向引用：
        语法形式：T&&(T 是模板参数) / auto&&
        绑定能力：可绑定左值（折叠为左值引用）、右值（保持右值引用）；
        底层依赖：C++11 引用折叠规则（& + && = &、&& + && = &&）。
    非前向引用的情况（仅普通右值引用）：
        如果没有类型推导，T&& 就是普通右值引用，只能绑定右值，例如：
            void func(int&& x) {}  // 无类型推导，T=int，func的参数是普通右值引用

- 数组
https://en.cppreference.com/w/cpp/language/array.html

- 参数与返回值
In a function call, the expressions passed at the call site are the function’s arguments(形参).
The arguments are used to initialize the function’s parameters(实参).
The distinction between arguments and parameters is important, because parameters are lvalues, but the arguments with which they are initialized may be rvalues or lvalues.

- 调用规则
https://en.wikipedia.org/wiki/X86_calling_conventions

- 构造函数与析构函数
- 默认构造函数
- copy constructor与copy assignment operator
- move constructor与move assignment operator
- new与delete(new operator, operator new, placement new, delete同理)

- 关键字
https://en.cppreference.com/w/cpp/keyword

- 初始化
https://en.cppreference.com/w/cpp/language/initialization

- std::move与std::forward
https://en.cppreference.com/w/cpp/utility/move.html
First, don’t declare objects const if you want to be able to move from them. Move requests on const objects are silently transformed into copy operations. Second, std::move not only doesn’t actually move anything, it doesn’t even guarantee that the object it’s casting will be eligible to be moved. The only thing you know for sure about the result of applying std::move to an object is that it’s an rvalue.
https://en.cppreference.com/w/cpp/utility/forward.html
The story for std::forward is similar to that for std::move, but whereas std::move unconditionally casts its argument to an rvalue, std::forward does it only under certain conditions. std::forward is a conditional cast.
• std::move performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything.
• std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.
• Neither std::move nor std::forward do anything at runtime.

== lifetime与temporary-object
https://en.cppreference.com/w/cpp/language/lifetime.html
https://en.cppreference.com/w/cpp/language/lifetime.html#Temporary_object_lifetime
https://eel.is/c++draft/class.temporary
《More Effective C++》Item 19: Understand the origin of temporary objects.
https://abseil.io/tips/5
const-reference与temporary-object:
https://www.zhihu.com/question/1917694144702318568/answer/1925943163090081252
https://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object
https://forum.qt.io/topic/160462/optimizing-the-for-loop-with-std-find_if-causes-an-unexpected-crash-during-runtime
https://stackoverflow.com/questions/39718268/why-do-const-references-extend-the-lifetime-of-rvalues

[source, cpp]
----
#include <iostream>
#include <vector>
#include <algorithm>

class Trace {
public:
    Trace(const char* name) : name(name) {
        std::cout << "Construct: " << name << " (" << this << ")" << std::endl;
    }
    
    // 需要显式定义拷贝构造函数
    Trace(const Trace& other) : name(other.name) {
        std::cout << "Copy Construct: " << name << " (" << this << ")" << std::endl;
    }
    
    // 移动构造函数
    Trace(Trace&& other) noexcept : name(other.name) {
        std::cout << "Move Construct: " << name << " (" << this << ")" << std::endl;
        other.name = "(moved)";
    }
    
    ~Trace() {
        std::cout << "Destruct: " << name << " (" << this << ")" << std::endl;
    }
    
    // 允许拷贝赋值和移动赋值
    Trace& operator=(const Trace&) = default;
    Trace& operator=(Trace&&) = default;
    
    const char* getName() const { return name; }
    
private:
    const char* name;
};

// 返回临时对象的函数
Trace getTemp() {
    return Trace("FunctionTemp");  // 这里可能涉及拷贝消除
}

void processTrace(Trace t) {
    std::cout << "Processing: " << t.getName() << std::endl;
}

void proveLifetime() {
    std::cout << "=== 证明1: 函数返回的临时对象 ===" << std::endl;
    
    // 临时对象在完整表达式结束时销毁
    std::cout << getTemp().getName() << std::endl;
	std::cout << "--- 在这之前就销毁了 ---" << std::endl;
	std::cout << "--- 完整表达式结束 ---" << std::endl;
}

void multipleTemporaries() {
    std::cout << "\n=== 证明2: 多个临时对象 ===" << std::endl;
    
    std::cout << "Before expression" << std::endl;
    processTrace(Trace("First"));
    std::cout << "After expression" << std::endl;
}

void compareWithReference() {
    std::cout << "\n=== 证明3: 与引用绑定对比 ===" << std::endl;
    
    // 情况1: 直接使用临时对象
    std::cout << "Case 1 - Direct temporary:" << std::endl;
    std::cout << Trace("Direct").getName() << std::endl;
    std::cout << "---" << std::endl;
    
    // 情况2: 绑定到const引用（生命周期延长）
    std::cout << "Case 2 - Const reference:" << std::endl;
    const Trace& ref = Trace("Referenced");
    std::cout << "Reference: " << ref.getName() << std::endl;
    std::cout << "Before scope end" << std::endl;
} // 引用离开作用域，临时对象在这里销毁

void stlAlgorithmTemporaries() {
    std::cout << "\n=== 证明4: STL算法中的临时对象 ===" << std::endl;
    
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    std::cout << "Before find_if" << std::endl;
    
    // 注意：这里lambda中创建临时对象
    auto it = std::find_if(vec.begin(), vec.end(), 
                          [](int x) {
        Trace temp("LambdaTemp");  // 临时对象在每次lambda调用时创建
        std::cout << "  Checking value: " << x << std::endl;
        return x > 3;
    }); // lambda中的临时对象在这里销毁
    
    std::cout << "After find_if" << std::endl;
}

void complexExpression() {
    std::cout << "\n=== 证明5: 复杂表达式 ===" << std::endl;
    
    auto processValue = [](Trace t) -> int {
        std::cout << "  In processValue: " << t.getName() << std::endl;
        return 1;
    };
    
    std::cout << "Start complex expression" << std::endl;
    
    // 复杂表达式中的多个临时对象
    int result = processValue(Trace("A")) + processValue(Trace("B"));
    std::cout << "Result: " << result << std::endl;
    
    std::cout << "End complex expression" << std::endl;
}

int main() {
    std::cout << "=== 临时对象生命周期演示 ===\n" << std::endl;
    
    proveLifetime();
    multipleTemporaries(); 
    compareWithReference();
    stlAlgorithmTemporaries();
    complexExpression();
    
    std::cout << "\n=== 演示结束 ===" << std::endl;
    return 0;
}
----

== 机器级表示与汇编嵌入
- 《CSAPP》chapter3

- https://en.cppreference.com/w/cpp/language/asm
- https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html
- https://clang.llvm.org/compatibility.html#inline-asm

== object-oriented
- 封装

- 继承

    继承(非多态继承 多态继承)
    多重继承
    虚拟继承
    参考《Inside the C++ Model Object》3.4

- 多态

- Inside the C++ Model Object

    g++ -fdump-lang-class  xyz.cpp
    clang -Xclang -fdump-record-layouts xyz.cpp
    visual studio: 编译选项 /d1reportSingleClassLayout<类名> 或者 /d1reportAllClassLayout(所有类相关布局)

== template
https://en.cppreference.com/w/cpp/language/templates
https://zhuanlan.zhihu.com/p/87917516

== STL
- container
https://en.cppreference.com/w/cpp/container

- iterator
https://en.cppreference.com/w/cpp/iterator
invalidation(失效): https://en.cppreference.com/w/cpp/container.html#Iterator_invalidation

- algorithm
https://en.cppreference.com/w/cpp/algorithm

- adaptor
容器适配器: https://en.cppreference.com/w/cpp/container
迭代器适配器: https://en.cppreference.com/w/cpp/iterator
函数适配器: https://en.cppreference.com/w/cpp/utility/functional

- functor
https://en.cppreference.com/w/cpp/utility/functional

- allocator
https://en.cppreference.com/w/cpp/memory/allocator

- 线程安全
https://en.cppreference.com/w/cpp/container.html#Thread_safety

== C++11
https://en.cppreference.com/w/cpp/11

== C++14
https://en.cppreference.com/w/cpp/14

== C++17
https://en.cppreference.com/w/cpp/17

== C++20
https://en.cppreference.com/w/cpp/20

== C++23
https://en.cppreference.com/w/cpp/23

== C++26
https://en.cppreference.com/w/cpp/26

== 并发
=== 线程
- https://en.cppreference.com/w/cpp/thread
- link:../concurrency/concurrency/thread.asc[《thread》]

=== 协程
- https://en.cppreference.com/w/cpp/language/coroutines
- link:../concurrency/concurrency/coroutine.asc[《coroutine》]

== 标准库与运行时库

    libstdc++ (默认编译器 GCC)
        https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3
    libc++    (默认编译器 Clang)
        https://github.com/llvm/llvm-project/tree/main/libcxx/src

    linux: glibc（GNU C Library）
        https://elixir.bootlin.com/glibc
        https://github.com/bminor/glibc/
    macOS: Apple自己开发的libSystem（其基础是Darwin的Libc）
    win: MSVCRT

== 工程实践
- link:cpp-convention.md[《cpp-convention》]

== 代码工具
understand
https://github.com/bootlin/elixir

== 性能优化
https://www.zhihu.com/question/23185359
https://github.com/MattPD/cpplinks/blob/master/performance.tools.md

== 库与框架
=== 内存管理
https://github.com/ivmai/bdwgc

== 试验特性(Experimental C/C++ Features)
https://en.cppreference.com/w/cpp/experimental.html
https://en.cppreference.com/w/c/experimental.html

== 实现
=== shared_ptr
https://github.com/llvm/llvm-project/blob/main/libcxx/include/__memory/shared_ptr.h

boost:
https://github.com/boostorg/smart_ptr/blob/develop/include/boost/smart_ptr/atomic_shared_ptr.hpp
https://github.com/boostorg/smart_ptr/blob/develop/include/boost/smart_ptr/shared_ptr.hpp

=== std::move()
[source, cpp]
.https://github.com/microsoft/STL/blob/main/stl/inc/type_traits
----
_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
----
即先使用 remove_reference_t<T> 去掉所有引用，再添加右值引用 &&。

remove_reference_t<T>:
[source, cpp]
.https://github.com/microsoft/STL/blob/main/stl/inc/xtr1common
----
_EXPORT_STD template <class _Ty>
struct _NO_SPECIALIZATIONS_OF_TYPE_TRAITS remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

_EXPORT_STD template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;
----

=== std::forward()
[source, cpp]
.https://github.com/microsoft/STL/blob/main/stl/inc/type_traits
----
_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

_EXPORT_STD template <class _Ty>
_NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}
----
forward(remove_reference_t<_Ty>& _Arg) 处理左值引用
forward(remove_reference_t<_Ty>&& _Arg) 处理右值引用
通过引用折叠，保持参数的原始值类别（左值/右值）在转发过程中不丢失。

== 参考
https://en.cppreference.com
https://eel.is/c++draft/
https://github.com/MattPD/cpplinks
https://github.com/fffaraz/awesome-cpp
https://github.com/rigtorp/awesome-modern-cpp
