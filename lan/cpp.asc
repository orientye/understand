= C++
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== history
https://en.cppreference.com/w/cpp/language/history

== c
https://en.cppreference.com/w/c

== cpp
https://en.cppreference.com/w/cpp

== 变量与函数
- 类型
https://en.cppreference.com/w/cpp/language/type
https://en.cppreference.com/w/cpp/types 

- 值
https://en.cppreference.com/w/cpp/language/value_category

          expression
            /    \
        glvalue   rvalue
          /  \    /   \
    lvalue   xvalue   prvalue

- 运算 (eg. sizeof, &)

- 指针变量

- 引用
https://en.cppreference.com/w/cpp/language/reference
左值引用、右值引用、前向引用
Universal Reference 是 Scott Meyers 在《Effective Modern C++》中引入的通俗名称，因其形象而被广泛使用，标准术语是 Forwarding Reference。

- 数组

- 参数与返回值
- 调用规则
https://en.wikipedia.org/wiki/X86_calling_conventions
- 构造函数与析构函数
- 默认构造函数
- copy constructor与copy assignment operator
- move constructor与move assignment operator
- new与delete(new operator, operator new, placement new, delete同理)

- 关键字
https://en.cppreference.com/w/cpp/keyword (eg. const, volatile)

- 初始化
https://en.cppreference.com/w/cpp/language/initialization

== lifetime与temporary-object
https://en.cppreference.com/w/cpp/language/lifetime.html
https://eel.is/c++draft/class.temporary
《More Effective C++》Item 19: Understand the origin of temporary objects.
https://abseil.io/tips/5
const-reference与temporary-object:
https://www.zhihu.com/question/1917694144702318568/answer/1925943163090081252
https://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object
https://forum.qt.io/topic/160462/optimizing-the-for-loop-with-std-find_if-causes-an-unexpected-crash-during-runtime
https://stackoverflow.com/questions/39718268/why-do-const-references-extend-the-lifetime-of-rvalues

[source, cpp]
----
#include <iostream>
#include <vector>
#include <algorithm>

class Trace {
public:
    Trace(const char* name) : name(name) {
        std::cout << "Construct: " << name << " (" << this << ")" << std::endl;
    }
    
    // 需要显式定义拷贝构造函数
    Trace(const Trace& other) : name(other.name) {
        std::cout << "Copy Construct: " << name << " (" << this << ")" << std::endl;
    }
    
    // 移动构造函数
    Trace(Trace&& other) noexcept : name(other.name) {
        std::cout << "Move Construct: " << name << " (" << this << ")" << std::endl;
        other.name = "(moved)";
    }
    
    ~Trace() {
        std::cout << "Destruct: " << name << " (" << this << ")" << std::endl;
    }
    
    // 允许拷贝赋值和移动赋值
    Trace& operator=(const Trace&) = default;
    Trace& operator=(Trace&&) = default;
    
    const char* getName() const { return name; }
    
private:
    const char* name;
};

// 返回临时对象的函数
Trace getTemp() {
    return Trace("FunctionTemp");  // 这里可能涉及拷贝消除
}

void processTrace(Trace t) {
    std::cout << "Processing: " << t.getName() << std::endl;
}

void proveLifetime() {
    std::cout << "=== 证明1: 函数返回的临时对象 ===" << std::endl;
    
    // 临时对象在完整表达式结束时销毁
    std::cout << getTemp().getName() << std::endl;
	std::cout << "--- 在这之前就销毁了 ---" << std::endl;
	std::cout << "--- 完整表达式结束 ---" << std::endl;
}

void multipleTemporaries() {
    std::cout << "\n=== 证明2: 多个临时对象 ===" << std::endl;
    
    std::cout << "Before expression" << std::endl;
    processTrace(Trace("First"));
    std::cout << "After expression" << std::endl;
}

void compareWithReference() {
    std::cout << "\n=== 证明3: 与引用绑定对比 ===" << std::endl;
    
    // 情况1: 直接使用临时对象
    std::cout << "Case 1 - Direct temporary:" << std::endl;
    std::cout << Trace("Direct").getName() << std::endl;
    std::cout << "---" << std::endl;
    
    // 情况2: 绑定到const引用（生命周期延长）
    std::cout << "Case 2 - Const reference:" << std::endl;
    const Trace& ref = Trace("Referenced");
    std::cout << "Reference: " << ref.getName() << std::endl;
    std::cout << "Before scope end" << std::endl;
} // 引用离开作用域，临时对象在这里销毁

void stlAlgorithmTemporaries() {
    std::cout << "\n=== 证明4: STL算法中的临时对象 ===" << std::endl;
    
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    std::cout << "Before find_if" << std::endl;
    
    // 注意：这里lambda中创建临时对象
    auto it = std::find_if(vec.begin(), vec.end(), 
                          [](int x) {
        Trace temp("LambdaTemp");  // 临时对象在每次lambda调用时创建
        std::cout << "  Checking value: " << x << std::endl;
        return x > 3;
    }); // lambda中的临时对象在这里销毁
    
    std::cout << "After find_if" << std::endl;
}

void complexExpression() {
    std::cout << "\n=== 证明5: 复杂表达式 ===" << std::endl;
    
    auto processValue = [](Trace t) -> int {
        std::cout << "  In processValue: " << t.getName() << std::endl;
        return 1;
    };
    
    std::cout << "Start complex expression" << std::endl;
    
    // 复杂表达式中的多个临时对象
    int result = processValue(Trace("A")) + processValue(Trace("B"));
    std::cout << "Result: " << result << std::endl;
    
    std::cout << "End complex expression" << std::endl;
}

int main() {
    std::cout << "=== 临时对象生命周期演示 ===\n" << std::endl;
    
    proveLifetime();
    multipleTemporaries(); 
    compareWithReference();
    stlAlgorithmTemporaries();
    complexExpression();
    
    std::cout << "\n=== 演示结束 ===" << std::endl;
    return 0;
}
----

== 机器级表示与汇编嵌入
- 《CSAPP》chapter3

- https://en.cppreference.com/w/cpp/language/asm
- https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html
- https://clang.llvm.org/compatibility.html#inline-asm

== object-oriented
- 封装

- 继承

    继承(非多态继承 多态继承)
    多重继承
    虚拟继承
    参考《Inside the C++ Model Object》3.4

- 多态

- Inside the C++ Model Object

    g++ -fdump-lang-class  xyz.cpp
    clang -Xclang -fdump-record-layouts xyz.cpp
    visual studio: 编译选项 /d1reportSingleClassLayout<类名> 或者 /d1reportAllClassLayout(所有类相关布局)

== template
https://en.cppreference.com/w/cpp/language/templates
https://zhuanlan.zhihu.com/p/87917516

== STL
- container
https://en.cppreference.com/w/cpp/container

- iterator
https://en.cppreference.com/w/cpp/iterator
invalidation(失效): https://en.cppreference.com/w/cpp/container.html#Iterator_invalidation

- algorithm
https://en.cppreference.com/w/cpp/algorithm

- adaptor
容器适配器: https://en.cppreference.com/w/cpp/container
迭代器适配器: https://en.cppreference.com/w/cpp/iterator
函数适配器: https://en.cppreference.com/w/cpp/utility/functional

- functor
https://en.cppreference.com/w/cpp/utility/functional

- allocator
https://en.cppreference.com/w/cpp/memory/allocator

- 线程安全
https://en.cppreference.com/w/cpp/container.html#Thread_safety

== C++11
https://en.cppreference.com/w/cpp/11

== C++14
https://en.cppreference.com/w/cpp/14

== C++17
https://en.cppreference.com/w/cpp/17

== C++20
https://en.cppreference.com/w/cpp/20

== C++23
https://en.cppreference.com/w/cpp/23

== 并发
=== 线程
- https://en.cppreference.com/w/cpp/thread
- link:../concurrency/concurrency/thread.asc[《thread》]

=== 协程
- https://en.cppreference.com/w/cpp/language/coroutines
- link:../concurrency/concurrency/coroutine.asc[《coroutine》]

== 编译 链接 调试
- 编译器

    gcc
    clang

- 标准库与运行时库

    glibc（GNU C Library）
        在macOS上，使用的是Apple自己开发的libSystem（其基础是Darwin的Libc）
        在Windows上，使用MSVCRT
        https://elixir.bootlin.com/glibc
        https://github.com/bminor/glibc/
    
    libstdc++ (默认编译器 GCC)
        https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3
    libc++    (默认编译器 Clang)
        https://github.com/llvm/llvm-project/tree/main/libcxx/src

- 链接

    静态链接
    动态链接

- 调试器

    gdb
    lldb

== 工程实践
- link:cpp-convention.md[《cpp-convention》]

== 代码工具
understand
https://github.com/bootlin/elixir

== 性能优化
https://www.zhihu.com/question/23185359
https://github.com/MattPD/cpplinks/blob/master/performance.tools.md

== 库与框架
=== 内存管理
https://github.com/ivmai/bdwgc

== 试验特性(Experimental C/C++ Features)
https://en.cppreference.com/w/cpp/experimental.html
https://en.cppreference.com/w/c/experimental.html

== 实现
=== shared_ptr
https://github.com/llvm/llvm-project/blob/main/libcxx/include/__memory/shared_ptr.h

boost:
https://github.com/boostorg/smart_ptr/blob/develop/include/boost/smart_ptr/atomic_shared_ptr.hpp
https://github.com/boostorg/smart_ptr/blob/develop/include/boost/smart_ptr/shared_ptr.hpp

== 参考
https://en.cppreference.com
https://eel.is/c++draft/
https://github.com/MattPD/cpplinks
https://github.com/fffaraz/awesome-cpp
https://github.com/rigtorp/awesome-modern-cpp
