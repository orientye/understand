= lua
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:hardbreaks-option:
<<<

== 说明
如果没有特别声明，以下代码>=Lua 5.4.0，基于: https://github.com/lua/lua

== 值与类型
8种基本类型: nil, boolean, number, string, table, function, userdata, and thread.

Nil is a marker type having only one value, also called nil.

Boolean values are the usual true and false.

Numbers are double-precision floating-point numbers, corresponding to the type double in C, but it is easy to compile Lua using float or long instead. (Several games consoles and smaller machines lack hardware support for double.) 

Strings are arrays of bytes with an explicit size, and so can contain arbitrary binary data, including embedded zeros.

Tables are associative arrays, which can be indexed by any value (exceptnil) and can hold any value.
Tables are the main in fact, the only data-structuring mechanism in Lua.
in Lua 5.0, tables are implemented as hybrid data structures: they contain a hash part and an array part

Functions are either Lua functions or C functions written according to a protocol for interfacing with the Lua virtual machine.

Userdata are essentially pointers to user memory blocks, and come in two flavors: heavy, whose blocks are allocated by Lua and are subject to garbage collection, and light, whose blocks are allocated and freed by the user.

threads represent coroutines.

注意:
Values of all types are first-class values: we can store them in global variables, local variables and table fields, pass them as arguments to functions, return them from functions, etc.
types are attached to values rather than to variables.

== 协程
=== 概念
⦁ Since version 5.0, Lua implements asymmetric coroutines (also called semisymmetric coroutines or semi-coroutines)

⦁ Conceptually, each coroutine has its own stack. (Concretely, each coroutine has two stacks, but we can consider them as a single abstract stack.)

⦁ Coroutines in Lua are stackful, in the sense that we can suspend a coroutine from inside any number of nested calls. The interpreter simply puts aside the entire stack for later use and continues running on another stack. A program can restart any suspended coroutine at will. The garbage collector collects stacks whose coroutines are no longer accessible.

⦁ 通过resume/yield函数的参数在协程间传递数据/通信

=== 示例
[source, lua]
----
function foo (a)
    print("foo print", a)
    return coroutine.yield(2 * a)
end
 
co = coroutine.create(function (a , b)
    print("1st in coroutine", a, b)
    local r = foo(a + 1)
     
    print("2nd in coroutine", r)
    local r, s = coroutine.yield(a + b, a - b)
     
    print("3rd in coroutine", r, s)
    return b, "end"
end)

print("main", coroutine.resume(co, 1, 10)) -- true 4
print("main", coroutine.resume(co, "r")) -- true 11 -9
print("main", coroutine.resume(co, "x", "y")) -- true 10 end
print("main", coroutine.resume(co, "x", "y")) -- false cannot resume dead coroutine
----

输出:

    1st in coroutine	1	10
    foo print	2
    main	true	4
    2nd in coroutine	r
    main	true	11	-9
    3rd in coroutine	x	y
    main	true	10	end
    main	false	cannot resume dead coroutine

=== 实现

==== struct lua_State
数据结构，跟虚拟机一样，使用的是lua_State:
[source, c]
.https://github.com/lua/lua/blob/master/lstate.h
----
/*
** 'per thread' state
*/
struct lua_State {
  CommonHeader;
  lu_byte status;
  lu_byte allowhook;
  unsigned short nci;  /* number of items in 'ci' list */
  StkIdRel top;  /* first free slot in the stack */
  global_State *l_G;
  CallInfo *ci;  /* call info for current function */
  StkIdRel stack_last;  /* end of stack (last element + 1) */
  StkIdRel stack;  /* stack base */
  UpVal *openupval;  /* list of open upvalues in this stack */
  StkIdRel tbclist;  /* list of to-be-closed variables */
  GCObject *gclist;
  struct lua_State *twups;  /* list of threads with open upvalues */
  struct lua_longjmp *errorJmp;  /* current error recover point */
  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
  volatile lua_Hook hook;
  ptrdiff_t errfunc;  /* current error handling function (stack index) */
  l_uint32 nCcalls;  /* number of nested (non-yieldable | C)  calls */
  int oldpc;  /* last pc traced */
  int basehookcount;
  int hookcount;
  volatile l_signalT hookmask;
};
----

==== 库函数
[source, c]
.https://github.com/lua/lua/blob/master/lcorolib.c
----
static const luaL_Reg co_funcs[] = {
  {"create", luaB_cocreate},
  {"resume", luaB_coresume},
  {"running", luaB_corunning},
  {"status", luaB_costatus},
  {"wrap", luaB_cowrap},
  {"yield", luaB_yield},
  {"isyieldable", luaB_yieldable},
  {"close", luaB_close},
  {NULL, NULL}
};
----

===== create
[source, c]
.https://github.com/lua/lua/blob/master/lcorolib.c
----
static int luaB_cocreate (lua_State *L) {
  lua_State *NL;
  luaL_checktype(L, 1, LUA_TFUNCTION);
  NL = lua_newthread(L);
  lua_pushvalue(L, 1);  /* move function to top */
  lua_xmove(L, NL, 1);  /* move function from L to NL */
  return 1;
}
----

[source, c]
.https://github.com/lua/lua/blob/master/lstate.c
----
LUA_API lua_State *lua_newthread (lua_State *L) {
  global_State *g = G(L);
  GCObject *o;
  lua_State *L1;
  lua_lock(L);
  luaC_checkGC(L);
  /* create new thread */
  o = luaC_newobjdt(L, LUA_TTHREAD, sizeof(LX), offsetof(LX, l));
  L1 = gco2th(o);
  /* anchor it on L stack */
  setthvalue2s(L, L->top.p, L1);
  api_incr_top(L);
  preinit_thread(L1, g);
  L1->hookmask = L->hookmask;
  L1->basehookcount = L->basehookcount;
  L1->hook = L->hook;
  resethookcount(L1);
  /* initialize L1 extra space */
  memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),
         LUA_EXTRASPACE);
  luai_userstatethread(L, L1);
  stack_init(L1, L);  /* init stack */
  lua_unlock(L);
  return L1;
}
----

===== resume
[source, c]
.https://github.com/lua/lua/blob/master/lcorolib.c
----
static int luaB_coresume (lua_State *L) {
  lua_State *co = getco(L);
  int r;
  r = auxresume(L, co, lua_gettop(L) - 1);
  if (l_unlikely(r < 0)) {
    lua_pushboolean(L, 0);
    lua_insert(L, -2);
    return 2;  /* return false + error message */
  }
  else {
    lua_pushboolean(L, 1);
    lua_insert(L, -(r + 1));
    return r + 1;  /* return true + 'resume' returns */
  }
}
----

===== yield
[source, c]
.https://github.com/lua/lua/blob/master/lcorolib.c
----
static int luaB_yield (lua_State *L) {
  return lua_yield(L, lua_gettop(L));
}
----

[source, c]
.https://github.com/lua/lua/blob/master/lua.h
----
#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
----

[source, c]
.https://github.com/lua/lua/blob/master/ldo.c
----
LUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,
                        lua_KFunction k) {
  CallInfo *ci;
  luai_userstateyield(L, nresults);
  lua_lock(L);
  ci = L->ci;
  api_checknelems(L, nresults);
  if (l_unlikely(!yieldable(L))) {
    if (L != G(L)->mainthread)
      luaG_runerror(L, "attempt to yield across a C-call boundary");
    else
      luaG_runerror(L, "attempt to yield from outside a coroutine");
  }
  L->status = LUA_YIELD;
  ci->u2.nyield = nresults;  /* save number of results */
  if (isLua(ci)) {  /* inside a hook? */
    lua_assert(!isLuacode(ci));
    api_check(L, nresults == 0, "hooks cannot yield values");
    api_check(L, k == NULL, "hooks cannot continue after yielding");
  }
  else {
    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
      ci->u.c.ctx = ctx;  /* save context */
    luaD_throw(L, LUA_YIELD);
  }
  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
  lua_unlock(L);
  return 0;  /* return to 'luaD_hook' */
}
----

== 虚拟机
⦁ Lua runs programs by first compiling them into instructions (“opcodes”) for a virtual machine and then executing those instructions. For each function that Lua compiles it creates a prototype, which contains an array with the opcodes for the function and an array of Lua values (TObjects) with all constants (literal strings and numerals) used by the function.

⦁ Since 1993, when Lua was first released, Lua used a stackbased virtual machine. Since 2003, Lua 5.0, Lua uses a register-based virtual machine. This register-based machine also uses a stack, for allocating activation records, wherein the registers live. When Lua enters a function, it preallocates from the stack an activation record large enough to hold all the function registers. All local variables are allocated in registers. As a consequence, access to local variables is specially efficient.

== 应用

=== 与C/C++的交互

=== 热更新
⦁ 基本思想
https://blog.csdn.net/xufeng0991/article/details/52473602
https://github.com/lichuang/Lua-Source-Internal/blob/master/doc/ch06-%E7%83%AD%E6%9B%B4%E6%96%B0.md

https://blog.codingnow.com/2016/11/lua_update.html
https://github.com/cloudwu/skynet/wiki/Snax#%E7%83%AD%E6%9B%B4%E6%96%B0-hotfix

⦁ _G, _ENV

⦁https://stackoverflow.com/questions/35910099/how-special-is-the-global-variable-g

== Lua JIT
https://github.com/LuaJIT/LuaJIT

vs. v8 benchmark:
https://programming-language-benchmarks.vercel.app/lua-vs-javascript

注意事项:
在64位系统(包括x86_64)上，LuaJIT垃圾回收器能管理的内存最大只有2GB一直为社区所诟病。所幸LuaJIT官方在2016年引入了GC64模式，这使得这个上限可以达到128TB(也就是低47位的地址空间)，这也就意味着可以不受限制的跑在当今主流的个人电脑和服务器上了:
https://blog.openresty.com/en/luajit-gc64-mode/
https://blog.openresty.com.cn/cn/luajit-gc64-mode/

== 优化
https://www.lua.org/gems/sample.pdf

== dev
https://github.com/LuaLS/lua-language-server
https://github.com/mpeterv/luacheck
https://github.com/luarocks/luarocks

== project
https://github.com/LewisJEllis/awesome-lua

== 参考
https://github.com/lua/lua