= MYSQL-convention

:revnumber: 1.0.0
:author: orient
:homepage: http://orientye.com
:toc:

== 基础规范
- 表存储引擎必须使用InnoDB

- 表字符集默认使用utf8, 必要时候使用utf8mb4(表情符号)

- 禁止使用存储过程, 视图, 触发器, event, 外键

- 禁止在数据库中存储大文件, 例如照片, 可以将大文件存储在对象存储系统, 数据库中存储路径

- 禁止在线上环境做数据库压力测试

- 测试, 开发, 线上数据库环境必须隔离

== 命名规范
- 库名, 表名, 列名必须用小写, 采用下划线分隔表名、字段名必须使用小写字母或数字, 禁止出现数字开头, 禁止两个下划线中间只出现数字, 长度不要超过32字符

- 禁用保留字, 如 desc、range、match、delayed 等, 请参考MySQL官方保留字

- 库备份必须以 bak 为前缀, 以日期为后缀

- 从库必须以-s 为后缀, 备库必须以-ss 为后缀

- 库名与应用名称尽量一致

- 表名不使用复数名词。
    
    说明:表名应该仅仅表示表里面的实体内容, 不应该表示实体数量, 对应于 DO 类名也是单数形式, 符合表达习惯。

- 表达是与否概念的字段, 必须使用 is_xxx 的方式命名, 数据类型是 unsigned tinyint ( 1表示是, 0 表示否)。

    说明:任何字段如果为非负数, 必须是 unsigned。正例:表达逻辑删除的字段名 is_deleted, 1 表示删除, 0 表示未删除。

- 主键索引名为 pk_字段名; 唯一索引名为 uk_字段名; 普通索引名则为 idx_字段名。 
    
    说明:pk即 primary key; uk 即 unique key; idx 即 index。

== 库表设计规范
- 单实例表个数必须控制在 2000 个以内

- 单表分表个数必须控制在 1024 个以内

- 【推荐】单表行数超过 500 万行或者单表容量超过 2GB, 才推荐进行分库分表。 

    说明:如果预计三年后的数据量根本达不到这个级别, 请不要在创建表时就分库分表。
- 【强制】表必备三字段:id, gmt_create, gmt_modified。 

    说明:其中 id 必为主键, 类型为unsigned int/unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型, 前者现在时表示主动创建, 后者过去分词表示被动更新。

- 建议将大字段, 访问频度低的字段拆分到单独的表中存储, 分离冷热数据

- 【参考】合适的字符存储长度, 不但节约数据库表空间、节约索引存储, 更重要的是提升检索速度。 

    正例:如无符号值可以避免误存负数, 且扩大了表示范围。

- 【推荐】字段允许适当冗余, 以提高查询性能, 但必须考虑数据一致。

    冗余字段应遵循:
    1)不是频繁修改的字段。2)不是 varchar 超长字段, 更不能是 text 字段。
    正例:商品类目名称使用频率高, 字段长度短, 名称基本一成不变, 可在相关联的表中冗余存储类目名称, 避免关联查询。

== 列/字段设计规范
- 必须把字段定义为 NOT NULL 并设默认值

    解读：
    （1）NULL 的列使用索引, 索引统计, 值都更加复杂, MySQL 更难优化
    （2）NULL 需要更多的存储空间
    （3）NULL 只能采用 IS NULL 或者 IS NOT NULL, 而在=/!=/in/not in 时有大坑

- 据业务区分使用 tiny/small/medium/int/bigint, 分别会占用 1/2/3/4/8 字节

- 小数类型为 decimal, 禁止使用 float 和 double。

    说明:float 和 double 在存储的时候, 存在精度损失的问题, 很可能在值的比较时, 得到不正确的结果。如果存储的数据范围超过decimal 的范围, 建议将数据拆成整数和小数分开存储。

- 根据业务区分使用 char/varchar：字段长度固定, 或者长度近似的业务场景适合使用 char, 能够减少碎片, 查询性能高；字段长度相差较大, 或者更新较少的业务场景, 适合使用 varchar, 能够减少空间varchar 是可变长字符串, 不预先分配存储空间, 长度不要超过 5000, 如果存储长度大于此值, 定义字段类型为 text, 独立出一张表用主键来对应, 避免影响其它字段索引效率

- 根据业务区分使用 datetime/timestamp 

    解读：
    a）DATETIME默认值为null；TIMESTAMP的字段默认不为空, 为当前时间(CURRENT_TIMESTAMP), 如果不做特殊处理, 并且 update 语句中没有指定该列的更新值, 则默认更新为当前时间。这个区别就解释了为什么平时我们都不用可以管这个字段就能自动更新了, 因为多数时候用的是 timestamp；datetime不会有自动更新当前时间的机制, 需要在上层手动更新该字段
    b）DATETIME使用8字节的存储空间, TIMESTAMP的存储空间为4字节。https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html
    c）两者的存储方式不一样 , 对于 TIMESTAMP, 它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时, 将其又转化为客户端当前时区进行返回。而对于DATETIME, 不做任何改变, 基本上是原样输入和输出。
    d）两者所能存储的时间范围不一样
    timestamp所能存储的时间范围为 ： ’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’；
    datetime所能存储的时间范围为 ： ’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。

- 使用 INT UNSIGNED 存储 IPv4, 不要用 char(15)
- 使用 varchar(20)存储手机号, 不要使用整数

    解读：
    （1）牵扯到国家代号, 可能出现+/-/()等字符, 例如+86
    （2）手机号不会用来做数学运算
    （3）varchar 可以模糊查询, 例如 like ‘138%’

- 使用 TINYINT 来代替 ENUM

    解读：ENUM 增加新值要进行 DDL 操作

== 索引规范

- 单张表索引数量建议控制在5个以内

    解读：

    （1）互联网高并发业务, 太多索引会影响写性能
    （2）生成执行计划时, 索引太多会降低性能, 并可能选择不到最优索引
    （3）异常复杂的查询需求, 可以选择 ES 等更为适合的方式存储

- 不建议在频繁更新的字段上建立索引

- 组合索引字段数不建议超过 5 个

    解读：如果 5 个字段还不能极大缩小 row 范围, 八成是设计有问题

- 非必要不要进行 JOIN 查询, 如果要进行 JOIN 查询, 被 JOIN 的字段必须类型相同, 并建立索引

    解读：踩过因为 JOIN 字段类型不一致, 而导致全表扫描的坑么？

- 理解组合索引最左前缀原则, 避免重复建设索引, 如果建立了(a,b,c), 相当于建立了(a), (a,b), (a,b,c)

- 业务上具有唯一特性的字段, 即使是多个字段的组合, 也必须建成唯一索引。 

    说明:不要以为唯一索引影响了 insert 速度, 这个速度损耗可以忽略, 但提高查找速度是明显的;另外, 即使在应用层做了非常完善的校验控制, 只要没有唯一索引, 根据墨菲定律, 必然有脏数据产生。

- 超过三个表禁止 join。需要 join 的字段, 数据类型必须绝对一致;多表关联查询时,  保证被关联的字段需要有索引。

    说明:即使双表 join 也要注意表索引、SQL 性能。 

- 在 varchar 字段上建立索引时, 必须指定索引长度, 没必要对全字段建立索引, 根据 、实际文本区分度决定索引长度即可。 说明:索引的长度与区分度是一对矛盾体, 一般对字符串类型数据, 长度为 20 的索引, 区分度会高达 90%以上, 可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

- 页面搜索严禁左模糊或者全模糊, 如果需要请走搜索引擎来解决。 说明:索引文件具有B-Tree 的最左前缀匹配特性, 如果左边的值未确定, 那么无法使用此索引。

- 【推荐】如果有 order by 的场景, 请注意利用索引的有序性。order by 最后的字段是组合索引的一部分, 并且放在索引组合顺序的最后, 避免出现 file_sort 的情况, 影响查询性能。 正例:where a=? and b=? order by c; 索引:a_b_c 反例:索引中有范围查找, 那么索引有序性无法利用, 如:WHERE a>10 ORDER BY b; 索引 a_b 无法排序。


- 【推荐】利用覆盖索引来进行查询操作, 避免回表。

- 【推荐】利用延迟关联或者子查询优化超多分页场景。说明:MySQL 并不是跳过 offset 行, 而是取 offset+N 行, 然后返回放弃前 offset 行, 返回 N 行, 那当 offset 特别大的时候, 
效率就非常的低下, 要么控制返回的总页数, 要么对超过 特定阈值的页数进行 SQL 改写。SELECT a.* FROM 表 1 a, (select id from
正例:先快速定位需要获取的 id 段, 然后再关联:表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

- 【推荐】SQL 性能优化的目标:至少要达到 range 级别, 要求是 ref 级别, 如果可以是consts 最好。  说明:
 1)consts 单表中最多只有一个匹配行(主键或者唯一索引), 在优化
阶段即可读取到数据。 2)ref 指的是使用普通的索引(normal index)。3)range 对索引进行范
围检索。  反例:explain 表的结果, type=index, 索引物理文件全扫描, 速度非常慢, 这
个 index 级 别比较 range 还低, 与全表扫描是小巫见大巫。

- 【推荐】建组合索引的时候, 区分度最高的在最左边。正例:如果 where a=? and b=? , a 列的几乎接近于唯一值, 那么只需要单建 idx_a 索引即 可。 说明:存在非等号和等号混合判断条件时, 在建索引时, 请把等号条件的列前置。如:where a>? and b=? 那么即使 a的区分度更高, 也必须把 b 放在索引的最前列。

- 【推荐】防止因字段类型不同造成的隐式转换, 导致索引失效。

- 【参考】创建索引时避免有如下极端误解: 

    1)认为一个查询就需要建一个索引。
    2)认为索引会消耗空间、严重拖慢更新和新增速度。 3)抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

== SQL 规范

- 不要使用 count(列名)或 count(常量)来替代 count(*), count(*)是 SQL92 定义的 标准统计行数的语法, 跟数据库无关, 跟 NULL 和非 NULL 无关。 说明:count(*)会统计值为NULL 的行, 而 count(列名)不会统计此列为 NULL 值的行。 

- count(distinct col) 计算该列除 NULL 之外的不重复行数, 注意 count(distinct col1, col2)如果其中一列全为 NULL, 那么即使另一列有不同的值, 也返回为 0。

- 当某一列的值全是 NULL 时, count(col)的返回结果为 0, 但 sum(col)的返回结果为NULL, 因此使用 sum()时需注意 NPE 问题。 正例:可以使用如下方式来避免 sum 的 NPE问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;

- 使用 ISNULL()来判断是否为 NULL 值。 说明:NULL 与任何值的直接比较都为 NULL。

    1) NULL<>NULL 的返回结果是 NULL, 而不是 false。 
    2) NULL=NULL 的返回结果是 NULL, 而不是 true。
    3) NULL<>1 的返回结果是 NULL, 而不是 true。 

- 在代码中写分页查询逻辑时, 若 count 为 0 应直接返回, 避免执行后面的分页语句。

- 数据订正时, 删除和修改记录时, 要先 select, 避免出现误删除, 确认无误才能执行更
新语句。

- 【推荐】in 操作能避免则避免, 若实在避免不了, 需要仔细评估 in 后边的集合元素数
量, 控制在 1000 个之内。

- 【参考】TRUNCATE TABLE 比 DELETE 速度快, 且使用的系统和事务日志资源少, 但TRUNCATE 无事务且不触发 trigger, 有可能造成事故, 故不建议在开发代码中使用此语句。说明:TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。

- 禁止使用 select *, 只获取必要字段

    解读：
    （1）select *会增加 cpu/io/内存/带宽的消耗
    （2）指定字段能有效利用索引覆盖
    （3）指定字段查询, 在表结构变更时, 能保证对应用程序无影响

- 隐式类型转换会使索引失效, 导致全表扫描

- 禁止在 where 条件列使用函数或者表达式(导致不能命中索引, 全表扫描)

- 禁止负向查询以及%开头的模糊查询(导致不能命中索引, 全表扫描)

- 禁止大表 JOIN 和子查询

- 同一个字段上的 OR 必须改写为 IN, IN 的值必须少于 50 个

- 应用程序必须捕获 SQL 异常, 方便定位线上问题

== 操作规范

- 超过 100 万行的批量写(update, delete, insert)操作,  要分批多次进行操作。

    解读：

    （1）大批量操作可能会造成严重的主从延迟
    （2）binlog 格式为 row 格式时会产生大量的日志
    （3）避免产生大事务操作

- 对于大表使用 pt-online-schema-change 修改表结构。

    解读：
    （1）避免大表修改时产生的主从延迟
    （2）避免对表字段进行修改时进行锁表
    （3）pt-online-schema-change 会先建立一个与原表结构相同的新表, 并且在新表上进行表结构的修改, 然后把原表中的数据复制到新表中。

- 禁止为程序使用的账号赋予 super, 遵循权限最小原则。

== 参考
- https://dev.mysql.com/doc/
- 阿里, 58 赶集等规范