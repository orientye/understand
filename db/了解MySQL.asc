= 了解MySQL
:revnumber: 0.0.1
:author: orient
:toc:
:homepage: http://orientye.com

<<<

include::了解MySQL/概览.asc[]

include::了解MySQL/索引.asc[]

include::了解MySQL/事务.asc[]

include::了解MySQL/锁.asc[]

include::了解MySQL/可用性.asc[]

include::了解MySQL/性能.asc[]

include::了解MySQL/SQL.asc[]

include::了解MySQL/备份与恢复.asc[]

include::了解MySQL/安全.asc[]

include::了解MySQL/实战.asc[]

include::了解MySQL/未来趋势.asc[]


锁

●  表锁（MyISAM，Memory，CSV等一些非事务性存储引擎）

●  页锁（BerkeleyDB存储引擎）

●  行锁（Record Lock， Gap Lock， Next-Key Lock）

●  全局锁

●  意向锁

●  其它

●  死锁问题

参考:  https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html

锁-全局锁

●  对整个数据库实例加锁

●  命令: flush tables with read lock(FTWRL)

整个库将会处于制度状态：数据更新语句（增删改），数据定义语句

（建表，修改表结构等）和更新类事务的提交语句

unlock tables

●  典型使用场景：

全库逻辑备份，也就是把整库每个表都select出来存成文本    
缺点：如果是主库备份，业务基本停摆；如果是从库备份，主从延迟；
正确姿势：mysqldump --single-transaction(过程中也用到FTWRL)

锁-表锁

●  两种：表锁，元数据锁（metal data lock, MDL）

        tips：MDL not DML --- DDL is Data Definition Language : it is used to define data structures.For example, with SQL, 
it would be instructions such as create table, alter table, ...; DML is Data Manipulation Language : it is used to manipulate 
data itself.For example, with SQL, it would be instructions such as insert, update, delete, ...

●  表锁

新类事务的提交语句

命令: lock tables … read/write
数据更新语句（增删改），数据定义语句（建表，修改表结构等）和更

unlock tables主动释放或客户端断开时自动释放
对于innodb, 不推荐使用，影响面太大，改成begin和commit;
对于MyISAM等，安排升级换引擎

●  MDL无需显式使用

对表做增删改查，加MDL读锁
对表结构变更操作，加MDL写锁
事务的MDL锁，在语句执行开始时申请，会等到整个事务提交后再释放

锁-意向锁（Intension Locks）

● InnoDB supports multiple granularity locking which permits coexistence of row 
locks and table locks 

indicates that a transaction intends to set a shared lock on individual 

● intention shared lock (IS) 
 
rows in a table

● intention exclusive lock (IX) 
 
individual rows in a table

indicates that that a transaction intends to set an exclusive lock on 

● For example, SELECT ... LOCK IN SHARE MODE sets an IS lock, and SELECT ... 
FOR UPDATE sets an IX lock.

● Before a transaction can acquire a shared lock on a row in a table, it must first 
acquire an IS lock or stronger on the table. Before a transaction can acquire an 
exclusive lock on a row in a table, it must first acquire an IX lock on the table.

● Intention locks do not block anything except full table requests (for example, 
LOCK TABLES ... WRITE). The main purpose of intention locks is to show that 
someone is locking a row, or going to lock a row in the table.

锁-意向锁（Intension Locks）
● why
为了控制在一个事务锁表之后,其他事务的「锁行」行为,所以设置这么一道“关卡”————
每个事务获取行锁时都要先获取对应的意向锁.

每个事务在尝试获取自己需要的行锁时, 会先通过意图锁检查一下表锁的占用情况,再决定是否
继续获得行锁,具体判断规则:如果表X锁被占有,则其他事务尝试获得 IS、IX均会阻塞,也就不能
继续获取行X锁或行S锁了.如果表S锁被占有,则其他事务可以获得IS, 而获得IX会阻塞. 从而阻止
其他事务获得行X锁。

锁-行锁

● 共享锁/读锁 shared (S) lock

        
 

permits the transaction that holds the lock to read a row.

● 排它锁/写锁 exclusive (X) lock
 

permits the transaction that holds the lock to update or delete a row.

锁-Gap Lock & Next-key Lock 

● >=RR

●  Next-Key Lock = Gap Lock + Record Lock 前开后闭

●  For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, 
and DELETE statements, locking depends on whether the statement uses a unique 
index with a unique search condition, or a range-type search condition. For a unique 
index with a unique search condition, InnoDB locks only the index record found, not 
the gap before it. For other search conditions, InnoDB locks the index range scanned, 
using gap locks or next-key locks to block insertions by other sessions into the gaps 
covered by the range.

●  作用：解决幻读

锁-Insert Intension Lock

●  An insert intention lock is a type of gap lock set by 
INSERT operations prior to row insertion

●  This lock signals the intent to insert in such a way that 
multiple transactions inserting into the same index gap 
need not wait for each other if they are not inserting at 
the same position within the gap. Suppose that there are 
index records with values of 4 and 7. Separate 
transactions that attempt to insert values of 5 and 6, 
respectively, each lock the gap between 4 and 7 with 
insert intention locks prior to obtaining the exclusive 
lock on the inserted row, but do not block each other 
because the rows are nonconflicting.

锁-AUTO-INC Locks
● An AUTO-INC lock is a special table-level lock taken by transactions 
inserting into tables with AUTO_INCREMENT columns. In the simplest 
case, if one transaction is inserting values into the table, any other 
transactions must wait to do their own inserts into that table, so that 
rows inserted by the first transaction receive consecutive primary key 
values.

The innodb_autoinc_lock_mode configuration option controls the 
algorithm used for auto-increment locking. It allows you to choose how 
to trade off between predictable sequences of auto-increment values 
and maximum concurrency for insert operations.

锁-其他

●  悲观锁与乐观锁

锁-分析

●  事务的隔离级别？
●  是否为主键？
●  如果不是主键，那么id列上有索引吗？
●  如果有二级索引，那么这个索引是唯一索引吗？
●  主键扫描？唯一键扫描？范围扫描？全表扫描？

锁-死锁

●  超时机制

●  wait-for graph检测机制

●  innodb并不会回滚大部分的错误异常，但死锁除外

高可用

●  备份与恢复

●  复制

●  架构

高可用-备份与恢复

●  备份

热备/在线备份， 冷备/离线备份
逻辑备份，物理备份（裸文件备份）
完全备份，增量备份，日志备份
mysqldump –-single-transaction --master-data?
xtrabackup(推荐)

●  恢复

mysqlbinlog

高可用-复制

●  复制是高性能，高可用，可扩展，灾难恢复，备份(在从库上备份以减轻主库
压力)以及数据仓库等工作的基础

！！复制只能扩展读操作，无法扩展写操作，写操作只能通过分区扩展

●  复制原理

高可用-复制

●  binlog的三种格式

statement（也叫逻辑复制,MySQL 3.23）
row(MySQL 5.1)
mixed

statement的binlog可能会导致主备不一致
row格式主要是占空间
mixed格式会自动判断这条SQL语句是否可能引起主备一致，如果可能

用row, 否则用statement

MYSQL设置为statement不合理，至少要设置为mixed
现在越来越多的场景要求binlog设置为row, 好处很多，例如：恢复数据

5.7.7之前，默认STATEMENT
5.7.7及更高版本中，默认值 ROW
日志格式通过 binlog-format 指定，
如 binlog-format=STATEMENT/ROW/MIXED

●  binlog的两大作用
复制；数据恢复

高可用-复制

●  binlog的刷盘

sync_binlog:
如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制

它缓存的刷新；

如果设置为不为0的值，则表示每sync_binlog次事务，MySQL调用文

件系统的刷新操作刷新binlog到磁盘中。

设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性

能有所影响。也有为了性能设置为100-1000中的某个值。

5.7.7之前默认值 是0，5.7.7和更高版本使用默认值1

高可用-复制

●  拓扑结构

一主一/多丛
主主（主动-主动模式）- 及其不推荐
主主（主动-被动模式）
拥有备库的主主结构
环形复制 - 不推荐
主库，分发主库，及备库
树或金字塔形
定制的复制方案:

选择性复制: -replicate_wild_do_table
分离功能等

现在用的比较多的是主主

●  同步异步

<5.5(2010年前)   异步复制  
5.5  半同步复制
5.7.17(2016年)    全同步复制 Group Replication

高可用-架构

●  方案： db-connection pool / API

●  方案： MM/MS+ vip

●  方案： MMM

●  方案： MHA(+中间件)

●  方案： Orchestrator(+中间件)

●  未来方向：基于分布式协议（基于MGR等）

高可用-架构

●  方案：MM +keepalive(网易)

自研的切换脚本进行自定义故障判定以及升主的一致性检查功能。一次完整的故障切换包含如下几个步骤：首
先利用Master上的keepalive定时调用故障检查check脚本，发现异常后进行3次重试，重试后MySQL依然无法
正常服务则触发切换。切换stop keepalive来触发slave抢占VIP，升级为主。升级为主后slave keepalive会调用
升主检查脚本，判定relay log应用完成后才放开写，关闭read only正式提供服务。
具备一致性检验功能（检查relay log是否应用完），配合杭研改进的semisync 功能，可以保障数据的强一致；
具备防网络抖动功能，不会在网络不稳定的情况下频繁切换；
原主恢复后不自动升级为master功能（MySQL复制延迟）；
自定义故障判定规则，贴近业务的高可用
简单易用，方便管理，可以人工介入。
Keepalived 使用注意事项
现象：
keepalived主从切换后，网关/交换机上的arp表没有立刻更新VIP对应备用 LVS 的mac，或者arp包被交换机dro
p掉，导致备机无法被访问。
解决：

arping -I eth1 -c 5 -s VIP GATEWAY
garp_master_refresh 选项 (Release 1.2.10)
Keepalived 不抢占的实现
Keepalived自带nopreempt参数实现不抢占功能，但当新主服务再挂掉后由于原主带nopreempt参数，即使原
主优先级高仍无法完成切换。故现在通过自定义脚本实现类似功能（sudo /etc/init.d/keepalived stop），备机
节点脚本只有当自身 MySQL可用且主机MySQL不可用时才触发切换。

Keepalive这套方案在网易内部主要用在一些负载比较小，但是对稳定性和可靠性要求比较高的数据库，比如o
penresty等云计算服务的元数据库，易信朋友圈数据库，也已经在线上稳定运行了3，4年的时间，可以做到秒
级别的切换。

高可用-架构

●  案例： MMM（美团2015年前）

●  案例： MHA+ 中间件（美团2015后）

https://tech.meituan.com/2017/06/29/database-availability-
architecture.html

高可用-架构

●  案例： github(多数据中心)

高性能

●  硬件系统

●  库表设计

●  SQL优化

●  软件架构

读写分离
分库分表

●  生产环境下调优(短期，临时性地)

高性能-硬件系统

innodb-read_io_threads, innodb_write_io_threads

注意mysql在NUMA上的问题

innodb buffer pool大小
缓冲池命中率

顺序访问
固态硬盘
合理设置RAID类型： 例如RAID10

●  CPU

●  内存

●  硬盘

●  网络
  

高性能-读写分离

●  分离之前

优先考虑缓存等其它方案
还有哪些解决读的？搜索引擎
实际上不少厂都不使用读写分离方案

●  问题与难点

数据复制的延迟问题
应用对于数据源的选择

●  读写分离: maxscale
官方推荐使用Lsyncd或者Corosync-Pacemaker做Maxscale的
HA

高性能-读写分离

  

高性能-读写分离

●  主从存在延迟如何解决？（导致没有读到更新后的数据）

方案1:   强制走主库（用的最多）
        区分哪些请求能够容忍，不能容忍就走主库

方案2:   Sleep（不靠谱）

方案3:   判断主备无延迟
        方法一： 判断seconds_behind_master==0  (秒为单位，不够精确)
        方法二： 判断位点：Master_Log_File, Read_Master_Log_Pos, Relay_Master_Log_File, 
Exec_Master_Log_Pos
        方法三： 判断GTID集合， AUTO_Position=1， Retrieved_Gtid_Set==Executed_Gtid_Set
        精确度已经提高不少，但仍没达到最精确。比如主库已经执行完成，但从库还没收到binlog。

方案3+:   配合semi-sync
         问题一： 一主多从的时候，某些从库依然存在问题；一主一丛没问题
         问题二： 业务更新高峰期，主库的位点或者GTID集合更新很快，判断可能一直不成立，导致从库迟迟无
法响应

方案4:   等主库位点
      select master_pos_wait(file, pos[, timeout])
         如果超时，去主库查询

方案5:   等GTID： 
         select wait_for_execute_gtid_set(gtid_set, 1)
         如果超时，去主库查询

高性能-分库分表

常见方案

● MySQL 分库分表

          基于 MySQL

● MySQL Cluster 

          基于 MySQL

● MySQL + Vitess

          基于 MySQL 

● MySQL + MyCAT                 基于 MySQL

● TiDB

                         兼容 MySQL 协议

● 其他不兼容MySQL的分布式数据库

  

SQL-分类

●  DDL(Data Definition Language)

create, drop, alter, truncate, comment, rename...
因为DDL没有事务性，所以DDL不能回滚
Q: 能online执行DDL吗？

●  DML(Data Manipulation Language)
insert, update, delete...

●   DQL(Data Query Language)

select...

●   DCL(Data Control Language)

grant, revoke...

●   TCL(Transaction Definition Language)

commit, rollback, savepoint...

SQL-执行顺序

(1) FROM
(2) JOINs 
(3) ON 
(4) WHERE
(5) GROUP BY(开始使用select中的别名，后面语句中都可以, 违反标准?)
(6) AVG, SUM.... 
(7) HAVING
(8) SELECT
(9) DISTINCT
(10) UNION
(11) ORDER BY 
(12) LIMIT and OFFSET(order by , 反着来的) 

SQL-join

●  

●   

●

●

●

●

SQL-join

SQL-join

SQL-join

● SELF JOIN

● WHERE vs INNER JOIN

● UNION vs JOIN
    UNION puts lines from queries after each other, while JOIN makes a 
cartesian product and subsets it -- completely different operations.

In simple terms, joins combine data into new columns. unions combine 
data into new rows.

SQL-join-impl

●  hash-join: https://dev.mysql.com/doc/refman/8.0/en/hash-joins.html

●  mysql 8.0.18(2019-10-14)
Beginning with MySQL 8.0.18, MySQL employs a hash join for any query for which 
each join has an equi-join condition and uses no indexes

●  A hash join is usually faster than and is intended to be used in such cases 
instead of the block nested loop algorithm (see Block Nested-Loop Join 
Algorithm) employed in previous versions of MySQL.
Beginning with MySQL 8.0.20, support for block nested loop is removed, and the 
server employs a hash join wherever a block nested loop would have been used 
previously.

SQL-进阶

●  CASE 表达式

●  SELF JOIN 与 排序  （rank mysql 8.0）

●  HAVING  可以单独使用，面向集合

●  子查询（及优化）

●  NOT EXISTS  vs NOT IN

●  EXISTS(谓词predicate   Q: 什么是谓词？有哪些？)  

SQL-优化

mysql> explain select * from (select * from ( select * from t1 where id=2602) ) ;
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------
+
| id | select_type | table      | type   | possible_keys     | key     | key_len | ref  | rows | Extra |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------
+
|  1 | PRIMARY    | <derived2> | system | NULL              | NULL    | NULL    | NULL |    1 |       |
|  2 | DERIVED     | <derived3> | system | NULL              | NULL    | NULL    | NULL |    1 |       |
|  3 | DERIVED     | t1             | const  | PRIMARY,idx_t1_id | PRIMARY | 4       |      |    1 |       |
+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------

type:

常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行

index: Full Index Scan，index与ALL区别为index类型只遍历索引树

range:只检索给定范围的行，使用一个索引来选择行

ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，
就是多表连接中使用primary key或者 unique key作为关联条件

const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置
于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的
情况下，使用system

NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以
通过单独索引查找完成。

SQL-优化

使用高效的查询：

参数是子查询时，用EXISTS代替IN
参数是子查询时，用连接代替IN
EXISTS vs 连接： 如果没有索引，EXISTS可能比连接更胜一筹

避免排序：

会进行排序的代表性运算：
GROUP BY 子句
ORDER BY 子句
聚合函数（ SUM 、 COUNT 、 AVG 、 MAX 、 MIN ）
DISTINCT
集合运算符（ UNION 、 INTERSECT 、 EXCEPT ）
窗口函数（ RANK 、 ROW_NUMBER 等）

考虑用UNION ALL 代替 UNION
使用 EXISTS 代替 DISTINCT
在极值函数中使用索引（ MAX/MIN）
能写在 WHERE 子句里的条件不要写在 HAVING 子句里 ---在使用 GROUP BY 子句聚合时会进行排序， 如果事先
通过WHERE 子句筛选出一部分行， 就能够减轻排序的负担。同时，WHERE 子句的条件里可以使用索引。 HAVING 子句是针对聚合后生成的视
图进行筛选的， 但是很多时候聚合后的视图都没有继承原表的索引结构 。
在 GROUP BY 子句和 ORDER BY 子句中使用索引

真正使用索引：

参考索引及索引失效

减少子查询
先进行连接再进行聚合
合理使用视图：

减少中间表： 1 展开数据需要耗费内存资源; 2 原始表中的索引不容易使用到（ 特别是聚合时）

聚合函数（ AVG 、 COUNT 、 SUM 、 MIN 、 MAX ）
集合运算符（ UNION 、 *NTERSECT 、 EXCEPT 等）

SQL-优化

●  插入或更新：
传统的思路：先select判断是否存在，再选择insert或者update。
用replace into 与 insert into … on duplicate key update替换。

●  插入或忽略：
INSERT IGNORE INTO ...

●  force index(vs. use index)
一条sql只会用到一个索引，mysql优化器会计算出一个合适的索引，但是这个索引不一定是最好的。force index()指令可以避免
MySql优化器用到了一个低效的索引。

●  分页
SELECT * FROM table_name LIMIT 10 OFFSET 8000001; (不推荐)
SELECT * FROM table_name WHERE id > 8000000 LIMIT 10 ;(推荐)
参考：https://hackernoon.com/please-dont-use-offset-and-limit-for-your-pagination-8ux3u4y

SQL-安全

实战-配置

●  innodb_flush_log_at_trx_commit   建议设置成1，表示每次事务的redo log都持久化到磁盘
●  sync_binlog建议设置成1， 表示每次事务的bin log都持久化到磁盘
●  set autocommit=1
●  innodb_deadlock_detect=on 默认也是on

双1模式

实战-命令

●  show processlist
●  information_schema.processlist表
●  sys.schema_table_lock_waits表
●  sys.innodb_lock_waits表
●  set long_query_time=1慢查询线上一般配置为1秒
    view slowquery.log
●  SHOW ENGINE INNODB STATUS
●  SHOW ENGINE INNODB MUTEX
●  SHOW ENGINE PERFORMANCE_SCHEMA STATUS
●  show open tables;
●  show status like 'table%';
●  show status like 'innodb_row_lock%';

1. innodb_row_lock_current_waits //当前正在等待锁定的数量
2. innodb_row_lock_time //从系统启动到现在锁定总时间长度
3. innodb_row_lock_time_avg //每次等待所花平均时间
4. innodb_row_lock_time_max //从系统启动到现在等待最长的一次所花时间
5. innodb_row_lock_waits //系统启动后到现在总共等待的次数

实战-规约

● 参考mysql_conversion.docx
