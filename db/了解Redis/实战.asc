:toc:
:toclevels: 5
:hardbreaks-option:

== 实战

=== 缓存与DB
- 读流程:

    hit: 返回数据
    否则miss: 从DB中读取, 然后放入缓存

- 写流程: 

    更新缓存:
        特点: 数据库和缓存都要写入
        优点: 不会增加一次miss, 效率可能会高一些
        缺点: 从一致性的角度, 有时候淘汰缓存可能会更好些

    淘汰缓存/删除缓存:
        特点: 只会写入数据库
        优点: 简单些
        缺点: 会增加一次miss

    先操作数据库，还是先操作缓存？
    
    更新缓存，还是淘汰缓存？
    
    需要根据具体的场景综合考虑一致性及性能问题，具体参考下面的一致性问题

- 一致性问题

    ▪ 什么是一致
    cache里有数据: cache和db里的数据是相同的
    cache里无数据: db里是最新的

    ▪ 有两种情况需要考虑:
    读写并发
    Cache/DB其中一个更新失败

    模式:
    ▪ Cache Aside Pattern
        先更新数据库，成功后让缓存失效
        依然存在问题，只是降低了概率
    ▪ Read/Write Through Pattern
        可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache
        也就是读写都落到一个DB节点上
        单一的存储保证一致性
    ▪ Write Behind Caching Pattern
        即write back
        只更新缓存，不更新数据库，缓存会异步地批量更新数据库
        优点: 性能
        缺点: 数据不是强一致性的，而且可能会丢失
    ▪ 分布式事务或强一致性
        效率太低

    可选方案:
    方案1:
    ID取模从服务service连接池选取服务连接，保证同一个数据的读写都落在同一个后端服务上
    ID取模从数据库DB连接池中选取DB连接，保证同一个数据的读写在数据库层面是串行的
    这个类似Read/Write Through Pattern的思想

- 参考
注意，以下参考中的某些方案及细节未必正确:
https://coolshell.cn/articles/17416.html
https://www.zhihu.com/question/319817091
https://m.w3cschool.cn/architectroad/architectroad-consistency-of-cache-with-database.html
https://m.w3cschool.cn/architectroad/architectroad-cache-architecture-design.html

- Q&A
Q1: 先删除/淘汰缓存，然后更新数据库，会有什么问题？
Q2: Cache Aside Pattern里，如果是先更新数据库，然后是更新缓存而不是删除缓存，会有什么问题？
Q3: Cache Aside Pattern存在什么问题？
Q4: 某个步骤失败了怎么办？

=== 缓存穿透
- 缓存和数据库中都没有的数据，而用户不断发起请求，这时的用户很可能是攻击者，攻击会导致数据库压力过大

- 接口层增加校验, 如用户鉴权校验

- 将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)

=== 缓存击穿
- 缓存击穿是指缓存中没有但数据库中有的数据(一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

- 击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。

- 二级缓存：对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间，则请求不会直接击穿缓存层到达数据库

- 热点数据永不过期

=== 缓存雪崩
- 当缓存服务器重启或者大量缓存集中在某一个时间段失效，会给后端系统(比如DB)带来很大压力，造成数据库后端故障，从而引起应用服务器雪崩

- 交错失效时间

- 提高HA

- 控制请求，重建缓存

- 熔断 隔离 限流

=== 数据类型
https://redis.io/docs/data-types/

=== 命令
https://redis.io/commands/

==== hash
https://redis.io/commands/?group=hash

Q: 如何删除hash下的所有field?
A: 小key可以使用del命令直接删除hash

==== hyperloglog
https://redis.io/commands/?group=hyperloglog
PF: Philippe Flajolet, https://en.wikipedia.org/wiki/Philippe_Flajolet

==== sorted-set
https://redis.io/commands/?group=sorted-set

==== Q&A
Q1: scan vs. keys
https://stackoverflow.com/questions/32603964/scan-vs-keys-performance-in-redis
SCAN SSCAN HSCAN ZSCAN也都比较慢

Q2: JSON representation
https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency

Q3: 阻塞操作
https://redis.io/docs/reference/modules/modules-blocking-ops/

=== pattern
https://redis.io/docs/manual/patterns/
https://redis.io/docs/manual/patterns/bulk-loading/
https://redis.io/docs/manual/patterns/distributed-locks/
https://redis.io/docs/manual/patterns/indexes/
https://redis.io/docs/manual/patterns/twitter-clone/

=== 查询与索引

==== 自建索引
https://redis.io/docs/manual/patterns/indexes/

secondary indexing:
Sorted sets to create secondary indexes by ID or other numerical fields.
Sorted sets with lexicographical ranges for creating more advanced secondary indexes, composite indexes and graph traversal indexes.
Sets for creating random indexes.
Lists for creating simple iterable indexes and last N items indexes.

==== Redis Search
https://redis.io/docs/interact/search-and-query/
https://redis.io/docs/stack/search/reference/query_syntax/

Redis Search:
https://github.com/RediSearch/RediSearch
https://github.com/RediSearch/redisearch-getting-started/
注意事项:
RediSearch 2.0: It works only with Redis 6 and above.

Commands:
https://redis.io/commands/?group=search
FT: full text

==== Q&A
Q: 如何支持主键索引？
Q: 如何支持非主键索引？
Q: 如何支持组合索引？
Q: 如何支持非唯一索引？
Q: 如何支持降序索引？

=== 关系型数据库
https://redis.com/blog/get-sql-like-experience-redis/

=== 工具
RedisInsight: https://redis.io/docs/ui/insight/
Redis Stack: https://redis.io/docs/about/about-stack/

=== 模块
since 5.0: https://docs.redis.com/latest/rs/release-notes/legacy-release-notes/redis-enterprise-5/
https://redis.io/resources/modules/

==== redis search
<<Redis Search, Redis Search>>

==== redis-cell
限流
https://github.com/brandur/redis-cell
https://redis.com/blog/redis-cell-rate-limiting-redis-module/

==== 编写
https://redis.io/docs/reference/modules/

=== 分布式锁
=== setnx
2.8版本中加入了set指令的扩展参数，使得setnx和expire指令可以一起执行。