:toc:
:toclevels: 5
:hardbreaks-option:

== 性能

=== clustor

https://redis.io/topics/cluster-tutorial
https://redis.io/topics/cluster-spec

=== 脚本
- 作用

    ▪ 原子操作: 脚本作为一个整体执行
    ▪ 降低网络开销: 多条命令一次打包
    ▪ 重复使用: lua脚本能存放到redis服务器, 每次脚本的执行只需传入脚本唯一id就能执行该脚本

- 使用
https://redis.io/commands/eval
https://redis.io/commands/evalsha
https://redis.io/commands/evalsha_ro
https://redis.io/commands/eval_ro
https://redis.io/commands/script-debug
https://redis.io/commands/script-exists
https://redis.io/commands/script-flush
https://redis.io/commands/script-kill
https://redis.io/commands/script-load

- 参考
https://redis.io/docs/interact/programmability/
https://redis.io/docs/interact/programmability/eval-intro/
https://rafaeleyng.github.io/redis-pipelining-transactions-and-lua-scripts

=== pipeline
原生命令: 例如mget、mset。
非原生命令: 可以使用pipeline提高效率。
但要注意控制一次批量操作的元素个数(例如500以内, 实际也和元素字节数有关)。

注意两者不同:
mget和mset是原子操作, pipeline是非原子操作。
pipeline可以打包不同的命令, mget和mset做不到。
pipeline需要客户端和服务端同时支持。

redis-benchmark -t set -P 2 -q
管道选项-P参数，表示单个管道内并行的请求数量。

参考:
https://redis.io/docs/manual/pipelining/
https://stackoverflow.com/questions/29327544/pipelining-vs-transaction-in-redis

=== 非阻塞
UNLINK命令: https://redis.io/commands/unlink/
FLUSHALL ASYNC: https://redis.io/commands/flushall/
FLUSHDB ASYNC: https://redis.io/commands/flushdb/

=== 延迟
https://redis.io/topics/latency

=== 慢查询日志
- SLOWLOG GET
- CONFIG SET slow-log-slower-than 0  (u seconds)
- CONFIG SET slowlog-max-len 5

=== 大key问题

==== 什么是大key
字符串类型: big体现在单个value值很大，一般认为超过10KB就是bigkey。
非字符串类型: 哈希、列表、集合、有序集合，big体现在元素个数太多(超过5000个?)。

==== 产生原因
1. 程序设计不当
2. 对数据规模的预估不足

==== 危害
1. 内存空间不均匀：这样会不利于集群对内存的统一管理，存在丢失数据的隐患。
2. 超时阻塞：由于Redis单线程的特性，操作bigkey的通常比较耗时，也就意味着阻塞Redis可能性越大，这样会造成客户端阻塞或者引起故障切换，它们通常出现在慢查询中。
3. 网络拥塞
bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey可能会对其他实例造成影响，其后果不堪设想。
4. 过期删除
有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性，而且这个过期删除不会从主节点的慢查询发现（因为这个删除不是客户端产生的，是内部循环事件，可以从latency命令中获取或者从slave节点慢查询发现）。
5. 迁移困难
当需要对bigkey进行迁移（例如Redis cluster的迁移slot），实际上是通过migrate命令来完成的，migrate实际上是通过dump + restore + del三个命令组合成原子命令完成，如果是bigkey，可能会使迁移失败，而且较慢的migrate会阻塞Redis。

==== 如何检测大key
redis-cli -h 127.0.0.1 -p 7001 –-bigkeys
该指令会大幅抬升redis的ops导致线上报警，可以增加一个休眠参数:
redis-cli -h 127.0.0.1 -p 7001 –-bigkeys -i 0.1
该指令每隔100条scan指令就会休眠0.1s，ops就不会剧烈抬升，但是扫描的时间会变长

==== 如何解决

==== 参考
https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&mid=2247483677&idx=1&sn=5c320b46f0e06ce9369a29909d62b401&chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&scene=21#wechat_redirect
https://www.getui.com/college/2019100911

=== 参考
https://redis.io/docs/management/optimization/
