:toc:
:toclevels: 5
:hardbreaks-option:

== 数据结构

=== sds
▪ simple dynamic string

▪ 作用
所有的Key
涉及到字符串的Value

▪ VS. c char
获取len O(1)
杜绝缓冲区溢出
减少修改长度时的内存分配次数: <1M *2   >1M +1M
二进制安全
兼容部分c字符串函数

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/sds.h
----
typedef char *sds;

/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
----

参考:
https://github.com/antirez/sds/

=== double linked list
▪ A generic doubly linked list

▪ 作用
list, 发布订阅，慢查询，监视器等

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/adlist.h
----
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct listIter {
    listNode *next;
    int direction;
} listIter;

typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
----

=== dict
▪ 作用
数据库; 哈希键

▪ 哈希算法
hashfunction() & sizemask
https://github.com/redis/redis/blob/unstable/src/siphash.c
当字典被用作数据库或者哈希键的底层实现时，使用SipHash(之前是MurmurHash2， murmur2 and murmur3 are both easy to 
attack, as there are algorithms which can quickly generate arbitrarily many keys that all hash to the same value regardless of what the seed is)

▪ 解决冲突
链地址法(separate chainning), 同时新节点添加到表头

▪ rehash
过程: hash表扩容/收缩，然后切换hash表的过程
扩容时机: server.rdb_child_pid == -1 && server.aof_child_pid == -1
_dictExpandIfNeeded
dict_force_resize_ratio=5
收缩时机: factor < 0.1?

▪ 渐进式hash
rehash的过程是渐进式的
delete, find, update是在ht[0], ht[1]上都要进行的，例如查找，先查ht[0], 查不到再查ht[1]
新增则只在ht[1]上进行

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/dict.h
----
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(dict *d, const void *key);
    void *(*valDup)(dict *d, const void *obj);
    int (*keyCompare)(dict *d, const void *key1, const void *key2);
    void (*keyDestructor)(dict *d, void *key);
    void (*valDestructor)(dict *d, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
    /* Flags */
    /* The 'no_value' flag, if set, indicates that values are not used, i.e. the
     * dict is a set. When this flag is set, it's not possible to access the
     * value of a dictEntry and it's also impossible to use dictSetKey(). Entry
     * metadata can also not be used. */
    unsigned int no_value:1;
    /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1
     * enables one more optimization: to store a key without an allocated
     * dictEntry. */
    unsigned int keys_are_odd:1;
    /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that
     * flag is set. */

    /* Allow each dict and dictEntry to carry extra caller-defined metadata. The
     * extra memory is initialized to 0 when allocated. */
    size_t (*dictEntryMetadataBytes)(dict *d);
    size_t (*dictMetadataBytes)(void);
    /* Optional callback called after an entry has been reallocated (due to
     * active defrag). Only called if the entry has metadata. */
    void (*afterReplaceEntry)(dict *d, dictEntry *entry);
} dictType;

//...

struct dict {
    dictType *type;

    dictEntry **ht_table[2];
    unsigned long ht_used[2];

    long rehashidx; /* rehashing not in progress if rehashidx == -1 */

    /* Keep small vars at end for optimal (minimal) struct padding */
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
    signed char ht_size_exp[2]; /* exponent of size. (size = 1<<exp) */

    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as defined
                                 * by dictType's dictEntryBytes. */
};
----

[source, c]
.https://github.com/redis/redis/blob/unstable/src/dict.c
----
struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;     /* Next entry in the same hash bucket. */
    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as returned
                                 * by dictType's dictEntryMetadataBytes(). */
};
----

=== skiplist
▪ 跳跃表
查找: 平均O(lgN), 最坏O(N)

▪ 作用
实现有序集合键(zset)  为什么是跳表: https://news.ycombinator.com/item?id=1171423
集群节点中用作数据结构等

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/server.h
----
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
----

参考:
https://zhuanlan.zhihu.com/p/23370124

=== intset
▪ 整数集合
本质上是一个数组: 有序，无重复

▪ 作用
实现集合键(set)

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/intset.h
----
typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
----

[source, c]
.https://github.com/redis/redis/blob/unstable/src/intset.c
----
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
----

=== ziplist
▪ 作用
实现列表键和哈希键

▪ 概念
The ziplist is a specially encoded dually linked list that is designed to be very memory efficient.
It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters.
It allows push and pop operations on either side of the list in O(1) time.
However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.

▪ 连续内存
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
其中每一个entry:
<prevlen> <encoding> <entry-data>
every entry in the ziplist is prefixed by metadata that contains two pieces of information. First, the length of the previous entry is stored to be able to traverse the list from back to front. Second, the entry encoding is provided. It represents the entry type, integer or string, and in the case of strings it also represents the length of the string payload.

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/ziplist.h
----
/* Each entry in the ziplist is either a string or an integer. */
typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    unsigned int slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
} ziplistEntry;
----

=== 参考
https://redis.com/redis-enterprise/data-structures/