:toc:
:toclevels: 5
:hardbreaks-option:

== 数据结构

=== sds
▪ simple dynamic string

▪ 作用
所有的Key
涉及到字符串的Value

▪ VS. c char
获取len O(1)
杜绝缓冲区溢出
减少修改长度时的内存分配次数: <1M *2    >1M +1M
二进制安全
兼容部分c字符串函数

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/sds.h
----
typedef char *sds;

/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
----
https://github.com/redis/redis/blob/unstable/src/sds.c
https://github.com/redis/redis/blob/unstable/src/sdsalloc.h

▪ 参考:
https://github.com/antirez/sds/

=== double linked list
▪ A generic doubly linked list

▪ 作用
列表键, 发布订阅，慢查询，监视器等

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/adlist.h
----
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct listIter {
    listNode *next;
    int direction;
} listIter;

typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;
----
链表表头节点的前置节点和表尾节点的后置节点都指向NULL, 因此redis链表实现的是无环链表。

=== dict
▪ 作用
数据库; 哈希键

▪ 哈希算法
hashfunction() & sizemask
https://github.com/redis/redis/blob/unstable/src/siphash.c
当字典被用作数据库或者哈希键的底层实现时，使用SipHash(之前是MurmurHash2, murmur2 and murmur3 are both easy to attack, as there are algorithms which can quickly generate arbitrarily many keys that all hash to the same value regardless of what the seed is)

▪ 解决冲突
链地址法(separate chainning), 同时新节点添加到表头

▪ rehash
过程: hash表扩容/收缩，然后切换hash表的过程
扩容时机: server.rdb_child_pid == -1 && server.aof_child_pid == -1
_dictExpandIfNeeded(): https://github.com/redis/redis/blob/unstable/src/dict.c
dict_force_resize_ratio=5
收缩时机: factor < 0.1?
dictResize(): https://github.com/redis/redis/blob/unstable/src/dict.c
扩缩容: _dictExpand() https://github.com/redis/redis/blob/unstable/src/dict.c

▪ 渐进式hash
rehash的过程是渐进式的
delete, find, update是在ht[0], ht[1]上都要进行的，例如查找，先查ht[0], 查不到再查ht[1]
新增则只在ht[1]上进行

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/dict.h
----
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(dict *d, const void *key);
    void *(*valDup)(dict *d, const void *obj);
    int (*keyCompare)(dict *d, const void *key1, const void *key2);
    void (*keyDestructor)(dict *d, void *key);
    void (*valDestructor)(dict *d, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
    /* Flags */
    /* The 'no_value' flag, if set, indicates that values are not used, i.e. the
     * dict is a set. When this flag is set, it's not possible to access the
     * value of a dictEntry and it's also impossible to use dictSetKey(). Entry
     * metadata can also not be used. */
    unsigned int no_value:1;
    /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1
     * enables one more optimization: to store a key without an allocated
     * dictEntry. */
    unsigned int keys_are_odd:1;
    /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that
     * flag is set. */

    /* Allow each dict and dictEntry to carry extra caller-defined metadata. The
     * extra memory is initialized to 0 when allocated. */
    size_t (*dictEntryMetadataBytes)(dict *d);
    size_t (*dictMetadataBytes)(void);
    /* Optional callback called after an entry has been reallocated (due to
     * active defrag). Only called if the entry has metadata. */
    void (*afterReplaceEntry)(dict *d, dictEntry *entry);
} dictType;

//...

struct dict {
    dictType *type;

    dictEntry **ht_table[2];
    unsigned long ht_used[2];

    long rehashidx; /* rehashing not in progress if rehashidx == -1 */

    /* Keep small vars at end for optimal (minimal) struct padding */
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
    signed char ht_size_exp[2]; /* exponent of size. (size = 1<<exp) */

    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as defined
                                 * by dictType's dictEntryBytes. */
};
----

metadata:
Allow each dict and dictEntry to carry extra caller-defined metadata. The extra memory is initialized to 0 when allocated.

[source, c]
.https://github.com/redis/redis/blob/unstable/src/dict.c
----
struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;     /* Next entry in the same hash bucket. */
    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as returned
                                 * by dictType's dictEntryMetadataBytes(). */
};
----

=== skiplist
▪ 跳跃表
查找: 平均O(lgN), 最坏O(N)

▪ 作用
实现有序集合键(zset)  为什么是跳表: https://news.ycombinator.com/item?id=1171423
集群节点中用作数据结构等

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/server.h
----
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
----

▪ 参考:
https://zhuanlan.zhihu.com/p/23370124

=== intset
▪ 整数集合
本质上是一个数组: 有序，无重复

▪ 作用
实现集合键(set)

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/intset.h
----
typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
----

[source, c]
.https://github.com/redis/redis/blob/unstable/src/intset.c
----
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
----

=== ziplist
▪ 作用
实现列表键和哈希键

▪ 概念
The ziplist is a specially encoded dually linked list that is designed to be very memory efficient.
It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters.
It allows push and pop operations on either side of the list in O(1) time.
However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.

▪ 连续内存
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
其中每一个entry:
<prevlen> <encoding> <entry-data>
every entry in the ziplist is prefixed by metadata that contains two pieces of information. First, the length of the previous entry is stored to be able to traverse the list from back to front. Second, the entry encoding is provided. It represents the entry type, integer or string, and in the case of strings it also represents the length of the string payload.

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/ziplist.h
----
/* Each entry in the ziplist is either a string or an integer. */
typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    unsigned int slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
} ziplistEntry;
----

=== quicklist
▪ A generic doubly linked quicklist implementation
since version 3.2

▪ 作用
实现列表键

▪ 主要思想
https://github.com/redis/redis/pull/2143

adlist: 双向链表，任意位置插入和删除非常方便，缺点是任意一个node是独立的内存块，因此可能导致内存碎片化
ziplist: 压缩双向链表，一个链表就是一整块内存，如果元素值为整数的话还可以进一步压缩，因此十分节省内存；缺点是任意一次插入删除操作都会导致重新分配内存，效率不高。
quicklist可以看作是adlist和ziplist的结合体: 外层使用类似adlist的结构，内层使用ziplist来节约内存。

quicklist还支持参数compress来控制压缩: 如果compress设置为1，则除了头尾两个节点，中间的节点都将被压缩(lzf压缩)。

▪ 实现
[source, c]
.https://github.com/redis/redis/blob/unstable/src/quicklist.h
----
/* Node, quicklist, and Iterator are the only data structures used currently. */

/* quicklistNode is a 32 byte struct describing a listpack for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max lp bytes is 65k, so max count actually < 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, PLAIN=1 (a single item as char array), PACKED=2 (listpack with multiple items).
 * recompress: 1 bit, bool, true if node is temporary decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 10 bits, free for future use; pads out the remainder of 32 bits */
typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *entry;
    size_t sz;             /* entry size in bytes */
    unsigned int count : 16;     /* count of items in listpack */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* PLAIN==1 or PACKED==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */
    unsigned int extra : 9; /* more bits to steal for future usage */
} quicklistNode;

/* quicklistLZF is a 8+N byte struct holding 'sz' followed by 'compressed'.
 * 'sz' is byte length of 'compressed' field.
 * 'compressed' is LZF data with total (compressed) length 'sz'
 * NOTE: uncompressed length is stored in quicklistNode->sz.
 * When quicklistNode->entry is compressed, node->entry points to a quicklistLZF */
typedef struct quicklistLZF {
    size_t sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;

/* Bookmarks are padded with realloc at the end of of the quicklist struct.
 * They should only be used for very big lists if thousands of nodes were the
 * excess memory usage is negligible, and there's a real need to iterate on them
 * in portions.
 * When not used, they don't add any memory overhead, but when used and then
 * deleted, some overhead remains (to avoid resonance).
 * The number of bookmarks used should be kept to minimum since it also adds
 * overhead on node deletion (searching for a bookmark to update). */
typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
} quicklistBookmark;

#if UINTPTR_MAX == 0xffffffff
/* 32-bit */
#   define QL_FILL_BITS 14
#   define QL_COMP_BITS 14
#   define QL_BM_BITS 4
#elif UINTPTR_MAX == 0xffffffffffffffff
/* 64-bit */
#   define QL_FILL_BITS 16
#   define QL_COMP_BITS 16
#   define QL_BM_BITS 4 /* we can encode more, but we rather limit the user
                           since they cause performance degradation. */
#else
#   error unknown arch bits count
#endif

/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * 'count' is the number of total entries.
 * 'len' is the number of quicklist nodes.
 * 'compress' is: 0 if compression disabled, otherwise it's the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * 'fill' is the user-requested (or default) fill factor.
 * 'bookmarks are an optional feature that is used by realloc this struct,
 *      so that they don't consume memory when not used. */
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all listpacks */
    unsigned long len;          /* number of quicklistNodes */
    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;

typedef struct quicklistIter {
    quicklist *quicklist;
    quicklistNode *current;
    unsigned char *zi; /* points to the current element */
    long offset; /* offset in current listpack */
    int direction;
} quicklistIter;

typedef struct quicklistEntry {
    const quicklist *quicklist;
    quicklistNode *node;
    unsigned char *zi;
    unsigned char *value;
    long long longval;
    size_t sz;
    int offset;
} quicklistEntry;
----

=== 参考
https://redis.com/redis-enterprise/data-structures/