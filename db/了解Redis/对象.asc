:toc:
:toclevels: 5
:hardbreaks-option:

== 对象
[source, c]
.https://github.com/redis/redis/blob/unstable/src/server.h
----
#define LRU_BITS 24
//...
struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
};
----

不同的对象具有不同的类型type(4bit)
同一个类型的type会有不同的存储形式encoding(4bit)
24个bit记录LRU/LFU信息
每个对象都有个引用计数，当引用计数为零时，对象会被销毁，内存得以回收
ptr指针指向对象内容的具体存储位置
一个redisObject对象头占据16字节(64位系统)

=== 类型
redis有5种实际的对象类型，分别为：string(字符串)、list(列表)、set(集合)、zset(有序集合)与hash(哈希)。

[source, c]
.https://github.com/redis/redis/blob/unstable/src/server.h
----
/* The actual Redis Object */
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */

/* The "module" object type is a special one that signals that the object
 * is one directly managed by a Redis module. In this case the value points
 * to a moduleValue struct, which contains the object value (which is only
 * handled by the module itself) and the RedisModuleType struct which lists
 * function pointers in order to serialize, deserialize, AOF-rewrite and
 * free the object.
 *
 * Inside the RDB file, module types are encoded as OBJ_MODULE followed
 * by a 64 bit module type ID, which has a 54 bits module-specific signature
 * in order to dispatch the loading to the right module, plus a 10 bits
 * encoding version. */
#define OBJ_MODULE 5    /* Module object. */
#define OBJ_STREAM 6    /* Stream object. */
#define OBJ_TYPE_MAX 7  /* Maximum number of object types */
----

=== 编码
[source, c]
.https://github.com/redis/redis/blob/unstable/src/server.h
----
/* Objects encoding. Some kind of objects like Strings and Hashes can be
 * internally represented in multiple ways. The 'encoding' field of the object
 * is set to one of this fields for this object. */
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* No longer used: old hash encoding. */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* No longer used: old list/hash/zset encoding. */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of listpacks */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
#define OBJ_ENCODING_LISTPACK 11 /* Encoded as a listpack */
----

=== 字符串对象
编码:
int
emstr(<=32字节)
raw

=== 列表对象
编码:
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */

=== 集合对象
编码:
intset

    需同时满足:
    所有元素都是整数值
    元素数量<=512

ht

=== 有序集合对象
编码:
ziplist

    需同时满足:
    元素长度都<64
    元素数量<128

skiplist

=== 哈希对象
编码:
ziplist

    需同时满足:
    字符串元素长度都<=64
    元素数量<=512

dict

=== 命令
TYPE
OBJECT ENCODING
OBJECT REFCOUNT
OBJECT IDLETIME

=== 生命周期
(1) maxmemory:    freeMemoryIfNeeded(evit.c):

    {"volatile-lru", MAXMEMORY_VOLATILE_LRU},
    {"volatile-lfu", MAXMEMORY_VOLATILE_LFU},
    {"volatile-random",MAXMEMORY_VOLATILE_RANDOM},
    {"volatile-ttl",MAXMEMORY_VOLATILE_TTL},
    {"allkeys-lru",MAXMEMORY_ALLKEYS_LRU},
    {"allkeys-lfu",MAXMEMORY_ALLKEYS_LFU},     
    {"allkeys-random",MAXMEMORY_ALLKEYS_RANDOM},
    {"noeviction",MAXMEMORY_NO_EVICTION},
    默认: MAXMEMORY_NO_EVICTION
    LFU:  V4.0
    Q: Approximated LRU algorithm, why?
    A: https://zhuanlan.zhihu.com/p/34133067

(2) 过期键