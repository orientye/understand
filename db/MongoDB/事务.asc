:toc:
:toclevels: 5
:hardbreaks-option:

== 事务

=== 简介
In MongoDB, an operation on a single document is atomic. Because you can use embedded documents and arrays to capture relationships between data in a single document structure instead of normalizing across multiple documents and collections, this single-document atomicity obviates the need for distributed transactions for many practical use cases.

For situations that require atomicity of reads and writes to multiple documents (in a single or multiple collections), MongoDB supports distributed transactions. With distributed transactions, transactions can be used across multiple operations, collections, databases, documents, and shards.

注意:
For many scenarios, the denormalized data model (embedded documents and arrays) will continue to be optimal for your data and use cases. That is, for many scenarios, modeling your data appropriately will minimize the need for distributed transactions.

=== ACID
[cols="2,3a", options="header"]
|===
|性质
|实现

|atomic
|
* 单表单行: version 1.x
* 复制集多表多行: version 4.0
* 分片集群多表多行: version 4.2

|consistent
|readConcern(version 3.2)

|isolate
|readConcern(version 3.2)

|durability
|journal and replication
|===

参考:
https://www.mongodb.com/docs/manual/core/transactions-production-consideration/#production-considerations
https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-atomicity

=== Read Preference

参考:
https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-read-preference

=== Read Concern
Read Concern/Read Isolation(query option)

local: 读取所有可用且属于当前分片的数据
available: 读取所有可用的数据
majority: 读取在大多数节点上提交完成的数据
linearizable: 可线性化读取文档
snapshot: 读取最近快照中的数据

▪ local与available:
在复制集上没有区别，在分片集上有区别

例如:
一个chunk x 正在从shard1向shar2迁移；
整个迁移过程中chunk x的部分数据会在shard1和shard2中同时存在，但源分片shard1仍为chunk x的负责方:
          所有对chunk x的读写操作仍然进入shard1;
          config中记录的信息chunk x仍然属于shard1;
此时如果读shard2, 则会体现local和available的区别:
          local: 只取应该由shard2负责的数据(不包括x)
          available: shard2上有什么读什么(包括x)

注意:
在一些无关紧要的场景下，可以选择available, 因为available效率会更高
从主节点读取数据，默认readConcern: local
从从节点读取数据，默认readConcern: available(向前兼容原因)

▪ majority
相当于mysql RC

Q: 如何实现安全的读写分离

eg. 反例
db.order.insert({_id:1001, q:1})
db.order.find({_id:1001}).readPref(“secondary”)

正确方式:
db.order.insert({_id:1001, q:1}, {wiriteConcern:{w:"majority"}})
db.order.find({_id:1001}).readPref("secondary").readConcern("majority")

▪ linearizable

▪ snapshot
相当于mysql serializable

参考:
https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-read-concern

=== Write Concern
Write concern describes the level of acknowledgment requested from MongoDB for write operations to a standalone mongod or to replica sets or to sharded clusters. In sharded clusters, mongos instances will pass the write concern on to the shards.

{ w: <value>, j: <boolean>, wtimeout: <number> }

w Option

1(default)
        With the default write concern, data can be rolled back.
        This write concern does not guarantee causal consistency.

0

majority

default:

https://docs.mongodb.com/manual/reference/mongodb-defaults/

参考:
https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-write-concern

=== Q&A
MongoDB事务能跨实例吗？
在同一个实例上，MongoDB事务能跨DB吗？

=== 参考
https://www.mongodb.com/docs/manual/core/transactions/