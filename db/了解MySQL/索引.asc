:toc:
:toclevels: 5
:hardbreaks-option:

== 索引

== 数据结构

- B+ Tree索引
    
    B+树 vs. B树

    索引与页: 一个节点对应一页?

    Q: InnoDB一棵B+树可以存放多少行数据
    A: https://mp.weixin.qq.com/s/comUSOOUPbkfdcXOvXgpVA

- Hash索引

    除了memory引擎外, NDB引擎也支持唯一哈希索引;
    innodb引擎有一个特殊的功能叫做自适应哈希索引, 当innodb注意到某些索引值被使用的非常频繁时, 
    它会在内存中基于btree索引之上再创建一个哈希索引, 这样就让btree索引也具有哈希索引的一些优点,
    比如: 快速的哈希查找, 这是一个全自动的, 内部的行为, 用户无法控制或者配置
    如果有必要, 可以选择关闭这个功能(innodb_adaptive_hash_index=OFF, 默认为ON)
    https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html

- Inverted Lists(FULLTEXT索引)

- R树索引 

== 类别

- 聚簇索引(clustered index)/主键索引

    叶子结点存储的是整行数据
    如果没有主键, 会寻找非空唯一索引, 如果没找到合适的, 则会隐式创建主键rowid(6-byte)

- 非聚簇索引(nonclustered index)/非主键索引/二级索引

    叶子结点存储的是主键的值

- 普通索引, 唯一索引, 联合索引(也称组合索引/复合索引/多列索引), 外键索引, 全文索引

- 回表

- 覆盖索引

- 函数索引
https://blogs.oracle.com/mysql/post/functional-indexes-in-mysql

== 设计

- 一般设计原则

    如果没有指定主键, InnoDB会用一个具有唯一且非空值的索引来代替
    如果不存在这样的索引, InnoDB会定义一个隐藏的主键, row num
    应当尽量避免随机的聚簇主键, 例如字符串主键
    主键长度应当尽量短小, 这样普通索引就越小, 从而节省空间
    一般建议使用自增主键: 避免B+树分裂
    采用业务字段作为主键: 只有一个索引; 该索引必须是唯一索引
    尽量使用主键查询
    尽量使用覆盖索引
    最左前缀原则: 最左前缀既可以是联合索引的最左N个字段, 也可以是字符串索引的最左M个字符
    避免重复索引, 冗余索引

- 字符串字段的索引

    完整索引, 可能比较占用空间。
    前缀索引, 节省空间, 但会增加扫描次数, 并且不能使用覆盖索引。
    倒序存储, 再创建前缀索引, 绕过字符串本身前缀的区分度不够问题, 不支持范围扫描。
    创建hash字段索引, 有额外的存储和计算消耗, 不支持范围扫描。

- 联合索引

    数据结构
    查询

== 失效情况

== 操作
可以通过表sys.schema_unused_indexes和索引不可见特性，删除无用的索引。