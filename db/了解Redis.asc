= 了解Redis

include::了解Redis/概览.asc[]

include::了解Redis/数据结构.asc[]

include::了解Redis/对象.asc[]

include::了解Redis/数据库.asc[]

include::了解Redis/持久化.asc[]

include::了解Redis/备份与恢复.asc[]

include::了解Redis/事务.asc[]

include::了解Redis/可用性.asc[]

include::了解Redis/性能.asc[]

include::了解Redis/实战.asc[]

数据结构-sds

●  simple dynamic string
sds.h/sds

●  VS. c char

获取len O(1)
杜绝缓冲区溢出
减少修改长度时的内存分配次数: <1M *2   > +1M
二进制安全
兼容部分c字符串函数

●   作用

所有的Key， 涉及到字符串的Value

数据结构-double linked list

●  双端链表

adlist.h/list

●  作用

list, 发布订阅，慢查询，监视器等

数据结构-dict

●  哈希表

dict.h/dict

●  作用

数据库； 哈希键

●  哈希算法

hashfunction() & sizemask
siphash.c
当字典被用作数据库或者哈希键的底层实现时，使用SipHash（之前是
MurmurHash2， murmur2 and murmur3 are both easy to 
attack, as there are algorithms which can quickly generate 
arbitrarily many keys that all hash to the same value regardless 
of what the seed is）

●  解决冲突

链地址法(separate chainning), 同时新节点添加到表头

数据结构-dict

●  rehash

 

       

过程： hash表扩容/收缩，然后切换hash表的过程
扩容时机:
server.rdb_child_pid == -1 && server.aof_child_pid == -1
_dictExpandIfNeeded
dict_force_resize_ratio=5
收缩时机：factor < 0.1?

●  渐进式hash

ht[0], 查不到再查ht[1]

新增则只在ht[1]上进行

rehash的过程是渐进式的
delete, find, update是在ht[0], ht[1]上都要进行的，例如查找，先查

数据结构-skiplist

●  跳跃表

●   作用

server.h/zskiplist
查找：平均O(lgN), 最坏O（N）

实现有序集合键(zset)
集群节点中用作数据结构等

https://zhuanlan.zhihu.com/p/23370124

数据结构-intset

●  整数集合

intset.h/intset

●  本质上是一个数组

有序，无重复
编码方式：

●   作用

实现集合键(set)

#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
编码方式可能会升级

数据结构-ziplist

●  压缩列表

ziplist.h/sds

●  连续内存
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>

其中每一个entry：
<prevlen> <encoding> <entry-data>
every entry in the ziplist is prefixed by metadata that contains two pieces
of information. First, the length of the previous entry is stored to be able to 
traverse the list from back to front. Second, the entry encoding is provided. 
It represents the entry type, integer or string, and in the case of strings it 
also represents the length of the string payload.

●   作用

实现列表键和哈希键

对象

typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;

其中， #define LRU_BITS 24

对象-类型

/* The actual Redis Object */
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */

/* The "module" object type is a special one that signals that the object
 * is one directly managed by a Redis module. In this case the value points
 * to a moduleValue struct, which contains the object value (which is only
 * handled by the module itself) and the RedisModuleType struct which lists
 * function pointers in order to serialize, deserialize, AOF-rewrite and
 * free the object.
 *
 * Inside the RDB file, module types are encoded as OBJ_MODULE followed
 * by a 64 bit module type ID, which has a 54 bits module-specific signature
 * in order to dispatch the loading to the right module, plus a 10 bits
 * encoding version. */
#define OBJ_MODULE 5    /* Module object. */
#define OBJ_STREAM 6    /* Stream object. */

对象-编码

#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */

对象-字符串对象

编码：
int
emstr(<=32字节)
raw

对象-列表对象

编码：

#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of 
ziplists */

对象-列表对象

对象-列表对象

对象-哈希对象

编码：
ziplist

dict

需同时满足：
字符串元素长度都<=64
元素数量<=512

对象-集合对象

编码：
intset

ht

需同时满足：
所有元素都是整数值
元素数量<=512

对象-有序集合对象

编码：
ziplist

skiplist

需同时满足：
元素长度都<64
元素数量<128

对象-命令

TYPE
OBJECT ENCODING
OBJECT REFCOUNT
OBJECT IDLETIME

对象-生命周期

(1)  maxmemory:    freeMemoryIfNeeded(evit.c):

    {"volatile-lru", MAXMEMORY_VOLATILE_LRU},
    {"volatile-lfu", MAXMEMORY_VOLATILE_LFU},
    {"volatile-random",MAXMEMORY_VOLATILE_RANDOM},
    {"volatile-ttl",MAXMEMORY_VOLATILE_TTL},
    {"allkeys-lru",MAXMEMORY_ALLKEYS_LRU},
    {"allkeys-lfu",MAXMEMORY_ALLKEYS_LFU},     
    {"allkeys-random",MAXMEMORY_ALLKEYS_RANDOM},
    {"noeviction",MAXMEMORY_NO_EVICTION},
默认： MAXMEMORY_NO_EVICTION
LFU:  V4.0
Q: Approximated LRU algorithm, why?

(2)  过期键

数据库-redisDb

/* Redis database representation. There are multiple databases identified
 * by integers from 0 (the default database) up to the max configured
 * database. The database number is the 'id' field in the structure. */
typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. 
*/
} redisDb;

server.c/initServer()
server.db = zmalloc(sizeof(redisDb)*server.dbnum);
CONFIG_DEFAULT_DBNUM = 16

数据库-redisDb

    dict *dict;

key: obj_string
val:  obj***

    dict *expires

key:  void* 指向dict里的key
val:   long long, 毫秒精度

数据库-redisDb

数据库-select dbnum

https://groups.google.com/forum/#!topic/redis-db/vS5wX8X4Cjg/discussion

Salvatore Sanfilippo

I understand how this can be useful, but unfortunately I consider Redis multiple 
database errors my worst decision in Redis design at all... without any kind of real gain, it 
makes the internals a lot more complex. The reality is that databases don't scale well for 
a number of reason, like active expire of keys and VM. If the DB selection can be 
performed with a string I can see this feature being used as a scalable O(1) dictionary 
layer, that instead it is not.With DB numbers, with a default of a few DBs, we are 
communication better what this feature is and how can be used I think. I hope that at 
some point we can drop the multiple DBs support at all, but I think it is probably too late 
as there is a number of people relying on this feature for their work.

其实没什么卵用

数据库-操作

FLUSHDB

DBSIZE

EXISTS

RENAME

KEYS

增删改查

数据库-读写

读：

更新hit或miss次数（INFO stats查看）
更新LRU时间(OBJECT idletime查看)
如果发现过期，会先删除过期键，然后才执行余下的操作

写：
如果有客户端WATCH监视了某个键，则将这个键标记为脏
脏计数器加1，这个计数器会触发服务器的持久化及复制操作

数据库-设置键的生存时间或过期时间

EXPIRE 秒（之后）
PEXPIRE   毫秒
EXPIREAT
PEXPIREAT
实际上都是PEXPIREAT

PERSIST

TTL 返回还有多长时间
PTTL 

如果没有设置时间，那缓存就是永不过期

数据库-过期键的删除

1、定时删除：通过维护一个定时器，过期马上删除，是最有效的，内存友好，cpu不友好。

2、惰性删除：程序在取出键时才判断它是否过期，过期才删除，cpu友好，内存不友好。 

3、定期删除：每隔一定时间执行一次删除过期键的操作，并限制每次删除操作的执行时长和频率，
是一种折中。 

Redis采用了惰性删除和定期删除的策略。

惰性删除：
expireIfNeeded()

定期删除：
activeExpireCycle()

数据库-过期键处理

SAVE/BGSAVE生成RDB时，过期键不会被保存到新创建的RDB中

        

如果服务器以主服务器模式运行，过期键不会被载入到数据库
如果服务器以从服务器模式运行，过期键会被载入到数据库

RDB
        生成：

        载入：

AOF
        写入：

        重写：

删除过期键时会追加DEL命令到AOF文件

过期键不会被保存到重写后的AOF文件中

复制
        主服务器删除一个过期键后会向所有从服务器发送DEL命令。
        从服务器执行客户端命令时，遇到过期键也不会将过期键删除，而是像处理未过期的键一样
来处理
        从服务器只有在接到主服务器的DEL命令之后才会删除过期键

数据库-通知

key-space notification
        关注某个键被执行了哪些命令

Key-event notification
        关注某个命令被什么键执行了

持久化-RDB

●  SAVE

●  BGSAVE

●  因AOF文件的更新频率通常比RDB文件的更新频率高，所以如
果服务器开启了AOF持久化功能，则服务器优先使用AOF文件来
还原数据库状态；只有在AOF持久化功能处于关闭状态时，服务
器才会使用RDB文件来还原数据库状态。 
 
  

持久化-AOF

●  appendfsync选项

●  BGREWRITEAOF执行原理 
  

事务

●

●
  

高可用

●  复制

●  sentinal

●  cluster

复制

●  slaveof

●  PSYNC(SYNC属于老版本)

●  INFO replication

redis复制是异步的
大致过程：
首先同步rdb, 之后命令传递

高性能

• clustor

• 脚本

实战

●  与DB的关系

●  缓存穿透

●  缓存击穿

●  缓存雪崩

●  慢查询

实战-与DB的关系

●  场景：读多写少

●  读流程：

●  写流程：

更新缓存：

读取缓存中是否有相关数据
如果hit, 返回数据
否则miss, 从DB中读取，然后放入缓存

淘汰缓存：

数据库和缓存都要写入
不会增加一次miss
复杂些

只会写入数据库
会增加一次miss
简单些
优先选择

先操作数据库，还是先操作缓存？
看谁的影响小
一般来说，先操作缓存，再操作数据库

●  服务接口化

实战-与DB的关系

●  Q：能用作持久化吗？

缓存穿透

●  缓存和数据库中都没有的数据，而用户不断发起请求，这时的
用户很可能是攻击者，攻击会导致数据库压力过大。

●  接口层增加校验，如用户鉴权校验

●  将key-value对写为key-null，缓存有效时间可以设置短点，
如30秒（设置太长会导致正常情况也没法使用）

缓存击穿

●  缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时
间到期），这时由于并发用户特别多，同时读缓存没读到数据，又
同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

击穿与雪崩的区别即在于击穿是对于特定的热点数据来说，而雪崩是全部数据。

●  二级缓存：对于热点数据进行二级缓存，并对于不同级别的缓
存设定不同的失效时间，则请求不会直接击穿缓存层到达数据库

●  热点数据永不过期

缓存雪崩

●  当缓存服务器重启或者大量缓存集中在某一个时间段失效，会
给后端系统(比如DB)带来很大压力，造成数据库后端故障，从而
引起应用服务器雪崩。

●  交错失效时间

●  提高HA

●  控制请求，重建缓存

●  熔断 隔离 限流

实战-慢查询日志

●  SLOWLOG GET

●  CONFIG SET slow-log-slower-than 0  (u seconds)
●  CONFIG SET slowlog-max-len 5 

谢谢大家！

