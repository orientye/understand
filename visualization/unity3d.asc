= unity3d
:revnumber: 0.0.1
:author: orient
:homepage: http://orientye.com
:toc:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:hardbreaks-option:
:stem: latexmath
<<<

== 编辑器结构
=== 文件目录

    Assets
        保留目录: https://docs.unity3d.com/Manual/SpecialFolders.html
    Library
        根据Assets目录下的游戏资源生成的中间文件
        IL指令会被编译到Library/ScripAssemblies/Assembly-CSharp.dll等文件中
        可以使用ILSpy工具对dll进行反编译
    Logs
    Packages
        要使用到的包
    ProjectSetttings
    Temp
        Library生成过程中产生的临时文件
    UserSettings
        本地工程的一些配置信息

    SVN与Git:
        只需要把Assets、Packages、ProjectSetttings上传到svn或Git。

    特殊的工程目录:
    https://blog.uwa4d.com/archives/USparkle_Addressable2.html

=== 视图

    Project视图
        项目的资源文件
        https://docs.unity3d.com/Manual/ProjectView.html
    Hierarchy视图
        保存游戏对象及其关系
        游戏对象可以保存在场景或者prefab中，场景和prefab则保存在project视图中
        https://docs.unity3d.com/Manual/Hierarchy.html
    Inspector视图
        属性
        https://docs.unity3d.com/Manual/UsingTheInspector.html
    Scene视图
        顶部的导航栏、左边的侧栏、右上角的坐标系控制器、正中间的游戏对象的编辑视图
        左边侧栏:
            1. 手形工具（Hand Tool）快捷键：Q
                用于平移Scene视图  按住鼠标中键拖动也可以实现同样效果  不移动对象，只移动视图摄像机
            2. 移动工具（Move Tool）快捷键：W
                移动选中的游戏对象  显示三色坐标轴Gizmo  可以沿轴或平面移动
            3. 旋转工具（Rotate Tool）快捷键：E
                旋转选中的游戏对象  显示球状旋转Gizmo  可以绕各个轴旋转
            4. 缩放工具（Scale Tool）快捷键：R
                缩放选中的游戏对象  显示立方体缩放Gizmo  可以均匀或非均匀缩放
            5. 矩形工具（Rect Tool）快捷键：T
                专门用于UI元素的变换  可以调整Rect Transform的尺寸和位置  显示矩形边框和控制点
            6. 移动、旋转、缩放组合工具（Move, Rotate, Scale Combined）快捷键：Y
                同时显示移动、旋转、缩放的控制柄  适合快速进行多种变换操作
    Game视图
        https://docs.unity3d.com/Manual/GameView.html
    导航栏视图
        https://docs.unity3d.com/Manual/Toolbar.html
        中间部分: 运行/关闭游戏、暂停游戏、逐帧播放游戏

    Unity 编辑模式下视角切换物体/游戏对象的方法:
        基本视角切换:
            选中物体后按 F 键 (Frame Selected)
            双击聚焦: 在 Hierarchy 窗口中双击物体名称
        视角环绕物体:
            聚焦物体后按住 Alt 键 + 鼠标左键拖动可以环绕观察
            按住 Alt 键 + 鼠标右键拖动可以缩放视角
        多物体视角切换:
            选中多个物体后按 F 键，视角会调整到能显示所有选中物体
        视角预设功能:
            保存视角位置:
                调整好视角后，点击场景视图右上角的相机图标
                选择 Save Camera Position 保存当前视角
            快速切换预设视角:
                使用数字键 1、2、3 等切换已保存的视角位置
                通过 Ctrl/Cmd + 数字键 保存新视角位置
        其它实用技巧:
            按 Shift + F 可以让视角跟随选中的物体（在移动物体时特别有用）
            在 2D 模式下，按 Ctrl/Cmd + Shift + F 可以快速对齐视图到选中物体
            使用场景视图右上方的方向小工具可以快速切换到标准视角（前、后、左、右等）
            按 Z 键可以切换物体轴心点与中心点的显示方式

=== Q&A

    Q: UNITY_EDITOR宏
    https://docs.unity3d.com/Manual/scripting-symbol-reference.html

    Q: meta文件
    meta 文件是 Unity 为项目中的每个资源文件自动生成的配套文件，包含该资源在 Unity 中的导入设置和引用信息。
    作用:
        资源导入设置: 存储资源导入时的各种参数配置
        GUID 标识: 为每个资源分配全局唯一标识符
        文件依赖关系: 记录资源之间的引用关系
        资源类型识别: 告诉 Unity 如何处理该文件

    Q: gizmos的作用与使用场景
    https://docs.unity3d.com/ScriptReference/Gizmos.html

=== ID
==== ClassID
https://docs.unity3d.com/Manual/ClassIDReference.html

作用:

    标识 Unity 内置的组件/资源类型

特点:

    Unity 内部定义的整数常量
    每个 Unity 内置类型有唯一的 ClassID
    例如:
        GameObject: 1
        Transform: 4
        MonoBehaviour: 114
        Texture2D: 28

Q: Unity 非内置类型有 ClassID 吗?
不会有新的 ClassID，但它们共享一个通用的 ClassID，对于自定义脚本，即 114 (MonoBehaviour)。Unity 通过 m_Script 字段（包含脚本的 guid 和 fileID）来区分和加载具体的非内置脚本类型，而不是为每个非内置类型分配一个独特的 ClassID。
Classes defined from scripts will always have class ID 114.

==== GUID FileID type InstanceID

    GUID (Globally Unique Identifier):
        作用: 唯一标识Unity项目中的每个资源文件
        格式: 32个字符的16进制字符串，如a3f2c5d1e4b6a7f8c9d0e1f2a3b4c5d6
        特性:
            每个资源文件(如纹理、预制体、脚本等)都有唯一的GUID
            即使文件重命名或移动位置，GUID保持不变
            存储在.meta文件中

    FileID:
        作用: 标识资源文件中的特定对象或子资源
        格式: 数字，如2100000或11500000

    type:
    形如m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}:
    Type is used to determine whether the file should be loaded from the Assets folder or the Library folder.
    Note that it only supports the following values, starting at 2 (given that 0 and 1 are deprecated):
    Type 2:
        Assets that can be loaded directly from the Assets folder by the Editor,
        like Materials and .asset files
    Type 3:
        Assets that have been processed and written in the Library folder, and loaded from there by the Editor,
        like Prefabs, textures, and 3D models
    参考: https://discussions.unity.com/t/what-does-type-3-mean-in-unity-scenes-prefabs-yaml/888216/4

    InstanceID:
        https://discussions.unity.com/t/an-explanation-of-how-instanceids-work/907399/3
        https://docs.unity3d.com/ScriptReference/Object.GetInstanceID.html

[cols="1,1,2,3", options="header"]
|===
| Identifier | Scope           | Persistence           | Example Use Case
| GUID       | Asset file      | Project-wide          | Tracking textures/prefabs in .meta
| FileID     | Object in asset | Asset-structure-based | Referencing a material inside an FBX
| InstanceID | Runtime object  | Session-only          | Fast GameObject lookup in gameplay
|===

At Edit Time:
Unity uses GUID + FileID to reference assets (e.g., a prefab links to a material via {GUID, FileID}).

At Runtime:
The instance ID of an object acts like a handle to the in-memory instance. It is always unique, and never has the value 0.

Q: Object.GetInstanceID vs GetHashCode()
https://discussions.unity.com/t/getinstanceid-v-gethashcode/816823
https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Scripting/UnityEngineObject.bindings.cs#L257

==== 参考
https://unity.com/blog/engine-platform/understanding-unitys-serialization-language-yaml

=== 参考
https://docs.unity3d.com/Manual/unity-editor.html

== asset
=== 概要
https://docs.unity3d.com/Manual/assets-and-media.html
https://learn.unity.com/tutorial/assets-resources-and-assetbundles
https://cloudycliff.github.io/post/unity_asset_best_practice_0/
https://blog.uwa4d.com/archives/USparkle_Addressable1.html
https://blog.uwa4d.com/archives/USparkle_Addressable2.html
https://blog.uwa4d.com/archives/USparkle_Addressable3.html

https://docs.unity3d.com/Manual/AssetWorkflow.html

Q: 如何查找资源引用?

=== 导入
https://docs.unity3d.com/Manual/import-assets.html

使用脚本管理导入:
https://docs.unity3d.com/Manual/ScriptedImporters.html
https://docs.unity3d.com/ScriptReference/AssetPostprocessor.html

==== AssetMetadata
https://docs.unity3d.com/Manual/AssetMetadata.html

[[Resources]]
=== Resources目录
可以在Assets下的任何目录下，并且可以有任意多份。
所有Resources目录下的文件都会直接打进一个特殊的Bundles中，并且在游戏启动时，会生成一个序列化映射表，并加载进内存里。
https://blog.uwa4d.com/archives/USparkle_Addressable2.html

该目录下的资源如果引用其它目录，则会把其它目录下的资源也一起打包。
Resources目录下的资源越多，或者依赖的资源越多，越容易增加包体。

不推荐新项目使用。

适用场景:
某些资源是项目整个生命周期都必须要用的
有些很重要，但是却不怎么占内存的
不怎么需要变化，并且不需要进行平台差异化处理的
用于系统启动时候最小引导的

[[StreamingAssets]]
=== StreamingAssets目录
https://docs.unity3d.com/Manual/StreamingAssets.html
Unity发布程序或者游戏，资源随包出去的，只有2个: Resources目录，以及StreamingAssets。
这个目录的下的文件，都会原封不动的复制到最终的APK或者iOS的包内。

特性:
1. 不会经过 Unity 的导入流程
放在 Resources 文件夹中的资源会被 Unity 压缩、处理并整合到项目的库文件中。
而放在 StreamingAssets 中的文件会 保持原始格式和字节不变。这对于需要保持文件完整性的场景至关重要。
2. 运行时动态加载
StreamingAssets 的主要目的是为了在运行时动态加载资源。

适用场景:
StreamingAssets适合存放那些不需要运行时修改但需要随包体一起发布的原始资源文件。
常见的应用场景包括:
加载 AssetBundle: 将打好的 AssetBundle 放在这里，应用运行时就可以加载它们，是实现热更新的基础。
读取配置文件。
任何需要保留原始字节的文件: 如加密过的资源、自定义二进制格式的文件等。

=== The Asset Database
https://docs.unity3d.com/Manual/AssetDatabase.html
https://docs.unity3d.com/ScriptReference/AssetDatabase.html

=== AssetBundle
==== 概要
https://docs.unity3d.com/Manual/AssetBundlesIntro.html

https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a7
https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a9

==== Layout
https://learn.unity.com/tutorial/assets-resources-and-assetbundles#5c7f8528edbc2a002053b5a7

==== Loading AssetBundles
https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html
https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html

==== Loading Assets From AssetBundles
https://docs.unity3d.com/ScriptReference/AssetBundle.html

- LoadAsset (LoadAssetAsync)
- LoadAllAssets (LoadAllAssetsAsync)
- LoadAssetWithSubAssets (LoadAssetWithSubAssetsAsync)

===== Low-level loading details
nityEngine.Object loading is performed off the main thread: an Object's data is read from storage on a worker thread. Anything which does not touch thread-sensitive parts of the Unity system (scripting, graphics) will be converted on the worker thread. For example, VBOs will be created from meshes, textures will be decompressed, etc.
From Unity 5.3 onward, Object loading has been parallelized. Multiple Objects are deserialized, processed and integrated on worker threads. When an Object finishes loading, its Awake callback will be invoked and the Object will become available to the rest of the Unity Engine during the next frame.
The synchronous AssetBundle.Load methods will pause the main thread until Object loading is complete. They will also time-slice Object loading so that Object integration does not occupy more than a certain number of milliseconds of frame time. The number of milliseconds is set by the property Application.backgroundLoadingPriority:
ThreadPriority.High: Maximum 50 milliseconds per frame
ThreadPriority.Normal: Maximum 10 milliseconds per frame
ThreadPriority.BelowNormal: Maximum 4 milliseconds per frame
ThreadPriority.Low: Maximum 2 milliseconds per frame.
From Unity 5.2 onwards, multiple Objects are loaded until the frame-time limit for Object loading is reached. Assuming all other factors are equal, the asynchronous variants of the asset loading APIs will always take longer to complete than the comparable synchronous version due to the minimum one-frame delay between issuing the asynchronous call and the object becoming available to the Engine.

===== AssetBundle依赖
https://docs.unity3d.com/Manual/AssetBundles-Dependencies.html

Q: 循环依赖？

===== AssetBundle manifest文件
https://docs.unity3d.com/ScriptReference/AssetBundleManifest.html

===== asset进bundle
https://docs.unity3d.com/Manual/AssetBundles-Preparing.html

===== AssetBundle变体(AssetBundleVariant)

==== xasset
https://github.com/xasset/xasset

==== YooAsset
https://github.com/tuyoogame/YooAsset

==== The Addressable Asset System
https://docs.unity3d.com/Manual/com.unity.addressables.html

缺点:
https://www.cnblogs.com/LiuOcean-Blog/p/wei-shen-me-pao-qi-le-addressable.html

==== asset graph
https://docs.unity3d.com/Packages/com.unity.assetgraph@1.6/manual/index.html

==== 参考
https://zhuanlan.zhihu.com/p/660510471

== script
=== scripting-backends
==== JIT与AOT
JIT: Just-In-Time，程序运行过程中进行转译
AOT: Ahead-Of-Time，提前将IL转译成机器码并且存储在文件中，此文件不能完全独立运行
完全静态编译: 只支持少数平台，基于AOT进一步生成所有的机器码

==== mono
解决C#的跨平台问题(在mono之前，C#只在windows平台上使用)。

开发模式下使用的是mono:
https://docs.unity3d.com/Manual/Mono.html

在游戏发布后自动将DLL转换成IL2CPP的方式。

==== IL2CPP
- unity采用IL2CPP的原因

    为了解决mono的问题，unity推出了il2cpp, 将c#转成c/c++代码，进而编译出native二进制代码。
    C#的一些高级特性，比如垃圾回收，线程等，则都实现到il2cpp runtime库(il2cpp vm)上。

    Mono VM在各个平台移植，维护非常耗时，有时甚至不可能完成
    Mono版本授权受限，换IL2CPP，IL2CPP VM是完全自己开发的组件，从而解决了授权问题
    提高运行效率，换成IL2CPP以后，程序编译成了硬件目标机器指令，运行效率提升

- 垃圾回收
The Boehm-Demers-Weiser conservative C/C++ Garbage Collector (bdwgc, also known as bdw-gc, boehm-gc, libgc)
https://github.com/ivmai/bdwgc
基本原理是在new和delete时记录引用关系，在收集垃圾的时候进行扫描，卸载无用的垃圾内存。

- 源码
unity自带源码位置:
    windows: Editor\2022.3.32f1\Editor\Data\il2cpp
    OSX: Contents/Frameworks/il2cpp/build
https://github.com/4ch12dy/il2cpp/
https://www.lfzxb.top/il2cpp-all-in-one/

- 实现
https://blog.unity.com/engine-platform/an-introduction-to-ilcpp-internals

- 参考
https://docs.unity3d.com/Manual/IL2CPP.html
https://blog.unity.com/topic/il2cpp
https://blog.unity.com/search?q=il2cpp

==== coreclr
https://blog.unity.com/engine-platform/porting-unity-to-coreclr

==== 扩展
https://github.com/jacksondunstan/UnityNativeScripting

==== 参考
https://docs.unity3d.com/Manual/scripting-backends.html

[[ExecutionOrder]]
=== ExecutionOrder
- 单个脚本内的执行顺序(确定)
https://docs.unity3d.com/Manual/ExecutionOrder.html

- 多个脚本的执行顺序
Project Settings -> Script Execution Order
DefaultExecutionOrder attribute:
https://docs.unity3d.com/2022.3/Documentation/ScriptReference/DefaultExecutionOrder.html
RuntimeInitializeOnLoadMethodAttribute:
https://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html

- +UniTask执行顺序
https://gist.github.com/neuecc/bc3a1cfd4d74501ad057e49efcd7bdae

=== coroutine
==== unity coroutines
https://docs.unity3d.com/Manual/Coroutines.html
https://docs.unity3d.com/Manual/ExecutionOrder.html#Coroutines

vs. async/await:
https://discussions.unity.com/t/differences-between-async-await-c-and-coroutines-unity3d/680771

与UniTask比较:
内置协程相比于UniTask，几乎没什么优势，一般不太建议使用。
https://medium.com/@burakzgen/unity-tips-6-b47d3af4b9ff

用法:

    IEnumerator
    yield return:
        yield return null 等待一帧
        yield return StartCoroutine(CallSomething())
        yield return new WaitForSeconds(5)
        yield return new WaitForFixedUpdate()

==== UniTask
===== 概览
https://github.com/Cysharp/UniTask
https://neuecc.medium.com/unitask-v2-zero-allocation-async-await-for-unity-with-asynchronous-linq-1aa9c96aa7dd

===== 设计目标
UniTask 的核心设计目标是为 Unity 提供一个高性能的与 Unity 深度集成的异步/等待解决方案，以解决标准 System.Threading.Tasks.Task 在 Unity 中的一些痛点，体现为:
a) 高性能:
标准的 Task 和 async/await 在每次调用时都会在堆上分配状态机对象，这会导致 GC压力，在每帧需要处理大量异步操作的游戏中这是不可接受的。UniTask 通过使用值类型（struct）替代引用类型（class）来实现极低的内存分配。
b) 深度集成 Unity:
UniTask 为 Unity 的单线程、基于主循环的架构量身定制，它天然支持 PlayerLoopSystem（Unity 的生命周期，如 Update, LateUpdate, FixedUpdate 等），可以在指定的帧时机恢复执行。
c) 轻量级:
通过移除 Task 中游戏开发不需要的复杂功能（如复杂的异常处理、取消令牌嵌套、多种任务调度器等），保持精简与高效。

===== API
====== 概要
https://github.com/Cysharp/UniTask/?tab=readme-ov-file#table-of-contents
https://github.com/Cysharp/UniTask/?tab=readme-ov-file#api-references

====== UniTask.Forget()
- 概念
当调用UniTask.Forget()时，实际上是启动了一个异步任务，但调用者立即"遗忘"了这个任务，不再对其进行显式的等待或管理。这意味着从调用Forget()的那一刻起，这个异步任务就开始在后台独立运行，调用者不会因为这个任务未完成而被阻塞等待。

- 潜在的问题
(1)资源释放
由于调用者不再跟踪这个异步任务，它可能会在后台持续运行，即使在某些情况下它已经不再需要。如果这个异步任务引用了一些资源(如数据库连接、文件句柄等)，并且没有正确地释放这些资源，就可能导致资源泄漏。
例如，如果异步任务中打开了一个文件进行写入，但没有在任务完成时关闭文件，而调用者又无法知道任务何时完成，就可能导致文件一直处于打开状态，占用系统资源。
(2)异常处理
如果异步任务在运行过程中出现错误，调用者可能无法察觉。因为调用者已经"遗忘"了这个任务，不会捕获任何可能由这个任务抛出的异常。这可能导致程序出现未预期的行为或错误，并且难以调试或者确定问题的根源。
此时，建议捕获异常。

- 适用场景
UniTask.Forget()通常适用于那些不需要立即结果、对结果不敏感或者可以在后台持续运行而不影响程序主要逻辑的异步任务。例如，日志记录、后台数据同步等任务。

- 注意事项
在使用UniTask.Forget()时，应该确保异步任务不会导致严重的资源泄漏或意外的副作用。如果异步任务涉及到重要的资源管理或可能产生严重错误，应该考虑使用其它方式来管理异步任务的生命周期，如等待任务完成、使用取消令牌等。
同时，应该对异步任务进行适当的错误处理，例如在异步任务中使用try-catch块来捕获异常，并采取适当的措施进行处理，以避免异常被忽略而导致程序出现不可预测的行为。

- 实现
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskExtensions.cs
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskVoid.cs

====== Q&A
- UniTask.Yield vs UniTask.NextFrame

====== MonoBehaviour与UniTask
- Q: MonoBehaviour里的很多方法都可以覆盖成async UniTaskVoid类型吗？
UniTaskVoid 只能用于特定的 MonoBehaviour 方法，最常见的就是 Start()。其它像 Update()、FixedUpdate() 等事件方法不应该/不建议被直接修改为 async UniTaskVoid 类型。
Start() 是"一次性"调用: Start() 在 GameObject 启用时只被调用一次。这意味着它非常适合进行异步初始化，比如加载资源或等待网络连接。
调用机制: Unity 引擎通过名称查找并调用 MonoBehaviour 中的事件方法。
Q: OnMouseDown可以么？只要不是频繁调用，应该没什么问题。

===== 实现原理
====== 基于值类型的 UniTask 结构体
与 System.Threading.Tasks.Task（引用类型）不同，UniTask 和 UniTask<T> 都是 struct（值类型）。

状态机存储在栈上:
当使用 async/await 时，编译器会生成一个状态机。对于 Task，这个状态机是一个 class，分配在堆上。而对于 UniTask，C# 编译器会生成一个 struct 状态机，通常分配在栈上，从而避免了托管堆的内存分配。

IUniTaskSource 接口:
虽然 UniTask 本身是值类型，但它需要与实际的异步操作源进行交互。这是通过 IUniTaskSource 和 IUniTaskSource<T> 接口实现的。具体的异步操作（如延时、资源加载、Web 请求）会实现这个接口。UniTask 结构体内部只持有一个对 IUniTaskSource 的引用和一个 token，本身非常轻量。通过对象池等技术可以复用这些源对象，进一步减少分配。

====== 自定义异步方法构建器
C# 的 async/await 语法糖背后是由一个构建器类型驱动的。对于 Task，编译器使用 AsyncTaskMethodBuilder。UniTask 提供了自己的 AsyncUniTaskMethodBuilder 和 AsyncUniTaskMethodBuilder<T>。

这个自定义构建器负责:
创建和启动 struct 状态机。
在异步操作完成时设置结果或异常。
返回到 Unity 主线程的上下文: 构建器知道当前操作是在 Unity 的哪个线程上发起的，并确保 await 之后的代码默认在 Unity 主线程上恢复，从而安全地调用 Transform, GameObject 等 API。

与 .NET 原生的 AsyncTaskMethodBuilder 相比，AsyncUniTaskMethodBuilder 做了大量优化：
1. 同步完成的激进优化
如果 await 的操作已经同步完成（例如，一个已经加载好的资源，或者一个瞬间完成的操作），UniTask 的构建器会采取“快速路径”。
它不会安排任何回调，而是立即继续执行后面的代码，就像没有 await 一样。这消除了所有异步机制的开销。
2. 使用 IUniTaskSource 池化
对于需要真正异步的操作（如 Delay, Yield），UniTask 内部使用对象池来管理实现 IUniTaskSource 的实例（如 DelayPromise）。
AsyncUniTaskMethodBuilder 在与这些实例协作时，充分利用了这套池化系统，避免了重复创建对象。

====== PlayerLoop 集成
原生问题: Unity 传统的协程（Coroutine）基于 IEnumerator 和 yield return 指令，返回的是 YieldInstruction 对象（如 WaitForSeconds, WaitForEndOfFrame）。这些 yield 指令会产生 GC 分配，并且功能有限。

UniTask 创建了对应的、更高效的等待机制。例如:
UniTask.Yield(PlayerLoopTiming.Update) 代替 yield return null，在下一帧 Update 之后继续。
UniTask.Delay(1000) 代替 new WaitForSeconds(1)，实现延时。
UniTask.WaitForEndOfFrame() 代替 yield return new WaitForEndOfFrame()。

底层实现: UniTask 内部有一个调度器，它将自己的延续（Continuation）操作注册到 Unity 玩家循环的特定阶段（如 Update, FixedUpdate, LateUpdate, PreRender, PostRender 等）。当游戏运行到该阶段时，Unity 的玩家循环会驱动 UniTask 的调度器，从而恢复等待中的异步操作。

====== 丰富的工具和操作符
Cancellation: 通过 CancellationToken 和 CancellationTokenSource 支持取消操作，与 UniTask 深度集成，比 Task 的取消更轻量。
AsyncLazy: 延迟执行且保证只执行一次的异步资源加载。
UniTask.WhenAll / UniTask.WhenAny: 等待所有或任意一个任务完成。这些操作符本身也经过高度优化，分配极少。
UniTask.Void / UniTask.Forget: 用于触发即发即弃（fire-and-forget）的异步操作，无需等待其完成。
UniTask.Retry / UniTask.Timeout: 为异步操作添加重试或超时逻辑。

====== 线程处理
UniTask 默认设计为在 Unity 的主线程上工作，延续（continuation）默认会在发布它的同步上下文（SynchronizationContext）上执行，这确保了线程安全。
主线程安全: 当 await 一个操作后，后面的代码默认会回到主线程执行，可以安全地访问和修改 Unity 的对象。
切换到线程池: 它也支持使用 UniTask.RunOnThreadPool() 或 UniTask.SwitchToThreadPool() 将耗时计算任务卸载到后台线程池，避免阻塞主线程。
切换回主线程: 在后台线程完成后，可以使用 UniTask.SwitchToMainThread() 切换回主线程，以更新UI或处理Unity对象。

f) 异步操作状态机复用
对于高频调用的异步操作（如网络消息处理），UniTask 提供了 UniTask.Retry, UniTask.Repeat 等方法，这些方法内部会尽可能复用状态机和异步源，而不是每次都创建新的，从而将性能开销降到最低。

===== 示例
[source, csharp]
----
using System.Threading;
using UnityEngine;
using Cysharp.Threading.Tasks;

public class UniTaskDemo : MonoBehaviour
{
    // 当鼠标点击这个碰撞体时调用
    private async UniTaskVoid OnMouseDown()
    {
        Debug.Log("OnMouseDown Begin");
        Debug.Log($"Main curThreadId = {Thread.CurrentThread.ManagedThreadId}");
        await FuncAsync();
        Debug.Log($"Main curThreadId = {Thread.CurrentThread.ManagedThreadId}");
        Debug.Log("OnMouseDown End");
    }

    static async UniTask<int> FuncAsync()
    {
        Func1();
        Func2();
        await Func3Async();
        await Func4Async();
        Func5();
        return 1;
    }

    static void Func1()
    {
        Debug.Log($"Func1 curThreadId = {Thread.CurrentThread.ManagedThreadId}");
        Debug.Log("Func1");
    }

    static void Func2()
    {
        Debug.Log($"Func2 curThreadId = {Thread.CurrentThread.ManagedThreadId}");
        Debug.Log("Func2");
    }

    static async UniTask<int> Func3Async()
    {
        Debug.Log("Func3Async Begin");
        Debug.Log($"Func3 curThreadId = {Thread.CurrentThread.ManagedThreadId}");

        await UniTask.Delay(10000);

        Debug.Log($"Func3 curThreadId = {Thread.CurrentThread.ManagedThreadId}");
        Debug.Log("Func3Async End");
        return 1;
    }

    static async UniTask<int> Func4Async()
    {
        Debug.Log("Func4Async Begin");
        Debug.Log($"Func4 curThreadId = {Thread.CurrentThread.ManagedThreadId}");

        await UniTask.Yield(PlayerLoopTiming.Update);

        Debug.Log($"Func4 curThreadId = {Thread.CurrentThread.ManagedThreadId}");
        Debug.Log("Func4Async End");
        return 2;
    }

    static void Func5()
    {
        Debug.Log("Func5");
        Debug.Log($"Func5 curThreadId = {Thread.CurrentThread.ManagedThreadId}");
    }
}
----

===== Func3Async()
====== 反编译
以下是通过dnSpy看到的结果:
[source, csharp]
----
[CompilerGenerated]
private sealed class <Func3Async>d__4 : IAsyncStateMachine
{
	public <Func3Async>d__4()
	{
	}

	void IAsyncStateMachine.MoveNext()
	{
		int num = this.<>1__state;
		int num2;
		try
		{
			UniTask.Awaiter awaiter;
			if (num != 0)
			{
				Debug.Log("Func3Async Begin");
				Debug.Log(string.Format("Func3 curThreadId = {0}", Thread.CurrentThread.ManagedThreadId));
				awaiter = UniTask.Delay(10000, false, PlayerLoopTiming.Update, default(CancellationToken), false).GetAwaiter();
				if (!awaiter.IsCompleted)
				{
					this.<>1__state = 0;
					this.<>u__1 = awaiter;
					UniTaskDemo.<Func3Async>d__4 <Func3Async>d__ = this;
					this.<>t__builder.AwaitUnsafeOnCompleted<UniTask.Awaiter, UniTaskDemo.<Func3Async>d__4>(ref awaiter, ref <Func3Async>d__);
					return;
				}
			}
			else
			{
				awaiter = this.<>u__1;
				this.<>u__1 = default(UniTask.Awaiter);
				this.<>1__state = -1;
			}
			awaiter.GetResult();
			Debug.Log(string.Format("Func3 curThreadId = {0}", Thread.CurrentThread.ManagedThreadId));
			Debug.Log("Func3Async End");
			num2 = 1;
		}
		catch (Exception ex)
		{
			this.<>1__state = -2;
			this.<>t__builder.SetException(ex);
			return;
		}
		this.<>1__state = -2;
		this.<>t__builder.SetResult(num2);
	}

	[DebuggerHidden]
	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
	}

	public int <>1__state;

	public AsyncUniTaskMethodBuilder<int> <>t__builder;

	private UniTask.Awaiter <>u__1;
}
----

====== UniTask.Delay(10000)的创建
Func3Async()第一次MoveNext():
awaiter = UniTask.Delay(10000, false, PlayerLoopTiming.Update, default(CancellationToken), false).GetAwaiter();

这里会将DelayPromise(实现了IPlayerLoopItem接口)添加到(负责PlayerLoopTiming.Update类型的)PlayerLoopRunner中:
UniTask.dll!Cysharp.Threading.Tasks.Internal.PlayerLoopRunner.AddAction(Cysharp.Threading.Tasks.IPlayerLoopItem item)
UniTask.dll!Cysharp.Threading.Tasks.PlayerLoopHelper.AddAction(Cysharp.Threading.Tasks.PlayerLoopTiming timing, Cysharp.Threading.Tasks.IPlayerLoopItem action)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.DelayPromise.Create(System.TimeSpan delayTimeSpan, Cysharp.Threading.Tasks.PlayerLoopTiming timing, System.Threading.CancellationToken cancellationToken, bool cancelImmediately, out short token)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.Delay(System.TimeSpan delayTimeSpan, Cysharp.Threading.Tasks.DelayType delayType, Cysharp.Threading.Tasks.PlayerLoopTiming delayTiming, System.Threading.CancellationToken cancellationToken, bool cancelImmediately)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.Delay(System.TimeSpan delayTimeSpan, bool ignoreTimeScale, Cysharp.Threading.Tasks.PlayerLoopTiming delayTiming, System.Threading.CancellationToken cancellationToken, bool cancelImmediately)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.Delay(int millisecondsDelay, bool ignoreTimeScale, Cysharp.Threading.Tasks.PlayerLoopTiming delayTiming, System.Threading.CancellationToken cancellationToken, bool cancelImmediately)

[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/PlayerLoopHelper.cs
----
public static void AddAction(PlayerLoopTiming timing, IPlayerLoopItem action)
{
    var runner = runners[(int)timing];
    if (runner == null)
    {
        ThrowInvalidLoopTiming(timing);
    }
    runner.AddAction(action);
}
----

[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/Internal/PlayerLoopRunner.cs
----
public void AddAction(IPlayerLoopItem item)
{
    lock (runningAndQueueLock)
    {
        if (running)
        {
            waitQueue.Enqueue(item);
            return;
        }
    }

    lock (arrayLock)
    {
        // Ensure Capacity
        if (loopItems.Length == tail)
        {
            Array.Resize(ref loopItems, checked(tail * 2));
        }
        loopItems[tail++] = item;
    }
}
----

====== UniTask.Delay(10000)的延续
UniTask.Delay(10000)的创建完成后，依然是在Func3Async()第一次MoveNext()里:
UniTask.dll!Cysharp.Threading.Tasks.UniTaskCompletionSourceCore<object>.OnCompleted(System.Action<object> continuation, object state, short token)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.DelayPromise.OnCompleted(System.Action<object> continuation, object state, short token)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.Awaiter.UnsafeOnCompleted(System.Action continuation)
UniTask.dll!Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskMethodBuilder<int>.AwaitUnsafeOnCompleted<Cysharp.Threading.Tasks.UniTask.Awaiter, UniTaskDemo.<Func3Async>d__4>(ref Cysharp.Threading.Tasks.UniTask.Awaiter awaiter, ref UniTaskDemo.<Func3Async>d__4 stateMachine)
Assembly-CSharp.dll!UniTaskDemo.Func3Async()
UniTask.dll!Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskMethodBuilder<int>.Start<UniTaskDemo.<Func3Async>d__4>(ref UniTaskDemo.<Func3Async>d__4 stateMachine)
Assembly-CSharp.dll!UniTaskDemo.Func3Async()
Assembly-CSharp.dll!UniTaskDemo.FuncAsync()
UniTask.dll!Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskMethodBuilder<int>.Start<UniTaskDemo.<FuncAsync>d__1>(ref UniTaskDemo.<FuncAsync>d__1 stateMachine)
Assembly-CSharp.dll!UniTaskDemo.FuncAsync()
Assembly-CSharp.dll!UniTaskDemo.OnMouseDown()
UniTask.dll!Cysharp.Threading.Tasks.CompilerServices.AsyncUniTaskVoidMethodBuilder.Start<UniTaskDemo.<OnMouseDown>d__0>(ref UniTaskDemo.<OnMouseDown>d__0 stateMachine)
Assembly-CSharp.dll!UniTaskDemo.OnMouseDown()
UnityEngine.CoreModule.dll!UnityEngine.GameObject.SendMessage(string methodName, object value, UnityEngine.SendMessageOptions options)
也就是说:
this.<>t__builder.AwaitUnsafeOnCompleted<UniTask.Awaiter, UniTaskDemo.<Func3Async>d__4>(ref awaiter, ref <Func3Async>d__); 会将Func3Async状态机设置为DelayTask的延续，这个设置过程是在
Cysharp.Threading.Tasks.UniTaskCompletionSourceCore<object>.OnCompleted(System.Action<object> continuation, object state, short token)函数中完成的(参数state在这里就是<Func3Async>d__状态机):

[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskCompletionSource.cs
----
public struct UniTaskCompletionSourceCore<TResult>
{
    // Struct Size: TResult + (8 + 2 + 1 + 1 + 8 + 8)

    TResult result;
    object error; // ExceptionHolder or OperationCanceledException
    short version;
    bool hasUnhandledError;
    int completedCount; // 0: completed == false
    Action<object> continuation;
    object continuationState;

    //...

    /// <summary>Schedules the continuation action for this operation.</summary>
    /// <param name="continuation">The continuation to invoke when the operation has completed.</param>
    /// <param name="state">The state object to pass to <paramref name="continuation"/> when it's invoked.</param>
    /// <param name="token">Opaque value that was provided to the <see cref="UniTask"/>'s constructor.</param>
    [DebuggerHidden]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void OnCompleted(Action<object> continuation, object state, short token /*, ValueTaskSourceOnCompletedFlags flags */)
    {
        if (continuation == null)
        {
            throw new ArgumentNullException(nameof(continuation));
        }
        ValidateToken(token);

        /* no use ValueTaskSourceOnCOmpletedFlags, always no capture ExecutionContext and SynchronizationContext. */

        /*
            PatternA: GetStatus=Pending => OnCompleted => TrySet*** => GetResult
            PatternB: TrySet*** => GetStatus=!Pending => GetResult
            PatternC: GetStatus=Pending => TrySet/OnCompleted(race condition) => GetResult
            C.1: win OnCompleted -> TrySet invoke saved continuation
            C.2: win TrySet -> should invoke continuation here.
        */

        // not set continuation yet.
        object oldContinuation = this.continuation;
        if (oldContinuation == null)
        {
            continuationState = state;
            oldContinuation = Interlocked.CompareExchange(ref this.continuation, continuation, null);
        }

        if (oldContinuation != null)
        {
            // already running continuation in TrySet.
            // It will cause call OnCompleted multiple time, invalid.
            if (!ReferenceEquals(oldContinuation, UniTaskCompletionSourceCoreShared.s_sentinel))
            {
                throw new InvalidOperationException("Already continuation registered, can not await twice or get Status after await.");
            }

            continuation(state);
        }
    }
    //...
}
----
对于上面的例子，this.continuation通常为null，会执行Interlocked.CompareExchange(ref this.continuation, continuation, null)，即:
比较this.continuation与null是否相等，为真，将continuation赋值给this.continuation，返回this.continuation之前的值也就是null。

也就是说，struct UniTaskCompletionSourceCore上的continuation字段记录了其延续。

====== UniTask.Delay(10000)的完成
Func3Async()第二次MoveNext():
Assembly-CSharp.dll!UniTaskDemo.Func3Async()
UniTask.dll!Cysharp.Threading.Tasks.CompilerServices.AsyncUniTask<UniTaskDemo.<Func3Async>d__4, int>.Run()
UniTask.dll!Cysharp.Threading.Tasks.AwaiterActions.Continuation(object state)
UniTask.dll!Cysharp.Threading.Tasks.UniTaskCompletionSourceCore<object>.TrySetResult(object result)
UniTask.dll!Cysharp.Threading.Tasks.UniTask.DelayPromise.MoveNext()
UniTask.dll!Cysharp.Threading.Tasks.Internal.PlayerLoopRunner.RunCore()
UniTask.dll!Cysharp.Threading.Tasks.Internal.PlayerLoopRunner.Update()
UniTask.dll!Cysharp.Threading.Tasks.Internal.PlayerLoopRunner.Run()

如前所述，DelayPromise添加到了PlayerLoopRunner中，当time定时完成时，会触发DelayPromised的MoveNext()，在这个DelayPromise的MoveNext()里，会调用UniTaskCompletionSourceCore<object>.TrySetResult()，进而执行其延续(也就是Func3Async状态机)的MoveNext()。

[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskCompletionSource.cs
----
public bool TrySetResult(TResult result)
{
    if (Interlocked.Increment(ref completedCount) == 1)
    {
        // setup result
        this.result = result;

        if (continuation != null || Interlocked.CompareExchange(ref this.continuation, UniTaskCompletionSourceCoreShared.s_sentinel, null) != null)
        {
            continuation(continuationState);
        }
        return true;
    }

    return false;
}
----

===== 实现
====== UniTask
strut UniTask与struct UniTask<T>:
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTask.cs
struct UniTaskVoid:
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTaskVoid.cs

[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTask.cs
----
[AsyncMethodBuilder(typeof(AsyncUniTaskMethodBuilder<>))]
[StructLayout(LayoutKind.Auto)]
public readonly struct UniTask<T>
{
    readonly IUniTaskSource<T> source;
    readonly T result;
    readonly short token;
    //...
}
----
source: 真正执行异步操作的源头。它是一个接口，允许不同的实现（如计时器、帧等待、AssetBundle 加载等）都能被 UniTask 使用。
result: 如果操作已经同步完成，则直接存储结果，避免调用 source。
token: 版本号，用于防止在已完成的 source 上重复执行延续，提升安全性。

====== AsyncUniTaskMethodBuilder
struct AsyncUniTaskMethodBuilder与struct AsyncUniTaskMethodBuilder<T>:
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/CompilerServices/AsyncUniTaskMethodBuilder.cs

[source, csharp]
----
public struct AsyncUniTaskMethodBuilder<T>
{
    IStateMachineRunnerPromise<T> runnerPromise;
    Exception ex;
    T result;

    // 1. Static Create method.
    [DebuggerHidden]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static AsyncUniTaskMethodBuilder<T> Create()
    {
        return default;
    }

    // 2. TaskLike Task property.
    public UniTask<T> Task
    {
        [DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (runnerPromise != null)
            {
                return runnerPromise.Task;
            }
            else if (ex != null)
            {
                return UniTask.FromException<T>(ex);
            }
            else
            {
                return UniTask.FromResult(result);
            }
        }
    }

    // 3. SetException
    [DebuggerHidden]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetException(Exception exception)
    {
        if (runnerPromise == null)
        {
            ex = exception;
        }
        else
        {
            runnerPromise.SetException(exception);
        }
    }

    // 4. SetResult
    [DebuggerHidden]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetResult(T result)
    {
        if (runnerPromise == null)
        {
            this.result = result;
        }
        else
        {
            runnerPromise.SetResult(result);
        }
    }

    // 5. AwaitOnCompleted
    [DebuggerHidden]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : INotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {
        if (runnerPromise == null)
        {
            AsyncUniTask<TStateMachine, T>.SetStateMachine(ref stateMachine, ref runnerPromise);
        }

        awaiter.OnCompleted(runnerPromise.MoveNext);
    }

    // 6. AwaitUnsafeOnCompleted
    [DebuggerHidden]
    [SecuritySafeCritical]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : ICriticalNotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {
        if (runnerPromise == null)
        {
            AsyncUniTask<TStateMachine, T>.SetStateMachine(ref stateMachine, ref runnerPromise);
        }

        awaiter.UnsafeOnCompleted(runnerPromise.MoveNext);
    }

    // 7. Start
    [DebuggerHidden]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Start<TStateMachine>(ref TStateMachine stateMachine)
        where TStateMachine : IAsyncStateMachine
    {
        stateMachine.MoveNext();
    }
    //...
}
----

====== StateMachineRunner
[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/CompilerServices/StateMachineRunner.cs
----
    internal interface IStateMachineRunner
    //...
    internal interface IStateMachineRunnerPromise : IUniTaskSource
    //...
    internal interface IStateMachineRunnerPromise<T> : IUniTaskSource<T>
    {
        Action MoveNext { get; }
        UniTask<T> Task { get; }
        void SetResult(T result);
        void SetException(Exception exception);
    }

    //...

    internal sealed class AsyncUniTaskVoid<TStateMachine> : IStateMachineRunner, ITaskPoolNode<AsyncUniTaskVoid<TStateMachine>>, IUniTaskSource
    where TStateMachine : IAsyncStateMachine
    //...
    internal sealed class AsyncUniTask<TStateMachine> : IStateMachineRunnerPromise, IUniTaskSource, ITaskPoolNode<AsyncUniTask<TStateMachine>>
    where TStateMachine : IAsyncStateMachine
    //...
        internal sealed class AsyncUniTask<TStateMachine, T> : IStateMachineRunnerPromise<T>, IUniTaskSource<T>, ITaskPoolNode<AsyncUniTask<TStateMachine, T>>
        where TStateMachine : IAsyncStateMachine
    {
        static TaskPool<AsyncUniTask<TStateMachine, T>> pool;

#if ENABLE_IL2CPP
        readonly Action returnDelegate;  
#endif

        public Action MoveNext { get; }

        TStateMachine stateMachine;
        UniTaskCompletionSourceCore<T> core;

        AsyncUniTask()
        {
            MoveNext = Run;
#if ENABLE_IL2CPP
            returnDelegate = Return;
#endif
        }

        public static void SetStateMachine(ref TStateMachine stateMachine, ref IStateMachineRunnerPromise<T> runnerPromiseFieldRef)
        {
            if (!pool.TryPop(out var result))
            {
                result = new AsyncUniTask<TStateMachine, T>();
            }
            TaskTracker.TrackActiveTask(result, 3);

            runnerPromiseFieldRef = result; // set runner before copied.
            result.stateMachine = stateMachine; // copy struct StateMachine(in release build).
        }

        AsyncUniTask<TStateMachine, T> nextNode;
        public ref AsyncUniTask<TStateMachine, T> NextNode => ref nextNode;

        static AsyncUniTask()
        {
            TaskPool.RegisterSizeGetter(typeof(AsyncUniTask<TStateMachine, T>), () => pool.Size);
        }

        void Return()
        {
            TaskTracker.RemoveTracking(this);
            core.Reset();
            stateMachine = default;
            pool.TryPush(this);
        }

        bool TryReturn()
        {
            TaskTracker.RemoveTracking(this);
            core.Reset();
            stateMachine = default;
            return pool.TryPush(this);
        }

        [DebuggerHidden]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void Run()
        {
            // UnityEngine.Debug.Log($"MoveNext State:" + StateMachineUtility.GetState(stateMachine));
            stateMachine.MoveNext();
        }

        public UniTask<T> Task
        {
            [DebuggerHidden]
            get
            {
                return new UniTask<T>(this, core.Version);
            }
        }

        [DebuggerHidden]
        public void SetResult(T result)
        {
            core.TrySetResult(result);
        }

        [DebuggerHidden]
        public void SetException(Exception exception)
        {
            core.TrySetException(exception);
        }

        [DebuggerHidden]
        public T GetResult(short token)
        {
            try
            {
                return core.GetResult(token);
            }
            finally
            {
#if ENABLE_IL2CPP
                // workaround for IL2CPP bug.
                PlayerLoopHelper.AddContinuation(PlayerLoopTiming.LastPostLateUpdate, returnDelegate);
#else
                TryReturn();
#endif
            }
        }

        [DebuggerHidden]
        void IUniTaskSource.GetResult(short token)
        {
            GetResult(token);
        }

        [DebuggerHidden]
        public UniTaskStatus GetStatus(short token)
        {
            return core.GetStatus(token);
        }

        [DebuggerHidden]
        public UniTaskStatus UnsafeGetStatus()
        {
            return core.UnsafeGetStatus();
        }

        [DebuggerHidden]
        public void OnCompleted(Action<object> continuation, object state, short token)
        {
            core.OnCompleted(continuation, state, token);
        }
    }
----

====== PlayerLoop
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/Internal/PlayerLoopRunner.cs

https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/PlayerLoopHelper.cs

https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/PlayerLoopTimer.cs

====== IPlayerLoopItem
[source, csharp]
.https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/PlayerLoopHelper.cs
----
public interface IPlayerLoopItem
{
    bool MoveNext();
}
----

- 延迟相关
例如:
sealed class DelayPromise : IUniTaskSource, IPlayerLoopItem, ITaskPoolNode<DelayPromise>
sealed class DelayFramePromise : IUniTaskSource, IPlayerLoopItem, ITaskPoolNode<DelayFramePromise>
sealed class YieldPromise : IUniTaskSource, IPlayerLoopItem, ITaskPoolNode<YieldPromise>sealed class YieldPromise : IUniTaskSource, IPlayerLoopItem, ITaskPoolNode<YieldPromise>
https://github.com/Cysharp/UniTask/blob/master/src/UniTask/Assets/Plugins/UniTask/Runtime/UniTask.Delay.cs


=== 序列化
https://docs.unity3d.com/Manual/script-serialization.html

使用场景:
https://docs.unity3d.com/Manual/script-serialization-how-unity-uses.html

配置:
Project Settings -> Editor -> Asset Serialization -> Mode 推荐使用Force Text，方便查看，不会影响最终游戏的发布效率

格式描述:
https://docs.unity3d.com/Manual/FormatDescription.html

序列化嵌套:
基础类型以及数组等支持序列化，但有些类型不支持序列化，例如字典、List<List<T>>等，需要包装在类里。

序列化引用

序列化继承

=== 脚本属性(Attributes)
- 公共/非公共属性
非公共属性: 默认情况下，非公共属性(private或protected)不会在Inspector中显示。
[SerializeField]: 用于在Inspector中显示非公共属性。
[HideInInspector]: 用于隐藏公共属性，使其不在Inspector中显示。

- 序列化属性
[SerializeField]: 值类型序列化
工作原理: 直接序列化字段的具体值，不关心字段的运行时类型。
[SerializeReference]: 引用类型序列化
工作原理: 序列化类型信息和数据，支持多态和运行时类型识别。
https://docs.unity3d.com/ScriptReference/SerializeField.html
https://docs.unity3d.com/ScriptReference/SerializeReference.html

- 默认的不序列化行为
public class DefaultNonSerialized : MonoBehaviour
{
    // 这些默认不会被序列化：
    private int privateField;           // 私有字段
    protected string protectedField;    // 受保护字段
    internal float internalField;       // 内部字段
    
    public static int staticField;      // 静态字段
    public const int CONST_FIELD = 100; // 常量
    
    // 属性（Properties）
    public int Health { get; set; }
    
    // 只读字段
    public readonly Vector3 direction = Vector3.forward;
    
    // 委托和事件
    public System.Action onEvent;
    public event System.Action<int> onValueChanged;
}

- 显式禁止序列化

    [System.NonSerialized]

- Header属性

- 编辑模式下执行脚本

- 枚举序列化别名

- 必须包含的组件

- 其它UI扩展面板

- 可选择属性

- 自定义属性

- 参考
https://docs.unity3d.com/Documentation/Manual/unity-attributes.html
https://github.com/teebarjunk/Unity-Built-In-Attributes

=== 通过脚本操作对象和组件
DontDestoryOnLoad():
https://docs.unity3d.com/ScriptReference/Object.DontDestroyOnLoad.html

=== 参考
https://docs.unity3d.com/Manual/ScriptingSection.html

== API
=== 类层次
https://docs.unity3d.com/400/Documentation/ScriptReference/20_class_hierarchy.html

=== Object
https://docs.unity3d.com/Manual/class-Object.html
https://docs.unity3d.com/ScriptReference/Object.html

UnityEngine.Object vs. System.Object
https://discussions.unity.com/t/object-vs-object/172536

=== GameObject
https://docs.unity3d.com/Manual/GameObjects.html
https://docs.unity3d.com/ScriptReference/GameObject.html
游戏对象

=== Component
https://docs.unity3d.com/Manual/unity-components.html
https://docs.unity3d.com/ScriptReference/Component.html
游戏组件

游戏组件与游戏对象的关系

游戏组件的种类

=== MonoBehaviour
==== 简介
https://docs.unity3d.com/Manual/class-MonoBehaviour.html
https://docs.unity3d.com/ScriptReference/MonoBehaviour.html
游戏脚本

继承关系:
MonoBehaviour ――――――▷ Behaviour ――――――▷ Component ――――――▷ Object

Q: MonoBehaviour vs. ScriptableObject
继承关系:
ScriptableObject ――――――▷ Object

==== 生命周期
===== 执行顺序
<<ExecutionOrder>>

===== 初始化和销毁
Awake()/OnDestory()、OnEnable()/OnDisable()、OnApplicationQuit()

Awake(): 脚本首次被初始化时调用，整个生命周期只会执行一次
OnEnable(): 脚本被启动时调用，整个生命周期会执行多次
OnApplicationQuit(): 程序退出时调用
OnDisable(): 脚本被关闭时调用，整个生命周期会执行多次
OnDestory(): 脚本被销毁时调用，整个生命周期只会执行一次

===== 二次初始化
OnEnable()后会调用Reset(), 然后调用Start()方法。

Reset()运行模式下不会执行，通常用来做一些编辑器下的初始化工作，尽量使用UNITY_EDITOR的宏将其包裹起来。

为什么会有Start()呢？
https://stackoverflow.com/questions/34652036/awake-and-start
https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html
https://docs.unity3d.com/ScriptReference/MonoBehaviour.Start.html

===== Awake()、OnEnable()、Start()区别
Awake(): 初始化阶段
🕐 只执行一次：在脚本实例的整个生命周期中只调用一次
🔄 不可靠顺序：不同GameObject的Awake执行顺序不确定
❌ 不关心激活状态：即使GameObject或脚本被禁用也会执行

OnEnable(): 激活响应阶段
🔁 多次执行：每次脚本从禁用变为启用时都会调用
✅ 依赖激活状态：只有脚本启用时才会执行
📢 事件注册的理想位置

Start(): 准备开始阶段
🕐 只执行一次：在脚本启用后，第一次Update之前执行
🔄 可靠顺序：在所有Awake执行完成后才执行
✅ 需要脚本启用：如果脚本初始禁用，则在启用后执行

===== 固定更新FixedUpdate()
默认每0.02秒调用一次，可以在Editor->Project Settings->Time里配置。

FixedUpdate()底层依赖Update(), 会在当前帧的Update()前执行。
如果帧率稳定，表现较好；如果帧率不稳定，FixedUpdate()则会表现糟糕。

通过设置最大间隔时间参数Maximum Allowed Timestep，便不会出现一帧内执行太多次的FixedUpdate()。

一般物理相关的更新都放在FixedUpdate()中。

===== 脚本逻辑更新
Update()
LateUpdate()

Update is called once per frame and is the main function for frame updates.

LateUpdate is called once per frame, after Update has finished. Any calculations performed in Update will have completed when LateUpdate begins. A common use for LateUpdate would be a following third-person camera. If you make your character move and turn inside Update, you can perform all camera movement and rotation calculations in LateUpdate. This will ensure that the character has moved completely before the camera tracks its position.

https://docs.unity3d.com/Manual/execution-order.html#UpdateOrder

性能:
https://unity.com/blog/engine-platform/10000-update-calls
https://discussions.unity.com/t/does-unity-call-the-methods-we-dont-override/801088/3

===== 渲染
逻辑更新结束后就进入场景渲染了、之后是Gizmo渲染、以及GUI渲染。
https://docs.unity3d.com/Documentation/Manual/execution-order.html#Rendering

=== Transform
https://docs.unity3d.com/Manual/ScriptingTransform.html
https://docs.unity3d.com/ScriptReference/RectTransform.html

=== Vectors
https://docs.unity3d.com/Manual/VectorCookbook.html

=== Quaternion
https://docs.unity3d.com/Manual/class-Quaternion.html

=== ScriptableObject
https://docs.unity3d.com/Manual/class-ScriptableObject.html

Q: ScriptableObject vs. MonoBehaviour

=== Time and frame rate management
https://docs.unity3d.com/Manual/TimeFrameManagement.html

=== Mathf
https://docs.unity3d.com/Manual/class-Mathf.html

=== Random
https://docs.unity3d.com/Manual/class-Random.html

=== Debug
https://docs.unity3d.com/Manual/class-Debug.html

=== Gizmos and Handles
https://docs.unity3d.com/Manual/GizmosAndHandles.html

=== 参考
https://docs.unity3d.com/ScriptReference/

== UI
=== 架构
https://blog.codingnow.com/2020/07/game_ui.html
https://blog.codingnow.com/2020/07/font_manager.html
https://gist.github.com/bkaradzic/853fd21a15542e0ec96f7268150f1b62

=== NGUI
NGUI vs. UGUI
https://zhuanlan.zhihu.com/p/445999150

=== UGUI
原生
如果UGUI和NGUI选一个，选UGUI

==== 游戏界面
- Text组件

- 富文本
UGUI支持富文本，但只支持简单的标签，无法支持图文混排。

- 描边和阴影
- 动态字体
- 字体花屏

- Text Mesh Pro
TextMesh Pro (TMP) 是 Unity 官方推出的高级文本渲染系统，用于替代传统的 UnityEngine.UI.Text，提供更清晰、更灵活的文本显示方案。它广泛应用于 UI 文本 和 3D 世界文本，支持丰富的排版、动态字体效果和高性能渲染。
https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/index.html
https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/TextMeshPro/index.html
https://docs.unity3d.com/Packages/com.unity.ugui@2.0/changelog/CHANGELOG.html

    TMP 的核心组件:
        TextMeshProUGUI
            用于 UI 系统（Canvas），继承自 UnityEngine.UI.Graphic。
            适用于 HUD、菜单、对话框等 UI 元素。
        TextMeshPro
            用于 3D 场景（如漂浮文字、3D 游戏中的标签）。
            继承自 MeshRenderer，直接渲染在 3D 空间。

- SDF字体
Signed Distance Field，有向距离场。与Text的位图原理不太一样，保存的是文本每个点相对于文字边缘的距离。
https://docs.unity3d.com/Packages/com.unity.textmeshpro@4.0/manual/FontAssetsSDF.html

- 图文混排
- 样式
- 文字fallback
- 点击事件
- Image组件
- Raw Image组件
- Button组件
- Toggle组件
- Scroll View组件
- Slider组件
- Scrollbar组件
- Dropdown组件(下拉选单)
- InputField组件

- Panel
https://discussions.unity.com/t/what-are-panels/733150/2

==== 界面布局
- Rect Transform组件

- 拉伸
Aspect Ratio Fitter 组件

- 自动布局
Horizonal Layout Group(水平布局组)
Vertical Layout Group(垂直布局组)
Grid Layout Group(垂直布局组)
Content Size Fitter 组件

- 文本自适应
Layout Element(布局元素)组件

- Layout Element组件
强制设置 UI 的包围盒矩形区域，必须配合 Layout Group 组件使用

- Layout Group组件
即Horizonal Layout Group、Vertical Layout Group、Grid Layout Group

- Content Size Filter组件
Layout Group 只能控制布局子节点的排列，使用 Content Size Filter 则可根据子节点的宽高来控制父节点的矩形区域，即 Rect Transform 的宽高。

==== Canvas组件
- 概念
Canvas组件是UI的基础画布，所有UI元素必须放在Canvas对象下面，并且支持嵌套。
Canvas支持3种绘制方式: Overlay(最上层)、Camera与World Space(3D布局)。
其中，用得最多的是Camera，它可以把正交摄像机投影出来的UI元素绘制在Canvas面板上。
3D界面则使用透视摄像机让UI达到更好的交互效果。

- UI摄像机
- 3D界面
- 自适应UI
- Canvas与3D排序

- 裁剪
UGUI提供了两种裁剪方式:
一种是Mask裁剪，优点是可以裁剪出任意形状的UI，缺点是需要额外占用一个Draw Call
另一种是矩形裁剪，Rect Mask 2D并不会额外占用一个Draw Call，应尽可能使用这种方式来裁剪

- 裁剪粒子

==== Atlas图集
- 创建Atlas
- 读取Atlas
- Variant
- 监听加载事件

- 多图集管理

==== 事件系统
- Graphic Raycaster组件
- UI事件
- UI事件管理
- UnityAction和UnityEvent
- C#事件系统
- 3D事件
- K帧动画(关键帧动画)
- 使用Scroll Rect组件制作游戏摇杆
- 点击区域优化

==== API
- RaycastResult
https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.RaycastResult.html
获取:
https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.EventSystem.html#UnityEngine_EventSystems_EventSystem_RaycastAll_UnityEngine_EventSystems_PointerEventData_System_Collections_Generic_List_UnityEngine_EventSystems_RaycastResult__

==== 参考
https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/index.html

=== UI Toolkit
设计目标是替代UGUI，UGUI的最大问题是效率低。
当前还没有UGUI成熟。
自Unity 2021.2起，UI Toolkit被官方内置在Unity中，与UGUI的地位相当。

vs. UGUI
https://docs.unity3d.com/Manual/UI-system-compare.html

- 性能
- 使用
- (当前)不足
- 推荐使用场景

=== IMGUI
早期的UI系统，运行时效率非常低下
编辑模式下的UI通常比较简单，且不太在意效率，因此目前IMGUI被广泛应用在编辑器UI中
https://docs.unity3d.com/Manual/GUIScriptingGuide.html
https://docs.unity3d.com/ScriptReference/UnityEngine.IMGUIModule.html

=== FGUI
跨平台
https://www.fairygui.com/
https://github.com/fairygui

=== 参考
https://www.lfzxb.top/personal-ui-framework-consider/

== 2D游戏开发

=== Sprites
==== Sprite Renderer组件
- 渲染原理
- 渲染排序

- 裁剪
SpriteRender与 Particl System 都可以使用 Sprite Mask 进行裁剪。
裁剪的原理是使用 Shader 的模板测试。

- 2D帧动画

- 2D骨骼动画
vs. spine
Unity 自家的2D骨骼动画（通常指Unity 2D Animation + Sprite Rigging）与第三方解决方案Spine各有优劣。
对于大多数动画需求相对简单的中小型项目，使用前者；对于追求专业动画效果的大型项目，使用Spine。

-IK反向运动
改动子节点影响父节点

- 精灵资源库

==== 像素风
==== 精灵形状
==== 精灵编辑器

=== Tile地图
https://docs.unity3d.com/Manual/tilemaps/tilemaps-landing.html

=== 2D game development in URP
https://docs.unity3d.com/Manual/2d-urp-landing.html

== 3D游戏开发
=== Renderer
- Mesh Renderer(网格渲染器)
- Skinned Mesh Renderer(蒙皮网格渲染器)
- Particle System(粒子系统)
- Trail Renderer(拖尾渲染器)
- Line Renderer(线渲染器)
- Terrain(地形)

=== 游戏对象和资源
- 静态对象
勾选static

- 标记(tag)
个游戏对象只能设置一个独有的标记

- 层
层通常需要和LayerMask配合使用

- Prefab
https://docs.unity3d.com/Manual/Prefabs.html

- Prefab嵌套
https://docs.unity3d.com/Manual/NestedPrefabs.html

- Prefab和游戏对象

- 实例化

- 游戏资源
Unity使用的资源可以分为外部资源和内部资源。
内部资源: unity中创建的资源，如Prefab、场景、材质球、动画剪辑、RenderTexture等；
外部资源: 通过第三方工具产生的资源，如贴图、模型、声音、视频等。
Unity并不会直接使用外部资源，而是将它们生成为另一份资源来使用，好处是可以通过一些配置对原始资源进行加工。
引擎真正使用的资源被保存在Library/Artifacts/中，文件名是生成的资源的MD5名称。
常用的游戏资源类型:

    模型文件:
        文件后缀.fbx
        引擎中的对应类型是Mesh和AnimationClip
    贴图文件:
        文件后缀.bmp、.tif、.tga、.jpg、.png或.psd
        引擎中的对应类型是Texture、Texture2D、Sprite
    音频文件:
        .mp3、.ogg、.wav等
        引擎中的对应类型是AudioClip
    文本文件:
        .txt、.json、.yaml等
        引擎中的对应类型是TextAsset

- 场景
https://docs.unity3d.com/Manual/working-with-scenes.html

- 场景模板
场景模板管线: A Scene Template Pipeline script lets you execute custom code when you create a new scene from the template.
https://docs.unity3d.com/Manual/scene-templates.html

=== 输入系统
- 射线
UI点击事件和点选模型在底层都是通过射线实现的。
检测点击事件就是检测点击的这条射线是否会与物体发生碰撞。

=== Transform组件
- 控制角色移动
- 摄像机跟随
- 插值移动
- 约束条件

=== 3D与2D结合
https://zhuanlan.zhihu.com/p/363965652

== 静态对象
作用: 提升性能
https://docs.unity3d.com/Manual/StaticObjects.html

=== 光照贴图

=== 反射探针

=== 遮挡剔除

=== 静态合批
https://docs.unity3d.com/Manual/static-batching.html
https://docs.unity3d.com/Manual/dynamic-batching.html

=== 导航网格

== graphics
=== render pipelines
==== 概念
https://docs.unity3d.com/Manual/render-pipelines.html
https://zhuanlan.zhihu.com/p/353687806

前向渲染: 适用于光源较少、透明物体较多的场景。
延迟渲染: 适用于光源数量较多的场景，但不适合透明物体，且需要较高的硬件性能。
前向渲染+: 结合了前向渲染和延迟渲染的优点，适合需要处理多个光源且仍需支持透明物体的场景。

===== 前向渲染(Forward Rendering)
- 概念

    前向渲染是传统的渲染方法。
    在前向渲染中，每个像素的渲染都涉及所有的光源。
    每个物体的每个表面会根据场景中所有的光源进行计算，这意味着渲染时会处理每个物体与光源的交互。

- 原理
每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区的信息: 颜色缓冲区与深度缓冲区。利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。
对于每个逐像素光源，都需要进行一次完整的渲染流程。
如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有N个物体，每个物体受M个光源的影响，那么要渲染整个场景一共需要N*M个Pass。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。

- 优点

    简单高效: 适合较少的光源和相对简单的场景。
    透明度支持: 前向渲染在处理透明物体时非常高效，因为它逐个像素进行计算。
    支持多种后处理效果: 可以与许多后处理效果(如光晕、景深等)很好地结合。
    硬件兼容性好: 对旧的硬件或低端设备有更好的支持。

- 缺点

    性能瓶颈: 如果场景中有很多光源，性能可能会下降，因为每个物体都需要计算所有光源的影响。
    难以处理复杂的光源交互: 当有很多动态光源时，前向渲染的性能会受到显著影响。

- 应用场景

    适合低光源、透明物体较多的场景，
    如一些移动设备上的游戏、VR项目，或者需要精细控制每个物体外观的场景。

- 设置

    TODO:
    Shader: 设置Pass的渲染标签

- 参考
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-universal-renderer.html#rendering-path-comparison
https://docs.unity3d.com/Manual/RenderTech-ForwardRendering.html
https://docs.unity3d.com/Manual/PerPixelLights-BuiltIn.html

===== 延迟渲染(Deferred Rendering)
- 概念

    延迟渲染是一种不同于前向渲染的方法，它将渲染过程分为多个阶段，
    特别是在计算光照时，先将场景的几何信息(如位置、法线、颜色等)渲染到多个缓冲区(G-buffer)中，
    再在后续的步骤中计算光源的影响。
    这使得延迟渲染能够在渲染大量光源时，显著减少性能损失。

- 原理
延迟渲染是一种更古老的渲染方法，但由于前向渲染可能造成的瓶颈问题，近几年又流行起来。
除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲(G-buffer)，其中 G 是英文 Geometry 的缩写。
G 缓冲区存储了所关心的表面（通常指的是离摄像机最近的表面）的其它信息，例如该表面的法线、位置、用于光照计算的材质属性等。
延迟渲染主要包含了两个Pass。在第一个Pass中，不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要通过深度缓冲区来实现。当发现一个片元是可见的，就把它的相关信息存储到G缓冲区中。然后，在第二个Pass中，利用G缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。
延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和使用的屏幕空间的大小有关。这是因为，需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张2D图像，计算实际上就是在这些图像空间中进的。
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/deferred-rendering-path.html#implementation-details

- 优点

    处理大量光源:
        延迟渲染非常适合具有大量光源的场景，因为所有光源的计算是在后期阶段统一进行的，与物体的数量无关。
    灵活的光照计算:
        光源不直接影响物体的渲染，可以更灵活地处理多个动态光源。
    适合现代硬件:
        在强大硬件上，延迟渲染能够提供更高的性能，尤其是在场景中有大量动态光源时。

- 缺点

    不适合透明物体:
        延迟渲染处理透明物体时非常困难，因为它依赖于 G-buffer 中的几何数据，透明物体的渲染需要特殊处理。
    内存消耗大:
        需要多个缓冲区来存储物体的几何信息，这会增加显存的消耗。
    对低端硬件性能要求较高:
        延迟渲染对硬件的要求较高，在低端设备上可能不太适用。

- 应用场景

    适合需要处理大量动态光源的场景，如大型开放世界游戏、具有多个光源的场景等。

- 设置

    TODO:

- 参考
https://docs.unity3d.com/Manual/RenderTech-DeferredShading.html

===== 前向渲染+(Forward+ Rendering)
概念:

    前向渲染+(也叫做 Forward+)是前向渲染和延迟渲染的结合，它在某些情况下可以获得两者的优点。
    前向渲染+ 通过将场景分割成多个区域(例如，基于摄像机视锥体的区域)，并为每个区域计算光源的影响，
    避免了每个物体都需要计算所有光源的情况。这使得它在处理多个光源时既高效又能提供较好的性能。

优点:

    减少计算量:
        它通过对光源进行分组，在计算时只考虑光源对视野中的物体的影响，避免了传统前向渲染的性能瓶颈。
    适应多光源场景:
        相比传统的前向渲染，前向渲染+ 可以更好地处理多光源场景，同时保留前向渲染的优势，如对透明物体的支持。

缺点:

    内存和复杂度:
        相较于传统的前向渲染，前向渲染+ 需要更多的内存和计算复杂度，
        因此在一些场景中可能不如传统前向渲染高效。

应用场景:

    适合在需要处理多个光源的同时，仍然保留前向渲染的灵活性和透明物体渲染的场景。

设置:

    TODO:

参考:
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html

===== 选择哪种渲染路径
总体来说，需要根据游戏发布的目标平台来选择渲染路径。如果当前显卡不支持所选的渲染路径，那么 Unity 会自动使用比其低一级的渲染路径。

==== SRP(Scriptable Render Pipeline)
SRP(可编程管线)
基于SRP，Unity开发了URP(通用渲染管线)与HDRP(高清渲染管线)。
https://docs.unity3d.com/Manual/scriptable-render-pipeline-introduction.html

- SRP Core

- 摄像机组件工具
Free Camera组件
Camera Switcher组件

- Look Dev

- Render Graph Viewer

- 对URP的展望

==== URP(Universal Render Pipeline)
===== 概览
Unity自2021版本不再维护内置渲染管线，而是使用URP完全代替它。
https://docs.unity3d.com/Manual/universal-render-pipeline.html
https://docs.unity3d.com/Manual/com.unity.render-pipelines.universal.html

===== 调试与修改

===== vs. 内置渲染管线
内置管线:
https://docs.unity3d.com/Manual/built-in-render-pipeline.html

===== 升级着色器

===== LightMode

===== Shader Graph
- 简介
https://www.zhihu.com/question/278425453

===== Renderer Pipeline Asset
- Rendering
- Qaulity
- Lighting
- Shadows
- Post-processing

- 参考
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/universalrp-asset.html

===== Renderer Pipeline Asset Data
Opaque Layer Mask 不透明的遮罩层
Transparent Layer Mask 半透明的遮罩层
Rendering Path: 前向渲染、前向渲染+、延迟渲染
Depth Priming Mode: 深度预处理模式
Depth Texture Mode: 深度图复制时机
Native Render Pass: 是否启动原生渲染，启动后可以在shader里进行混合编程，但OpenGL ES2不支持。
Transparent Receive Shadows: 是否在透明物体上绘制阴影。
Post Processing: 是否启用后处理，后处理配置文件也可以单独创建。
Stencil: 是否覆盖模板缓冲值
Intermediate Texture: 是否通过中间纹理进行渲染。

===== URP Global Settings
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-global-settings.html

===== Universal Renderer
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-universal-renderer.html

===== URP Renderer Feature
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/urp-renderer-feature.html

==== HDRP(High Definition Render Pipeline)
https://docs.unity3d.com/Manual/high-definition-render-pipeline.html

==== SRP Batch
- 不透明物体绘制

- 半透明物体绘制

- Early-Z

- Alpha Test

- Alpha Blend

- Set Pass Call与Draw Call

- SRP Batch原理
可以减少Set Pass Call的数量，但无法减少Draw Call的数量

==== 渲染技术
===== Blinn-Phong光照计算
===== PBR光照计算
===== 阴影
===== 渲染数据传递
===== SRP流程
===== GPU渲染管线
===== 前向渲染流程
===== 多摄像机与Final Blit
===== ScriptableRenderPass

==== 自定义渲染管线
===== 参与渲染的对象
===== MVP矩阵计算
===== Render Objects
===== Rendering Layer Mask
===== 自定义 Render Feature
===== 裁剪与层
===== UI部分模糊
===== 降低分辨率不包含UI

==== Render Graph
Render Graph是一种用于管理和优化渲染流程的技术，广泛应用于实时渲染和游戏引擎中。它通过图形化的方式描述渲染任务的依赖关系，帮助开发者更高效地组织渲染管线。

1. 核心元素
节点(Node): 每个节点代表一个渲染任务，如绘制场景、应用后处理效果等。
边(Edge): 边表示任务间的依赖关系，确保任务按正确顺序执行。
资源(Resource): 渲染过程中使用的纹理、缓冲区等资源。

2. 主要优势
依赖管理: 自动处理任务间的依赖，避免手动管理。
资源优化: 自动复用和释放资源，减少内存占用。
模块化设计: 便于扩展和维护，适合复杂渲染管线。

3. 工作流程
定义节点和依赖: 明确每个渲染任务及其依赖关系。
构建图结构: 将节点和依赖关系转化为图。
执行渲染: 按图顺序执行任务，确保依赖关系得到满足。

4. 应用场景
游戏引擎: 如Unity、Unreal Engine等，用于管理复杂渲染管线。
实时渲染: VR、AR等需要高效渲染的场景。
后处理效果: 如Bloom、SSAO等，依赖关系复杂的效果。

5. 工具与库
FrameGraph: 用于Vulkan的Render Graph库。
RDG(Render Dependency Graph): Unreal Engine中的实现。
Unity SRP(Scriptable Render Pipeline): 支持Render Graph的模块化渲染管线。

参考:
https://zhuanlan.zhihu.com/p/24181086877

=== 相机
==== 概览
https://docs.unity3d.com/Manual/CamerasOverview.html
https://docs.unity3d.com/Manual/class-Camera.html

render path:
Different rendering paths have different features and performance characteristics that mostly affect lights and shadows. The rendering path used by your Project is chosen in the Player settings. Additionally, you can override it for each Camera.
https://docs.unity3d.com/Manual/RenderingPaths.html

==== The camera view
https://docs.unity3d.com/Manual/CameraView.html

==== 多相机
https://docs.unity3d.com/Manual/MultipleCameras-landing.html

==== (动态)分辨率
https://docs.unity3d.com/Manual/resolution-scale.html

==== 遮挡剔除(Excluding hidden objects with occlusion culling)
https://docs.unity3d.com/Manual/OcclusionCulling-landing.html

核心概念：遮挡剔除是一种优化技术，它会在渲染流程中判断：哪些物体虽然在该相机的视野内，但被其他更近的物体完全挡住了（即被遮挡了）。如果被挡住了，Unity 就不会将它们提交给 GPU 渲染。

关键区别：
视锥体剔除：这是自动发生的，由相机负责。它会剔除在相机视野范围之外的物体。
遮挡剔除：这是一个可选的、更进一步的优化。它会在视锥体剔除的基础上，再剔除那些在视野内但不可见的物体。

示例：
想象一个第一人称游戏，站在一个复杂的基地里，面前是一堵厚实的墙。墙后面有很多桌子、电脑和箱子。虽然这些东西都在视野范围内（因为相机就在墙后面），但肉眼是看不到它们的。如果没有遮挡剔除，Unity 仍然会渲染所有这些物体，浪费大量性能。启用遮挡剔除后，Unity 会知道这些物体被墙挡住了，从而不会去渲染它们。

遮挡剔除如何工作？
Unity 的遮挡剔除系统分为两个阶段：烘焙 和 运行时查询。

遮挡剔除的局限性：
CPU 开销：每帧进行遮挡查询需要消耗 CPU 资源。如果一个场景有成千上万个微小物体，查询开销可能反而会降低性能。
内存开销：烘焙好的遮挡数据会占用磁盘空间和运行时内存。
不适用于所有场景：在开阔地带，几乎没有物体相互遮挡，那么遮挡剔除的收益就很小，此时视锥体剔除是主力。

==== Physical Cameras
物理摄像机是 Unity 2018.1 中引入的一个系统。它超越了传统摄像机的简单参数（如 FOV），引入了真实相机的一些核心物理属性：焦距、传感器尺寸、镜头移位。
启用后，摄像机的视野将不再是一个独立的数值，而是由焦距和传感器尺寸计算得出的结果，这与真实相机的工作原理一致。
https://docs.unity3d.com/Manual/PhysicalCameras.html

==== Camera output
https://docs.unity3d.com/Manual/CameraOutput.html

==== Cameras in URP
https://docs.unity3d.com/Manual/urp/urp-cameras-landing.html

==== Cameras in the Built-In Render Pipeline
https://docs.unity3d.com/Manual/cameras-birp.html

==== 相机故障排除(Troubleshooting cameras)
https://docs.unity3d.com/Manual/CameraTroubleshooting.html

==== cinemachine
https://docs.unity3d.com/Packages/com.unity.cinemachine@3.1/manual/index.html

=== color
https://docs.unity3d.com/Manual/graphics-color.html

- color space
https://docs.unity3d.com/Manual/LinearLighting.html
gamma color space is the historically standard format, linear color space rendering gives more precise results.
Is there a reason to ever use gamma color space?
Only when you're targeting old hardware or old graphics APIs. OpenGL ES 2.0 and WebGL 1.0 don't support linear space, besides that gamma can be faster than linear on old mobile devices.
对于需要更真实光照效果的项目，建议使用Linear颜色空间；而对于更注重性能和兼容性的项目，Gamma颜色空间可能是一个更好的选择。

- high dynamic range
https://docs.unity3d.com/Manual/HDR.html

=== 光照
==== 概览
https://docs.unity3d.com/Manual/LightingOverview.html
https://docs.unity3d.com/Manual/LightingInUnity.html

==== Lighting configuration workflow
https://docs.unity3d.com/Manual/lighting-configuration-workflow.html

==== Light sources
https://docs.unity3d.com/Manual/lighting-light-sources.html

==== Direct and indirect lighting
https://docs.unity3d.com/Manual/direct-and-indirect-lighting.html

==== Shadows
https://docs.unity3d.com/Manual/Shadows.html

==== Reflections
https://docs.unity3d.com/Manual/reflections-landing.html

==== Lighting in URP
https://docs.unity3d.com/Manual/urp/lighting-landing.html

==== Lighting in the Built-In Render Pipeline
https://docs.unity3d.com/Manual/lighting-birp.html

==== Lighting reference
https://docs.unity3d.com/Manual/lighting-reference.html

=== 纹理
https://docs.unity3d.com/Manual/Textures-landing.html

=== 材质
https://docs.unity3d.com/Manual/Materials.html

=== shader
==== 分类
1 Shaders that are part of the graphics pipeline are the most common type of shader. They perform calculations that determine the color of pixels on the screen. In Unity, you usually work with this type of shader by using Shader objects.
2 Compute shaders perform calculations on the GPU, outside of the regular graphics pipeline.
3 Ray tracing shaders perform calculations related to ray tracing.

==== vs. 传统Shader
Unity Shader != 真正的Shader
在传统Shader里，只可以编写特定类型Shader，而在Unity Shader里，可以在同一个文件里同时包含需要的顶点着色器和片元着色器代码。
在传统Shader里，无法设置一些渲染设置，例如是否开启混合，深度测试等。在Unity Shader中，通过一行特定指令就可以完成这些设置。
在传统Shader里，需要编写冗长的代码来设置着色器的输入和输出，在Unity Shader中，只需要在特定语句块中声明一些属性，就可以依靠材质来方便地改变这些属性。

==== Unity Shader的形式
- 表面着色器(Surface Shader)
Unity自己创造的一种着色器代码类型。它需要的代码量很少，Unity在背后做了很多工作，但渲染的代价较大。
表面着色器在本质上就是顶点、片元着色器，它们看起来很不像是因为表面着色器是Unity在顶点/片元着色器上层为开发者提供 的一层抽象封装，但在背后，Unity还是会把它转化成包含一个多Pass的顶点/片元着色器。可以在UnityShader的导入设置面板中单击show generated cocde按钮来查看生成的真正的顶点／片元着色器代码。可以说，从本质上来讲，Unity Shader只有有两种形式: 顶点/片元着色器和固定函数着色器(在Unity 5.2以后的版本中，固定函数着色器 也会在背后被转化成顶点/片元着色器，因此从本质上来说Unity中只存在顶点/片元着色器)。

- 顶点/片元着色器(Vertex/Fragment Shader)

- 固定函数着色器(已废弃)
由于现在绝大多数GPU都支待可编程的渲染管线，这种固定管线的编程方式已经逐渐被抛弃。实际上，在Unity 5.2中，所有固定函数着色器都会在背后被Unity编译成对应的顶点/片元着色器，因此真正意义上的固定函数着色器已经不存在了。

==== 与 CG/HLSL 之间的关系
UnityShader是用ShaderLab语言编写的，但对于表面着色器和顶点/片元着色器，可以在ShaderLab内部嵌套CG/HLSL语言来编写这些着色器代码。这些CG/HLSL代码是嵌套在CGPROG RAM和ENDCG之间的。由于CG和DX9风格的HLSL从写法上来说儿乎是同一种语言，因此在Unity里CG和HLSL是等价的。

==== 数学基础
二维笛卡尔坐标系:

    在屏幕映射时，OpenGL y轴朝上，DirectX y轴朝下。

三维笛卡尔坐标系:

    unity使用左手坐标系。

坐标空间:

    模型空间，世界空间，观察空间，裁剪空间，屏幕空间。
    其中，仅观察空间中unity使用右手坐标系，其它均使用左手坐标系。
    除了这些最重要的坐标空间，实际开发中也会遇到其它空间:
        例如切线空间(tangent space, 通常用于法线映射):
            https://www.zhihu.com/question/23706933

内置变量:

    变换矩阵、摄像机和屏幕参数

==== 光照
===== 概念
- 光源
Directional Light(方向光)
Spot Light(聚光灯)
Point Light(点光源)
Area Light(面光源)

- 吸收和散射
高光反射(specular)表示物体表面是如何反射光线的
漫反射(diffuse)表示有多少光线会被折射、吸收和散射出表面

- 着色
着色(shading)指的是，根据材质属性(如漫反射屈性等)、光源信息(如光源方向、辐照度等)，使用一个等式去计算沿某个观察方向的出射度的过程。这个等式称为光照模型Lighting Model)。
不同的光照模型有不同的目的。例如，一些用于描述粗糙的物体表面，一些用于描述金属表面等。

- BRDF光照模型
BRDF(双向反射分布函数，Bidirectional Reflectance Distribution Function)是描述光线如何从表面反射的数学模型，广泛应用于计算机图形学中的光照计算。它定义了入射光与出射光之间的关系，帮助模拟真实世界中的光照效果。

===== 标准光照模型
====== 概念
虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。实际上，在BRDF理论被提出之前，标准光照模型就已经被广泛使用了。

在1975年，著名学者裴祥风(Bui Tuong Phong)提出了标准光照模型背后的基本理念。标准光照模型只关心直接光照(direct light)，也就是那些直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线。

虽然标准光照模型仅仅是一个经验模型，也就是说，它并不完全符合真实世界中的光照现象。但由于它的易用性、计算速度和得到的效果都比较好，因此仍然被广泛使用。

- vs. PBR
PBR 基于物理原理，能够提供更加真实和一致的光照和材质表现，适用于现代图形学中的高质量渲染。PBR 考虑了多个物理因素，如能量守恒、金属度、粗糙度、反射率等，确保了物体与环境的交互符合真实世界的物理定律。
标准光照模型: 通常更简单、计算量较小，适合早期图形学应用，但在材质和光照的模拟方面没有 PBR 真实和一致。

====== 环境光(ambient)
- 作用
模拟场景中间接光照的全局基础亮度，避免完全黑暗的区域。

- 关键点
与光源和视角无关，是恒定值。
常用于补足未被直接光源照亮的区域。

====== 自发光(emissive)
- 作用
使材质自身发光（如霓虹灯、屏幕），不受外部光源影响。

- 关键点
不参与光照计算，直接叠加到最终颜色。
在延迟渲染中可能需要特殊处理（如作为光源）

====== 漫反射(diffuse)
- 物理原理
光线均匀散射到所有方向，表现材质的"基础颜色"。

- 视觉表现
柔和均匀

- 计算复杂度
低（仅点积）

- 典型用途
布料、粗糙表面

- 计算公式(Lambert 模型)
ifdef::env-github[]
```math
I_{\text{diffuse}} = k_d \cdot I_{\text{light}} \cdot (\mathbf{L} \cdot \mathbf{N})
```
*参数说明*：
- $k_d$：材质的漫反射系数（颜色/贴图）。
- $I_{\text{light}}$：光源强度。
- $\mathbf{L}$：归一化的光线方向向量（从表面点到光源）。
- $\mathbf{N}$：归一化的表面法线向量。
- $(\mathbf{L} \cdot \mathbf{N})$：点积（clamped 到 `[0,1]`）。
endif::[]
ifndef::env-github[]
stem:[I_{\text{diffuse}} = k_d \cdot I_{\text{light}} \cdot (\mathbf{L} \cdot \mathbf{N})]
*参数说明*：
- latexmath:[k_d]：材质的漫反射系数（颜色/贴图）。
- latexmath:[I_{\text{light}}]：光源强度。
- latexmath:[\mathbf{L}]：归一化的光线方向向量（从表面点到光源）。
- latexmath:[\mathbf{N}]：归一化的表面法线向量。
- latexmath:[(\mathbf{L} \cdot \mathbf{N})]：点积（clamped 到 `[0,1]`）。
endif::[]

- 关键点
与观察方向无关，仅取决于光线与法线的夹角。
背面光照（点积 < 0）时通常忽略。

====== 高光反射(specular)
- 物理原理
光线在光滑表面上的镜面反射，形成亮斑(高光)。

- 视觉表现
明亮光斑

- 计算复杂度
高（需反射/半角向量）

- 典型用途
金属、光滑塑料

====== Phong模型
一个完整的局部光照通常由三个（或四个）部分组成:
环境光（Ambient）：模拟从周围环境间接反射过来的光，防止完全黑暗的区域出现。它是一个常数。
漫反射（Diffuse）：模拟粗糙表面对光线的均匀散射。光线入射角度不同，亮度不同，但与视角无关。
高光反射（Specular）：模拟光滑表面上的亮斑（高光）。它的强度高度依赖于视角方向和光线入射方向。
自发光（Emissive）：（可选）模拟物体自身发出的光，不受其他光源影响。

Phong 和 Blinn-Phong 的核心区别就在于如何计算这个高光项。

====== Blinn-Phong模型
局限性:
首先，有很多重要的物理现象无法用 Blinn-Phong 模型表现出来，例如菲涅耳反射(Fresnel reflection)。
其次，Blinn-Phong 模型是各项同性(isotropic)的，也就是说，当固定视角和光源方向旋转这个表面时，反射不会发生任何改变。但有些表面是具有各向异性(anisotropic)反射性质的，例如拉丝金屈、毛发等。

====== 逐像素还是逐顶点
光照模型使用的数学公式，那么在哪里计算这些光照模型呢？通常来讲，有两种选择：在片元着色器中计算，也被称为逐像素光照(per-pixel lighting)；在顶点着色器中计算，也被称为逐顶点光照(per-vertex lighting)。

在逐像素光照中，以每个像素为基础，得到它的法线（可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的），然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为Phong着色(Phong shading)，也被称为Phong插值或法线插值着色技术。这不同于之前讲到的Phong光照模型。

与之相对的是逐顶点光照，也被称为高洛德着色(Gouraud shading)。在逐顶点光照中，在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。由于顶点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小千逐像素光照。但是，由于逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有非线性的计算（例如计算高光反射时）时，逐顶点光照就会出问题。而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。

===== Unity中的环境光与自发光

===== 在Unity Shader中实现漫反射光照模型
====== 逐顶点
====== 逐像素
====== 半兰伯特模型

===== 在Unity Shader中实现高光反射光照模型
====== 逐顶点
====== 逐像素

===== 使用Unity内置的函数

===== Unity的渲染路径

===== Unity的光源类型
unity一种支持4种光源类型: 平行光、点光源、聚光灯和面光源(area light)。

- 平行光
平行光没有一个具体的位置，因此没有衰减的概念，即光照强度不会随着距离发生改变。
平行光可以放在场景中的任意位置。
平行光到场景中所有点的方向都是一样的。

- 点光源
点光源照亮的空间是有限的，它由空间的一个球体定义。
点光源是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。

- 聚光灯
照亮空间也是有限的，但不再是简单的球体，而是由空间中的一块锥形区域定义。
聚光灯可以用于表示由一个特定位置出发，向特定方向延伸的光。

===== Unity的光照衰减
- 用于光照衰减的纹理
- 使用数学公式计算衰减

===== Unity的阴影
====== 阴影是如何实现的
在实时渲染中，最常使用的是一种名为 Shadow Map 的技术。它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。Unity 使用的就是这种技术。

====== 不透明物体的阴影
====== 使用帧调试器查看阴影绘制过程
====== 统一管理光照衰减和阴影
====== 透明度物体的阴影

==== 纹理
===== 单张纹理
- 纹理属性

===== 凹凸映射(bump mapping)
====== 实现原理

    凹凸映射通常使用以下两种方式之一:
        高度图(Height Map):
            灰度图像表示表面高度变化
            亮色区域表示"凸起"，暗色区域表示"凹陷"
        法线图(Normal Map):
            RGB图像直接存储法线方向
            R、G、B通道分别对应法线的X、Y、Z分量

====== 高度纹理

====== 法线纹理
- 模型空间的法线纹理(object-space normal map)
• 实现简单，更加直观。甚至都不需要模型原始的法线和切线等信息，也就是说，计算更少。生成它也非常简单，而如果要生成切线空间下的法线纹理，由于模型的切线一般是和UV方向相同，因此想要得到效果比较好的法线映射就要求纹理映射也是连续的。
• 在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙）较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。

- 切线空间的法线纹理(tangent-space normal map)
• 自由度很高。模型空间下的法线纹理记录的是绝对法线信息，仅可用于创建它时的那个模型，而应用到其它模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果。
• 可进行UV动画。比如，可以移动一个纹理的UV坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果。原因同上。这种UV动画在水或者火山熔岩这种类型的物体上会经常用到。
• 可以重用法线纹理。比如一个砖块，仅使用一张法线纹理就可以用到所有的6个面上。
• 可压缩。由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此我们可以仅存储XY方向，而推导得到Z方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值，不可压缩。
切线空间在很多情况下都优于模型空间，而且可以节省美术人员的工作。

====== 实践
====== Unity中的法线纹理类型

===== 渐变纹理(ramp texture)

===== 遮罩纹理(mask texture)
dota2:
https://help.steampowered.com/zh-cn/faqs/view/299C-D7F9-09A5-98B6

===== 立方体纹理

===== 渲染纹理

===== 程序纹理

==== 透明效果
===== 渲染顺序
===== Unity Shader的渲染顺序
===== 透明度测试(alpha test)
===== 透明度混合(alpha blending)
===== 开启深度写入的半透明效果
===== ShaderLab的混合命令
===== 双面渲染的透明效果

==== 动画
===== 纹理动画
===== 顶点动画

==== 屏幕后处理效果(screen post-processing effects)

==== shaders in URP
https://docs.unity3d.com/Manual/urp/shaders-in-universalrp.html
https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/shaders-in-universalrp.html

==== 注意事项
- 避免不必要的计算
- 慎用分支和循环语句

==== 工具
===== Shader Graph
https://www.zhihu.com/question/475771378
注意: ShaderForge已废弃

==== 参考
https://docs.unity3d.com/Manual/Shaders.html
《Unity Shader入门精要》

=== virtual geometry(虚拟几何体)
https://docs.unity.cn/cn/tuanjiemanual/Manual/VirtualGeometry.html

Q: 局限性/限制？

=== 参考
https://docs.unity3d.com/Manual/Graphics.html
https://docs.unity3d.com/cn/current/Manual/Graphics.html

== 动画
=== 概念
- 模型动画与非模型动画

    模型动画:
        顶点动画与骨骼动画
    非模型动画:
        非模型动画指的是不依赖3D网格模型或骨骼系统的动画技术，主要包括以下几种类型:
        帧动画/2D精灵动画、粒子系统、程序化动画如水面波动、着色器动画、矢量动画等。

- Spine与Unity骨骼动画
Spine 和 Unity 的骨骼动画系统是两种不同的工具，分别用于 2D 和 3D 动画制作与集成。
Spine与Unity骨骼动画的区别:
[cols="1,1,1", options="header"]
|===
| 特性               | Spine                             | Unity 骨骼动画
| *主要用途*         | 专为 2D 骨骼动画设计                | 主要用于 3D 骨骼动画，也支持 2D 动画
| *动画类型*         | 2D 骨骼动画                        | 3D 骨骼动画为主，2D 骨骼动画为辅
| *工具链*           | 独立的 Spine 编辑器                | Unity 内置的 Animator 和动画工具
| *性能优化*         | 轻量级，适合移动端                  | 依赖项目复杂度，3D 动画可能较重
| *集成性*           | 需要导入 Spine 运行时库到 Unity     | 完全集成在 Unity 引擎中
| *学习曲线*         | 专注于 2D 动画，学习曲线较低         | 需要掌握 Unity 的动画系统和工具链
| *适用场景*         | 2D 游戏、移动端游戏                 | 3D 游戏、2D/3D 混合项目
|===

=== 动画文件
1. Animation（旧版动画系统）
适用场景：简单的动画播放，适合小型项目或非人形动画（如物体移动、旋转等）。
核心组件：Animation 组件 + .anim 动画片段。

2. Animator（新版动画系统，Mecanim）
适用场景：复杂动画逻辑（如角色状态机、混合动画、人形动画重定向）。
核心组件：Animator 组件 + Animator Controller（状态机） + Animation Clip。

使用新版动画，也不一定必须创建Animator Controller文件，通过Playable的方式也可以使用代码处理动画。

=== 制作动画
内部动画
外部动画(如FBX、GLTF等)

=== 动画事件
=== 骨骼动画优化
=== 播放动画
=== 切换动画
=== 动画混合
=== 老版动画
=== SimpleAnimation 组件
=== 控制动画进度
=== 特殊动画行为
=== Playable 组件
=== 使用 Playable 自定义脚本

=== 模型换装
- 更换材质

- 更换模型
不带蒙皮信息的mesh

- 更换蒙皮模型
skinned mesh

=== spine
https://esotericsoftware.com/spine-unity

=== timeline
https://docs.unity3d.com/Manual/com.unity.timeline.html

🔹 timeline缺点
1. 性能开销
Playables API 底层开销：相比直接使用 Animator 或代码控制动画，Timeline 会带来额外性能负担，尤其在低端设备上。
不适合高频更新动画（如实时战斗动作）。
2. 动态控制较弱
运行时修改受限: 虽然可以动态绑定对象，但时间轴结构（如轨道、Clip）不能在运行时动态修改。
条件分支困难: 难以实现“根据玩家选择播放不同剧情”的逻辑，需配合代码（如 PlayableDirector.Pause() + 脚本跳转）。
3. 复杂动画混合的局限性
混合精度不足: 复杂动画混合（如上半身攻击 + 下半身跑步）仍需依赖 Animator Layer 或代码。
不支持物理动画（如布娃娃效果）。
4. 学习成本与工作流问题
陡峭的学习曲线: 需掌握 Playables API、Track 类型、Signal 系统 等概念。
版本兼容性: 不同 Unity 版本的 Timeline 功能可能有差异（如 2019 后新增的 Track 类型）。
5. 调试困难
问题难以定位: 如果动画未播放，可能原因包括绑定丢失、Clip 配置错误、权重问题等，需逐项排查。

🔹 Timeline vs. 替代方案
需求场景	Timeline	Animator	代码控制（Coroutine/DOTween）	Cinemachine
过场动画/剧情序列	✅ 最佳	❌ 不适用	⚠️ 需手动同步	✅ 配合使用
角色动画混合	✅	✅ 更灵活	❌ 复杂	❌ 不适用
高频实时动画（如战斗）	❌ 性能差	✅ 推荐	✅ 直接控制	❌ 不适用
动态条件分支	⚠️ 需配合代码	✅ 状态机	✅ 灵活	❌ 不适用

🔹 使用建议
适合 Timeline 的场景:
    电影式叙事、固定剧情动画。
    需要音画同步的过场（如对话 + 镜头切换）。
    快速原型设计（无需代码编排动画）。
避免 Timeline 的场景:
    需要高频更新的实时动画。
    复杂的状态机逻辑（用 Animator 更合适）。
    完全动态生成的动画（如程序化关卡）。

🔹 优化技巧
减少活跃轨道数量以降低性能开销。
使用 Signal Receiver 替代频繁的 Update 检测。
结合 Animator 处理复杂动画混合。

🔹 总结
Timeline 是 Unity 中强大的叙事和动画编排工具，特别适合线性内容，但在动态控制和性能敏感场景下需谨慎使用。
合理搭配 Animator、DOTween 或代码控制，可以最大化其价值。

=== DOTween
补间动画(Tweening)
https://github.com/Demigiant/dotween

=== Slate
Slate 是一个流行的剧情动画（Cinematic）和序列化任务（Sequencing）插件，主要用于制作游戏中的过场动画、任务流程、对话系统等交互式内容。它提供可视化的时间轴（Timeline）编辑功能，类似于 Unity 官方的 Timeline 工具，但更轻量且专注于游戏逻辑的序列化控制。
https://slate.paradoxnotion.com/

=== 参考
https://docs.unity3d.com/Manual/AnimationSection.html

== physical
=== 概念
刚体
碰撞体

Unity 2D和3D项目的物理引擎均基于PhysX。

=== 2D物理系统
https://docs.unity3d.com/Manual/2d-physics/2d-physics.html

- Collider 2D组件
- Rigidbody 2D组件
- 碰撞事件
- 碰撞方向
- 触发器监听
- 复合碰撞体
- Effectors 2D组件
- 关节
- 物理材质与恒定力
- 计算区域

=== 3D物理系统
- 角色控制器(Charator Controller)
- 刚体物理(Rigibody Physics)
- 碰撞体(Collider)
- 关节(Joints)
- 衔接(Articulations)
- 布娃娃物理(Ragdoll Physics)
- 布料(Cloth)

=== 参考
https://docs.unity3d.com/Manual/PhysicsSection.html

== 导航
https://docs.unity3d.com/Manual/com.unity.ai.navigation.html

== 持久化

== 资源管理
=== 编辑器模式
- 游戏资源

- 加载资源

- 卸载资源
Resources.UnloadAsset()
Resources.UnloadUnusedAssets()

- 创建与修改资源

- 创建与修改游戏对象

- reimport
Q: reimport本质上是干什么的？
Q: 什么时候需要reimport?

=== 运行模式
==== 参与打包的资源
直接引用: 资源被场景中的 GameObject、其他资源（如材质、预制体）或脚本中的公共变量所引用。
Resources 文件夹: 位于任何名为 Resources 文件夹内的资源（无论是否被引用）。
Addressables / AssetBundles: 被配置为 Addressable 或打包进 AssetBundle 的资源。
Player Settings 配置: 如启动画面、图标、默认字体等。
StreamingAssets 文件夹: 该文件夹内容会原封不动地复制到构建目录，但不参与编译。

- Resources
<<Resources>>

- 通过脚本计算依赖

- StreamingAssets
<<StreamingAssets>>

- 场景资源
只需要将场景添加到Build Settings中就可以参与打包了。

=== AssetBundle
- 设置AB

- 设置依赖

- 纯脚本打包

- 差异打包

- AB压缩格式

- 加载AB

- 内存与卸载

- 场景AB

- CDN下载流程

- 加载流程

- 多进程AB构建

=== 代码编译
ScriptAssemblies/Assembly-CSharp.dll

- Plugins
Plugins目录下的代码会编译到Assembly-CSharp-firstpass.dll中，修改逻辑代码就不再同时编译这部分代码了。
Plugins目录下的代码是优先编译的，Assembly-CSharp.dll可以调用它们，但是它们不能反向调用Assembly-CSharp.dll。

- Assembly

- Editor
Assembly-CSharp-Editor.dll

- IL2CPP

- AB中的脚本

- 热更新代码

=== Shader编译
- 打包与运行

- Shader重复打包

- Shader宏

- Shader与AB包

- Shader打包剥离

=== 美术资源管理
- 版本管理
- 材质丢失
- 协作开发与多工程
- 美术资源生成

== 自动化与打包
=== 自动化设置资源
- 设置贴图格式
默认贴图格式是Automatic

- 动画控制器
应该禁止使用Animation Controller文件

- 设置模型格式

- 导出动画文件

- 生成角色Prefab

- 生成场景

- 场景dirty状态

- 自动生成UI图集

- 更换Shader残留宏

- 自动生成变种收集器

- 剔除顶点色

=== 可编程构建管线系统
https://docs.unity3d.com/Packages/com.unity.scriptablebuildpipeline@2.0/manual/index.html

=== Build(构建)相关
https://docs.unity3d.com/Documentation/ScriptReference/BuildOptions.html

- android
https://docs.unity3d.com/Documentation/Manual/android-build-settings.html
Q: Script Debugging作用是?

=== 自动化打包
- 打包过程中的事件

- 打包机的选择
建议windows打包机构建windows和android包，macOS构建iOS和macOS包。

- 打包后自动压缩
- 调用shell脚本
- 命令行打开工程
- 脚本化打包参数
- Jenkins

=== 平台
==== andorid
https://docs.unity3d.com/Documentation/Manual/android-building-and-delivering.html
Q: APK vs. AAB(Android App Bundle)

== 热重载
hot reload
https://www.bilibili.com/video/BV14X4y1y7mB/?vd_source=8390cf4acc81f67e6df66ea39d1fc6fe

== 热更新
=== 概览
https://zhuanlan.zhihu.com/p/535748877

=== hybridclr
https://hybridclr.doc.code-philosophy.com/docs/intro
https://github.com/focus-creative-games/inspect_hybridclr
https://github.com/focus-creative-games/hybridclr

- 基于AOT(本地机器代码执行)+Interpreter(IL解释执行)使用同一个内存数据对象，没有跨域访问的问题。
xLua或ILRuntime热更方案都有一条原则，尽量减少与Unity C#层的交互，但是这种交互又避免不了而且量大，比如要在逻辑热更代码里面访问Unity C#的GameObject对象数据，最终在运行的时候，GameObject会在AOT模式下的原生内存数据结构对象。由于xLua或ILRuntime有自己的虚拟机，所以不能直接访问原生GameObject数据对象，往往要把访问里面的数据包装成函数，这样性能开销就大大的增加了。而hybrid是在IL2CPP模式下的解释执行，直接可以访问原生的数据对象。

- 逻辑代码更新后(1.0版本到2.0版本)，如果发布新版本2.0(重新安装新版本的app)，可以直接把更新的逻辑，直接使用AOT编译出来，不用解释执行，从而获得AOT的性能。
而基于xLua, ILRuntime的热更方案开发的代码(1.0版本到2.0版本)，用户即使重新安装2.0客户端后，还是解释执行，新版本的性能无法达到AOT的性能级别。

- 相比传统的Lua或ILRuntime热更，能更新任意部分的代码。
不用像Lua或ILRuntime一样，分热更代码+框架代码，框架代码有bug还不能热更。

=== MISC
https://zhuanlan.zhihu.com/p/676793950
https://mp.weixin.qq.com/s/5xfq-EveRWmBnHMfC-icRA

== 多语言

== 扩展
=== package
==== vs. plugin
https://forum.unity.com/threads/unity-plugin-vs-unity-package.263003/

==== Packages and package management
入口: Window > Package Management > Package Manager
https://docs.unity3d.com/Manual/PackagesList.html
https://docs.unity3d.com/Manual/FeatureSets.html

==== rider
https://docs.unity3d.com/Manual/com.unity.ide.rider.html
pausepoints:
https://blog.jetbrains.com/dotnet/2020/06/11/introducing-unity-pausepoints-for-rider/

=== 插件
https://docs.unity3d.com/Manual/Plugins.html

=== 编辑器扩展
https://docs.unity3d.com/Manual/ExtendingTheEditor.html
Unity 编辑器扩展允许开发者自定义 Unity 编辑器界面，创建专用工具来提升工作流程效率。

核心类:

    EditorWindow - 创建自定义窗口
    Editor - 自定义组件检视面板
    PropertyDrawer - 自定义属性绘制器
    MenuItem - 添加菜单项

关键特性:

    使用 UnityEditor 命名空间
    脚本必须放在 Editor 文件夹中
    在编辑器模式下运行

== framework
=== gf
https://github.com/EllanJiang/GameFramework
https://www.lfzxb.top/gameframework-all/

=== et
https://github.com/egametang/ET
https://github.com/egametang/ET/tree/master/Book
https://www.lfzxb.top/et-all/

=== ecs(entity component system)
https://en.wikipedia.org/wiki/Entity_component_system
https://developer.unity.cn/projects/677ca79dedbc2a001f135aec
https://developer.unity.cn/projects/677cd9d4edbc2a001eac2828
https://indienova.com/indie-game-development/gdc-overwatch-gameplay-architecture-and-netcode/
https://blog.codingnow.com/eo/ecs/

=== dots(data-oriented tech stack)
https://unity.com/dots

=== mvvm
https://github.com/vovgou/loxodon-framework/

=== 参考
https://www.zhihu.com/question/268285328

== 库
=== 寻路
https://github.com/recastnavigation/recastnavigation

=== 行为树
https://github.com/meniku/NPBehave

== 工具
=== stack trace

==== Stack trace logging
https://docs.unity3d.com/Manual/StackTrace.html

缺点:

    only to debug.
    Limit the type of messages that display a stack trace.

==== StackTrace Class
https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stacktrace

缺点:

    It will not give stack traces for inlined method calls.
    If compiled in release mode, it will probably not have file and line numbers.
    there may be an odd platform it doesn’t support.

参考:
https://discussions.unity.com/t/how-to-get-a-reliable-stack-trace-in-release-build/

==== Release中的文件名、方法名、行号？
- 方法1: csharp StackTrace Class + Assembly带上PDB
https://learn.microsoft.com/en-us/dotnet/api/system.reflection.assembly.load?view=net-9.0#system-reflection-assembly-load(system-byte()-system-byte())

- 方法2: Unity 2023.1 and later
https://docs.unity3d.com/Manual/il2cpp-managed-stack-traces.html

参考:
https://discussions.unity.com/t/il2cpp-missing-line-numbers-in-stack-trace/
https://discussions.unity.com/t/file-and-line-numbers-in-stack-trace/
https://stackoverflow.com/questions/72258670/c-sharp-get-the-calling-methods-line-number-class-file-and-method-name-etc
https://www.lfzxb.top/il2cpp-linenumber-recover/

=== unit test
https://docs.unity3d.com/Manual/testing-editortestsrunner.html

=== roslyn
https://docs.unity3d.com/Manual/roslyn-analyzers.html

=== Visual Studio
https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html

=== dnSpy
https://github.com/Neoshrimp/dnSpy-Unity-mono-unity2021.xx
https://github.com/Neoshrimp/dnSpy-Unity-mono-unity2021.xx/tree/unity2021/builds/Release/unity-2021.3.27f1-toolset_v141 经验证，对于unity2021.3.27f1可用
https://github.com/dnSpyEx/dnSpy-Unity-mono
https://github.com/dnSpyEx/dnSpy/wiki/Debugging-Unity-Games
http://blog.ihopenot.men/2022/03/31/dnSpy%E8%B0%83%E8%AF%95Unity%E7%A8%8B%E5%BA%8F/
https://github.com/wh0am15533/Patched-Unity-Mono

=== 日志
- SRDebugger
https://www.stompyrobot.uk/tools/srdebugger/
https://www.stompyrobot.uk/tools/srdebugger/documentation/
SRDebugger除了日志，还提供选项、系统信息等功能

- android
android studio: https://developer.android.com/studio/debug/logcat?hl=zh-cn

== 性能优化
=== 概要
https://docs.unity3d.com/Manual/UnderstandingPerformance.html
https://docs.unity3d.com/Manual/analysis.html
游戏性能优化与逆向分析技术: https://zhuanlan.zhihu.com/p/697337400

=== Profiler
https://docs.unity3d.com/Manual/Profiler.html
https://docs.unity3d.com/ScriptReference/Profiling.Profiler.html

android: https://docs.unity3d.com/Manual/android-profile-on-an-android-device.html
adb forward tcp:34999 localabstract:Unity-{insert bundle identifier here}

Q: Unity.Profiling vs. UnityEngine.Profiling?
https://discussions.unity.com/t/what-the-different-between-unity-profiling-and-unityengine-profiling/

=== UWA
https://www.uwa4d.com/
UWA GOT (Game Optimization Toolkit) 本地性能分析工具，支持 PC/Android/iOS
UWA Pipeline 云端自动化测试，多设备并行测试
UWA Localization 本地化性能分析，适用于海外版本优化
UWA Deep Memory 深度内存分析，检测泄漏和冗余资源

=== Frame Debugger
https://docs.unity3d.com/Manual/FrameDebugger.html
https://docs.unity3d.com/Manual/FrameDebugger-landing.html

=== perfdog
https://perfdog.qq.com/helpCenter

=== burst
- 概要
Burst 是一个高性能的 C# 编译器，专门用于优化计算密集型任务。
它将 C# 代码直接编译为高度优化的本地机器码(Native Code)，绕过传统的 .NET 运行时(如 Mono 或 IL2CPP)。
Burst 使用 LLVM 作为后端编译器，生成针对特定 CPU 架构优化的机器码，支持 SIMD(单指令多数据流)指令集，以加速并行计算。

- 参考
https://docs.unity3d.com/Manual/com.unity.burst.html

=== API/库/框架
==== string
- Unity ZString
https://github.com/Cysharp/ZString
https://neuecc.medium.com/zstring-zero-allocation-stringbuilder-for-net-core-and-unity-f3163c88c887
栈上分配: struct避免堆分配
可扩展缓冲区: 初始使用栈空间，超量时切换至数组
Span操作: 直接操作内存，避免接口调用开销

- zstring
https://github.com/871041532/zstring

==== Cysharp
https://github.com/Cysharp

=== 参考
https://docs.unity3d.com/Manual/analysis.html
https://docs.unity3d.com/Manual/graphics-performance-profiling.html
https://www.bilibili.com/read/readlist/rl511863?spm_id_from=333.1369.opus.module_collection.click

== 团结引擎
https://docs.unity.cn/cn/tuanjiemanual/Manual/intro.html

- 注意事项
微信小游戏不能使用多线程:
https://developer.unity.cn/ask/question/672c2e45edbc2a4e04a81cee

== tutorial
https://catlikecoding.com/unity/tutorials/
https://www.youtube.com/playlist?list=PLPV2KyIb3jR4GH32npxmkXE-AHnlamcdG

== project
https://github.com/Unity-Technologies

== 源码
https://www.zhihu.com/question/270076640
https://github.com/Unity-Technologies/UnityCsReference

== 项目规范
https://www.zhihu.com/question/3854922557/answer/57599729291

== AI
https://unity.com/ai
https://docs.unity3d.com/Manual/unity-ai.html
Unity Muse
Unity Sentis

== 参考
《Unity3D游戏开发》第3版 宣雨松
https://docs.unity3d.com/Manual/index.html
https://unity.com/how-to#ebooks-for-programmers
https://developer.unity.cn/u/unityji-zhu-bo-ke?tab=article