:toc:
:toclevels: 4
:hardbreaks-option:

== 文件

=== 基础
缓冲IO与非缓冲IO: 是否经过标准库缓存
直接IO与非直接IO: O_DIRECT
阻塞IO与非阻塞IO: O_NONBLOCK
同步IO与非同步IO: O_SYNC, O_DSYNC

open, read, write, close, lseek, ioctl, fcntl(FD_CLOEXEC)
Q: 线程安全?
A: 是

2>&1
dev/fd/n: n是与进程中的打开文件描述符相对应的编号
dev/null

原子性与竞态条件: O_EXCL  O_APPEND

pread, pwrite, preadv, pwritev, preadv2, pwritev2:
pread带有offset, 不完全等同于read+lseek, 因为其具有原子性
https://man7.org/linux/man-pages/man2/preadv2.2.html
https://www.postgresql.org/message-id/20051008154852.GC30988@svana.org
https://stackoverflow.com/questions/20560992/between-read-and-pread-which-way-has-more-efficient

readv, writev
https://stackoverflow.com/questions/10520182/linux-when-to-use-scatter-gather-io-readv-writev-vs-a-large-buffer-with-frea

truncate, ftruncate

O_NONBLOCK

Large Files

temporary file: mkstemp

signalfd: 2.6.22 (linux非标准)
timerfd: 2.6.25
eventfd: 2.6.22

monitoring file events: inotify

Kernel Buffering of FILE IO: The Buffer Cache
写同样多的数据，一次调用大的BUFFSIZE比多次调用小的BUFFSIZE效率高

Buffering in the stdio Library

fsync    fdatasync   sync    O_SYNC

Direct IO:    O_DIRECT

sendfile

ext4 btrfs

tmpfs

文件属性

文件扩展属性(linux2.6)

Access Control Lists(ACL, linux2.6)

Directories and Links
Q: hard link vs soft(symbolic) link, 以及什么情况下使用
A: https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link

=== aio
https://man7.org/linux/man-pages/man7/aio.7.html
https://github.com/littledan/linux-aio

glibc aio与linux aio:
https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux

=== io_uring

==== 简介
- 历史

    kernel version >= 5.1, 2019年

- io_uring名称的含义

    io既包含文件IO, 也包括网络IO
    uring表示use ring buffer实现内核与应用层的通信

- 使用情况

    rocksdb: http://openinx.github.io/ppt/io-uring.pdf
    https://wiki.qemu.org/ChangeLog/5.0

==== 设计背景
read(2), write(2): 最古老, 最基本
pread(2), pwrite(2): 支持offset
readv(2), writev(2): 支持vector, 即分散输入和集中输出(Scatter-Gather I/O)
preadv(2), pwritev(2): offset + vector

aio_read(2), aio_write(2): 支持异步, POSIX, 但乏善可陈, 性能不佳

io_setup(2), io_submit(2), io_getevents(2): linux native aio
不足:

- 仅支持direct IO

    在采用AIO的时候，只能使用O_DIRECT，不能借助文件系统缓存来缓存当前的IO请求
    还存在size对齐(直接操作磁盘，所有写入内存块数量必须是文件系统块大小的倍数，而且要与内存页大小对齐)等限制。

- 仍然可能被阻塞
    
    语义不完备。即使应用层主观上，希望系统层采用异步IO，但是客观上，有时候还是可能会被阻塞。
    io_getevents(2)调用read_events读取AIO的完成events，read_events中的wait_event_interruptible_hrtimeout等待aio_read_events，
    如果条件不成立(events未完成)则调用__wait_event_hrtimeout进入睡眠(当然，支持用户态设置最大等待时间)。

- 拷贝开销大

    每个IO提交需要拷贝64+8字节，每个IO完成需要拷贝32字节，总共104字节的拷贝。
    这个拷贝开销是否可以承受，和单次IO大小有关：如果需要发送的IO本身就很大，相较之下，这点消耗可以忽略，
    而在大量小IO的场景下，这样的拷贝影响比较大。

- API不友好

    每一个IO至少需要两次系统调用才能完成(submit和wait-for-completion)，需要非常小心地使用完成事件以避免丢事件。系统调用开销大。
    也正是因为上一条，io_submit/io_getevents造成了较大的系统调用开销
    在存在spectre/meltdown(CPU熔断幽灵漏洞，CVE-2017-5754)的机器上，若如果要避免漏洞问题，系统调用性能则会大幅下降。
    在存储场景下，高频系统调用的性能影响较大。

==== 思想
异步操作可以分为两步: 1.提交请求, 2.请求完成。
对于提交请求, 应用层是生产者, 内核是消费者。
对于请求完成, 内核是生产者, 应用层是消费者。
分别对应两个环形缓冲区: SQ(即提交队列), CQ(即完成队列)

▪ 降低了系统调用次数
▪ 使用共享内存 + SPSC(单生产者单消费者, 无锁)
▪ 统一了API

==== API

[source,c]
----
int io_uring_setup(unsigned entries, struct io_uring_params *p);
int io_uring_enter(int fd, unsigned to_submit,
	unsigned min_complete, unsigned flags, sigset_t *sig);
int io_uring_register(int fd, unsigned int opcode, void *arg,
	unsigned int nr_args);
----

===== io_uring_setup

https://manpages.debian.org/unstable/liburing-dev/io_uring_setup.2.en.html
https://github.com/axboe/liburing/blob/master/man/io_uring_setup.2

===== io_uring_enter

https://manpages.debian.org/unstable/liburing-dev/io_uring_enter.2.en.html
https://github.com/axboe/liburing/blob/master/man/io_uring_enter.2

===== io_uring_register

https://manpages.debian.org/unstable/liburing-dev/io_uring_register.2.en.html
https://github.com/axboe/liburing/blob/master/man/io_uring_register.2

==== liburing
liburing简化了io_uring的使用:
https://github.com/axboe/liburing

===== 使用
https://stackoverflow.com/questions/61525015/how-to-build-liburing

===== 示例
https://github.com/axboe/liburing/tree/master/examples
https://github.com/axboe/liburing/tree/master/test
https://unixism.net/loti/tutorial/index.html

==== 特性
- Fixed Files And Buffers
- Polled IO
- Kernel Side Polling

==== benchmark
https://github.com/frevib/io_uring-echo-server

==== 实现
link:../了解Linux内核/文件/io_uring.asc[《io_uring 实现》]

==== 参考
https://en.wikipedia.org/wiki/Io_uring
https://unixism.net/loti/index.html
https://kernel.dk/io_uring.pdf
https://zhuanlan.zhihu.com/p/334658432
https://lore.kernel.org/linux-block/20190116175003.17880-1-axboe@kernel.dk/
https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/
https://lwn.net/Articles/810414/
https://arthurchiao.art/blog/intro-to-io-uring-zh/
https://kernel.taobao.org/2020/08/Introduction_to_IO_uring/
https://blog.csdn.net/csdnnews/article/details/108848646
