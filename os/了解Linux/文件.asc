:toc:
:toclevels: 5
:hardbreaks-option:

== 文件

=== 基础
Q: In UNIX, everything is a file?
A: https://www.zhihu.com/question/21040222/answer/96976318

缓冲IO与非缓冲IO: 是否经过标准库缓存
直接IO与非直接IO: O_DIRECT
阻塞IO与非阻塞IO: O_NONBLOCK
同步IO与非同步IO: O_SYNC, O_DSYNC

open, read, write, close, lseek, ioctl, fcntl(FD_CLOEXEC)
Q: 线程安全?
A: 是

2>&1
dev/fd/n: n是与进程中的打开文件描述符相对应的编号
dev/null

原子性与竞态条件: O_EXCL  O_APPEND

pread, pwrite, preadv, pwritev, preadv2, pwritev2:
pread带有offset, 不完全等同于read+lseek, 因为其具有原子性
https://man7.org/linux/man-pages/man2/preadv2.2.html
https://www.postgresql.org/message-id/20051008154852.GC30988@svana.org
https://stackoverflow.com/questions/20560992/between-read-and-pread-which-way-has-more-efficient

readv, writev
https://stackoverflow.com/questions/10520182/linux-when-to-use-scatter-gather-io-readv-writev-vs-a-large-buffer-with-frea

write vs. fwrite(3)
fwrite: https://man7.org/linux/man-pages/man3/fwrite.3p.html
https://stackoverflow.com/questions/11414191/what-are-the-main-differences-between-fwrite-and-write

truncate, ftruncate

O_NONBLOCK

Large Files

temporary file: mkstemp

signalfd: 2.6.22 (linux非标准)
timerfd: 2.6.25
eventfd: 2.6.22

monitoring file events: inotify

Kernel Buffering of FILE IO: The Buffer Cache
写同样多的数据，一次调用大的BUFFSIZE比多次调用小的BUFFSIZE效率高

Buffering in the stdio Library

fsync    fdatasync   sync    O_SYNC

Direct IO:    O_DIRECT

sendfile
https://man7.org/linux/man-pages/man2/sendfile.2.html

ext4 btrfs

▪ tmpfs
https://en.wikipedia.org/wiki/Tmpfs
https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html
https://man7.org/linux/man-pages/man5/tmpfs.5.html

文件属性

文件扩展属性(linux2.6)

Access Control Lists(ACL, linux2.6)

Directories and Links
Q: hard link vs soft(symbolic) link, 以及什么情况下使用
A: https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link

=== aio
https://man7.org/linux/man-pages/man7/aio.7.html
https://github.com/littledan/linux-aio

glibc aio与linux aio:
https://stackoverflow.com/questions/8768083/difference-between-posix-aio-and-libaio-on-linux

=== io_uring

==== 简介
- 历史

    kernel version >= 5.1, 2019年

- io_uring名称的含义

    io既包含文件IO, 也包括网络IO
    uring表示use ring buffer实现内核与应用层的通信

- 使用情况

    rocksdb: http://openinx.github.io/ppt/io-uring.pdf
    https://wiki.qemu.org/ChangeLog/5.0

==== 设计背景
read(2), write(2): 最古老, 最基本
pread(2), pwrite(2): 支持offset
readv(2), writev(2): 支持vector, 即分散输入和集中输出(Scatter-Gather I/O)
preadv(2), pwritev(2): offset + vector

aio_read(2), aio_write(2): 支持异步, POSIX, 但乏善可陈, 性能不佳
https://man7.org/linux/man-pages/man7/aio.7.html

io_setup(2), io_submit(2), io_getevents(2): linux native aio
https://man7.org/linux/man-pages/man2/io_submit.2.html
不足:

- 仅支持direct IO

    在采用AIO的时候，只能使用O_DIRECT，不能借助文件系统缓存来缓存当前的IO请求
    还存在size对齐(直接操作磁盘，所有写入内存块数量必须是文件系统块大小的倍数，而且要与内存页大小对齐)等限制。

- 仍然可能被阻塞

    语义不完备。即使应用层主观上，希望系统层采用异步IO，但是客观上，有时候还是可能会被阻塞。
    io_getevents(2)调用read_events读取AIO的完成events，read_events中的wait_event_interruptible_hrtimeout等待aio_read_events，
    如果条件不成立(events未完成)则调用__wait_event_hrtimeout进入睡眠(当然，支持用户态设置最大等待时间)。

- 拷贝开销大

    每个IO提交需要拷贝64+8字节，每个IO完成需要拷贝32字节，总共104字节的拷贝。
    这个拷贝开销是否可以承受，和单次IO大小有关:
        如果需要发送的IO本身就很大，相较之下，这点消耗可以忽略，
        如果大量小IO的场景下，这样的拷贝影响比较大。

- API不友好

    每一个IO至少需要两次系统调用才能完成(submit和wait-for-completion)，需要非常小心地使用完成事件以避免丢事件。
    系统调用开销大。
    也正是因为上一条，io_submit/io_getevents造成了较大的系统调用开销
    在存在spectre/meltdown(CPU熔断幽灵漏洞，CVE-2017-5754)的机器上，若如果要避免漏洞问题，系统调用性能则会大幅下降。
    在存储场景下，高频系统调用的性能影响较大。

==== 思想
异步操作可以分为两步: 1.提交请求, 2.请求完成。
对于提交请求, 应用层是生产者, 内核是消费者。
对于请求完成, 内核是生产者, 应用层是消费者。
分别对应两个环形缓冲区: SQ(即提交队列), CQ(即完成队列)

▪ 降低了系统调用次数
▪ 使用共享内存 + SPSC(单生产者单消费者, 无锁)
▪ 统一了API

==== API

[source,c]
.https://elixir.bootlin.com/linux/latest/source/tools/io_uring/liburing.h
----
extern int io_uring_setup(unsigned entries, struct io_uring_params *p);
extern int io_uring_enter(int fd, unsigned to_submit,
	unsigned min_complete, unsigned flags, sigset_t *sig);
extern int io_uring_register(int fd, unsigned int opcode, void *arg,
	unsigned int nr_args);
----

===== io_uring_setup
- int io_uring_setup(unsigned entries, struct io_uring_params *p);
    io_uring_setup的作用是建立context, 返回一个新的io_uring fd给后续函数(mmap/io_uring_register/io_uring_enter)调用。
    核心函数: io_uring_create
    代码: https://elixir.bootlin.com/linux/latest/C/ident/io_uring_create

- 参数unsigned entries
    可以近似认为是SQ的长度或CQ长度的一半, 参数内核首先会对这个参数进行2的幂次方取证, 之后SQ和CQ的长度的计算与此值相关。

- 参数struct io_uring_params *p
    作为输入参数，同时也是输出参数
    
    struct io_uring_params {
        __u32 sq_entries;
        __u32 cq_entries;
        __u32 flags;
        __u32 sq_thread_cpu;
        __u32 sq_thread_idle;
        __u32 features;
        __u32 wq_fd;
        __u32 resv[3];
        struct io_sqring_offsets sq_off;
        struct io_cqring_offsets cq_off;
    };

- 返回值
    成功返回一个fd, 用于后续的mmap调用或者io_uring_register和io_uring_enter调用, 否则返回-1

===== io_uring_enter
- int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig);
    io_uring_setup的作用是初始化和/或完成异步I/O, 是io_uring最核心的接口
    代码: https://elixir.bootlin.com/linux/latest/source/io_uring/io_uring.c

- 参数fd
    io_uring_setup返回的fd

- 参数to_submit
    todo

- 参数min_complete
    todo

- 参数flags
    todo

- 参数sig
    todo

- 返回值
    返回成功消费的IO数量。This can be zero if to_submit was zero or if the submission queue was empty. Note that if the ring was created with IORING_SETUP_SQPOLL specified, then the return value will generally be the same as to_submit as submission happens outside the context of the system call.
    The errors related to a submission queue entry will be returned through a completion queue entry (see section CQE ERRORS), rather than through the system call itself.
    Errors that occur not on behalf of a submission queue entry are returned via the system call directly. On such an error, -1 is returned and errno is set appropriately.

===== io_uring_register
- int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args);

==== liburing
liburing简化了io_uring的使用:
https://github.com/axboe/liburing

===== 编译与安装

    git clone https://github.com/axboe/liburing.git
    cd liburing
    ./configure
    make -j 8
    sudo make install

===== 示例
https://github.com/axboe/liburing/tree/master/examples
https://github.com/axboe/liburing/tree/master/test
https://unixism.net/loti/tutorial/index.html

==== 特性
- Fixed Files And Buffers
- Polled IO
- Kernel Side Polling

==== benchmark
https://github.com/frevib/io_uring-echo-server

==== 实现
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E6%96%87%E4%BB%B6/io_uring.asc[《io_uring 实现》]

==== 参考
https://en.wikipedia.org/wiki/Io_uring
https://unixism.net/loti/index.html
https://kernel.dk/io_uring.pdf
https://zhuanlan.zhihu.com/p/380726590
https://zhuanlan.zhihu.com/p/413523052
https://zhuanlan.zhihu.com/p/334658432
https://zhuanlan.zhihu.com/p/361955546
https://lore.kernel.org/linux-block/20190116175003.17880-1-axboe@kernel.dk/
https://www.scylladb.com/2020/05/05/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/
https://lwn.net/Articles/810414/
https://arthurchiao.art/blog/intro-to-io-uring-zh/
https://kernel.taobao.org/2020/08/Introduction_to_IO_uring/
https://blog.csdn.net/csdnnews/article/details/108848646
