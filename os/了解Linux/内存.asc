:toc:
:toclevels: 4
:hardbreaks-option:

== 内存

=== 分配与释放

- 堆
    
    malloc
        Q: malloc的实现
        Q: 是否线程安全? 是否可重入?
    free 
        free() is a NULL pointer, then the call does nothing   
        freeing the same memory twice leads to unpredictable behavior
        Q: to free or not free?
    calloc() and realloc()
    memalign() and posix_memalign(): allocating aligned memory

- 栈
    
    alloca
    https://stackoverflow.com/questions/1018853/why-is-the-use-of-alloca-not-considered-good-practice
    另:
    https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard

- 实践

    Q: jemalloc vs tcmalloc

=== 内存映射

- 作用

    绝大多数操作系统(Windows/Unix-like)用于加载进程(主要用途)
    多个进程的共享内存(Q: mmap vs. shm)
    对大文件的读写(Q: why?)

-  mmap  munmap  mremap

[source,c]
----
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 
Returns starting address of mapping on success, or MAP_FAILED on error 
int munmap(void *addr, size_t length); 
int msync(void *addr, size_t length, int flags);
void *mremap(void *old_address, size_t old_size, size_t new_size, int flags, ...); 
int remap_file_pages(void *addr, size_t size, int prot, size_t pgoff, int flags);
----

    Q: mmap 线程安全吗？

- file-based or anonymous

- MAP_PRIVATE or MAP_SHARED

=== 虚拟内存

- mprotect

- mlock mlockall

- mincore

- madvise

[source,c]
----
#include <sys/mman.h> 
int mprotect(void *addr, size_t length, int prot);
int mlock(void *addr, size_t length); 
int munlock(void *addr, size_t length); 
int mincore(void *addr, size_t length, unsigned char *vec);
int madvise(void *addr, size_t length, int advice);
----