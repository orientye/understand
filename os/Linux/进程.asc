:toc:
:toclevels: 5
:hardbreaks-option:

== 进程

=== 创建
• 使用场景
    eg. shell, web server, chrome ...

• Q: fork做了什么
    对fd, memory的影响
        copy on write

• 多线程与fork
    https://www.cnblogs.com/Solstice/archive/2010/02/26/linux_new_syscalls.html

• Q: fork vs vfork vs clone vs exec
    Aspect	fork()	vfork()	clone()	exec()
    Memory	Copy (COW)	Shared	Configurable	Replaced
    Parent	Continues	Suspended	Configurable	Continues (same process, new program)
    Use Case	Process creation	Legacy optimization	Threads/custom	Program loading
    Safety	Safe	Dangerous	Flexible	Safe
    Returns	Twice	Twice	Once	Never
    PID	New PID	New PID	Configurable	Same PID
    Process Image	Same copy	Same	Configurable	Completely replaced
    https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone
    https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec
    vfork: https://www.zhihu.com/question/304323673

• Q: fork vs vfork vs clone vs exec 对进程属性的影响
    https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E7%AE%A1%E7%90%86.asc#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8
    https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E8%BF%9B%E7%A8%8B/%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.asc

• Q: 热更新/无缝重启/hot restart/zero-downtime restart
    eg. nginx/golang/nodejs/lua

• Q: 最多能分配多少个进程呢?
    ulimit -u max user processes
    https://stackoverflow.com/questions/9361816/maximum-number-of-processes-in-linux

=== 终止
exit, _exit
The following actions are performed by exit():
Exit handlers (functions registered with atexit() and on_exit()) are called, in reverse order of their registration.
The stdio stream buffers are flushed.
The _exit() system call is invoked, using the value supplied in status.
Unlike _exit(), which is UNIX-specific, exit() is defined as part of the standard C library; that is, it is available with every C implementation.

https://stackoverflow.com/questions/5422831/what-is-the-difference-between-using-exit-exit-in-a-conventional-linux-fo

atexit, on_exit

=== 状态
执行man ps命令:
PROCESS STATE CODES

    Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the state of a process:
        D    uninterruptible sleep (usually IO)
        I    Idle kernel thread
        R    running or runnable (on run queue)
        S    interruptible sleep (waiting for an event to complete)
        T    stopped by job control signal
        t    stopped by debugger during the tracing
        W    paging (not valid since the 2.6.xx kernel)
        X    dead (should never be seen)
        Z    defunct ("zombie") process, terminated but not reaped by its parent

    For BSD formats and when the stat keyword is used, additional characters may be displayed:
        <    high-priority (not nice to other users)
        N    low-priority (nice to other users)
        L    has pages locked into memory (for real-time and custom IO)
        s    is a session leader
        l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
        +    is in the foreground process group


=== 子进程
wait, waitpid
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options)

waitid
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

wait3, wait4
pid_t wait3(int *status, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);

Orphans and Zombies
Q: 分别怎么来的?
Q: 孤儿真的是孤儿吗?
Q: wait与zombie

孤儿进程 (Orphan Process)

    定义：
        当父进程先于子进程结束，子进程就会成为孤儿进程。
    特点：
        孤儿进程会被 init 进程接管，成为其新的父进程
        不会对系统造成危害
        init 进程会定期调用 wait() 来收集孤儿进程的退出状态
    产生原因：
        父进程意外终止(如崩溃)
        父进程显式终止但未等待子进程

僵尸进程 (Zombie Process)

    定义：
        子进程先于父进程结束，但父进程没有调用 wait() 或 waitpid() 来获取子进程的退出状态，子进程就成为僵尸进程。
    特点：
        已经终止但仍占用进程表中的条目
        不占用内存等资源，但占用有限的进程ID
        如果大量产生会导致系统无法创建新进程
    产生原因：
        父进程没有正确处理子进程的终止
        父进程太忙无法及时调用 wait()

特征        孤儿进程              僵尸进程
定义       父进程先终止      子进程终止但未被父进程回收
危害性        无害          可能耗尽进程ID资源
处理方式   由init进程接管    需要父进程调用wait()回收
进程状态     仍在运行         已终止(Zombie状态)
解决方案   系统自动处理      需要编程处理或杀死父进程

SIGCHLD
https://www.gnu.org/software/libc/manual/html_node/Job-Control-Signals.html#index-SIGCHLD

=== 执行
execve
int execve(const char *pathname, char *const argv[], char *const envp[])

execle execlp execvp execv execl fexecve

system

=== 调度
int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int prio);
int sched_get_priority_min(int policy);
int sched_get_priority_max(int policy);
int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);
int sched_setparam(pid_t pid, const struct sched_param *param);
int sched_getscheduler(pid_t pid);
int sched_getparam(pid_t pid, struct sched_param *param);
int sched_yield(void);
int sched_rr_get_interval(pid_t pid, struct timespec *tp);

int sched_setaffinity(pid_t pid, size_t len, cpu_set_t *set);
int sched_getaffinity(pid_t pid, size_t len, cpu_set_t *set);

=== IPC
- Most OS:

    https://en.wikipedia.org/wiki/Inter-process_communication

- Special:

    eg. Windows Clipboard, COM, Data Copy, DDE, Mailslots

==== IPC-pipe
byte stream; unidirectional;
Writes of up to PIPE_BUF bytes are guaranteed to be atomic
Pipes have a limited capacity(linux2.6.11, 65536bytes default,fcntl(fd, F_SETPIPE_SZ, size) )

int pipe(int filedes[2]);
int pipe2(int pipefd[2], int flags);

Q: 匿名管道支持非阻塞读写吗？

注意事项:
When using pipes, we must be careful to close unused descriptors in order to ensure that reading processes detect end-of-file and writing processes receive the SIGPIPE signal or the EPIPE error. (Usually, it is easiest to have the application writing to a pipe ignore SIGPIPE and detect a “broken” pipe via the EPIPE error.)

int mkfifo(const char *pathname, mode_t mode);

https://man7.org/linux/man-pages/man7/pipe.7.html

==== IPC-FIFO
By default, opening a FIFO for reading blocks until another process opens the FIFO for writing, and vice versa.

Nonblocking I/O 

==== IPC-System V
什么时候可能需要考虑 System V IPC？
尽管 POSIX 有诸多优点，但在极少数情况下，可能会遇到 System V IPC：
维护遗留代码：维护一个非常古老的项目，它已经大量使用了 System V IPC，为了保持一致性和减少重写成本，你可能会继续使用它。
特定的跨平台需求：需要支持的某个非常老旧的、不符合 POSIX 标准的 Unix 变体可能只提供了 System V IPC。
与特定第三方软件的交互：某些老旧的软件在其内部或配置中可能会使用 System V 的共享内存或信号量。

==== IPC-POSIX
为什么推荐 POSIX IPC？
更清晰的 API 设计：使用路径名而不是神秘的 key_t，代码可读性更高，意图更明确。
更好的资源管理：基于文件系统的命名方式，使得清理残留资源更简单（可以直接用 unlink 类似的函数或命令）。
更强大的功能：例如消息队列的异步通知机制，这是 System V 所不具备的。
更符合现代标准：新的库、工具和开发实践都倾向于使用 POSIX 接口。
更好的线程安全：POSIX IPC 的接口在设计时更多地考虑了线程环境。

==== IPC-File Lock
• Only fcntl() locking is standardized in SUSv3.
• The flock() system call locks an entire file.
• The fcntl() system call places locks (“record locks”) on any region of a file, ranging from a single byte to the entire file. Two types of locks may be placed: read locks and write locks, which have similar compatibility semantics to the shared and exclusive locks 
placed via flock(). If a blocking (F_SETLKW) lock request would bring about a deadlock situation, then the kernel causes fcntl() to fail (with the error EDEADLK) in one of the affected processes.
• Locks placed using flock() and fcntl() are invisible to one another (except on systems that implement flock() using fcntl()). The locks placed via flock() and fcntl() have different semantics with respect to inheritance across fork() and release when file descriptors are closed.
• The Linux-specific /proc/locks file displays the file locks currently held by all processes on the system.

=== thread
参考: https://github.com/orientye/understand/blob/main/concurrency/concurrency/thread.asc

=== daemon
int daemon(int nochdir, int noclose);

Progress Groups
Sessions

实现

=== 命名空间
clone()
setns()
unshare()