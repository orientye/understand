:toc:
:toclevels: 5
:hardbreaks-option:

== 内存

=== 分配与释放
==== 堆

    malloc
        Q: malloc的实现
        Q: 是否线程安全? 是否可重入?

    free
        free() is a NULL pointer, then the call does nothing   
        freeing the same memory twice leads to unpredictable behavior

    calloc() and realloc()

    memalign() and posix_memalign()
        allocating aligned memory

==== 栈

    alloca
        https://stackoverflow.com/questions/1018853/why-is-the-use-of-alloca-not-considered-good-practice
        https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard

==== 实践

    Q: jemalloc vs tcmalloc

==== 参考
https://github.com/orientye/understanding-the-linux-kernel/blob/main/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98/%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE.asc#mallocfreecallocreallocreallocarray[linux-kernel-malloc]

=== 内存映射
==== 作用
- 绝大多数操作系统(Windows/Unix-like)用于加载进程(主要用途)

        动态链接器：使用 mmap 将可执行文件和共享库映射到进程地址空间
        按需分页：只有真正访问到的代码和数据才会被加载到物理内存
        节省内存：多个进程运行同一个程序时，共享代码段（如 libc 等共享库）

- 多个进程的共享内存

        mmap vs. shm
            特性	    mmap	          shm（System V/POSIX）
            持久性	    随进程消失	       显式删除前持续存在
            关联文件	可以映射普通文件    纯内存对象（可持久化到文件）
            命名空间	无全局命名	       有全局键名/名字
            使用场景	文件IO、进程加载	纯粹的进程间通信
            选择建议：
                需要操作文件 → mmap
                只需要共享内存通信 → shm_open + mmap（POSIX共享内存）
                需要跨进程同步 → 两者都可配合信号量使用

- 对大文件的读写

        减少数据拷贝
            传统读写：文件→内核缓冲区→用户缓冲区→内核缓冲区→文件（4次拷贝）
            mmap：文件→用户地址空间（直接映射，2次拷贝）
        减少系统调用
            一次映射后，读写就像访问普通内存
            避免频繁的 read/write 系统调用开销
        按需加载
            只需访问文件的一小部分，不会加载整个文件
            对超大文件特别友好
        简化的编程模型
            使用指针操作，无需管理缓冲区
            自动处理缓存

==== mmap/munmap/mremap
[source, c]
----
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 
Returns starting address of mapping on success, or MAP_FAILED on error 
int munmap(void *addr, size_t length); 
int msync(void *addr, size_t length, int flags);
void *mremap(void *old_address, size_t old_size, size_t new_size, int flags, ...); 
int remap_file_pages(void *addr, size_t size, int prot, size_t pgoff, int flags);
----

Q: mmap线程安全吗?
是(参考https://man7.org/linux/man-pages/man2/mmap.2.html), 但不要误以为在mmap映射出来的内存上进行多线程操作也是安全的

参考:
https://man7.org/linux/man-pages/man2/mmap.2.html

==== file-based or anonymous

==== MAP_PRIVATE or MAP_SHARED

=== 虚拟内存

- mprotect

- mlock mlockall

- mincore

- madvise

[source, c]
----
#include <sys/mman.h> 
int mprotect(void *addr, size_t length, int prot);
int mlock(void *addr, size_t length); 
int munlock(void *addr, size_t length); 
int mincore(void *addr, size_t length, unsigned char *vec);
int madvise(void *addr, size_t length, int advice);
----

=== 共享内存
==== POSIX 共享内存

[source, c]
----
#include <sys/mman.h>
#include <sys/stat.h>        /* For mode constants */
#include <fcntl.h>           /* For O_* constants */
int shm_open(const char *name, int oflag, mode_t mode);
int shm_unlink(const char *name);
----

==== System V 共享内存

[source, c]
----
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
void *shmat(int shmid, const void *shmaddr, int shmflg);
int shmdt(const void *shmaddr);
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
----

https://stackoverflow.com/questions/21311080/linux-shared-memory-shmget-vs-mmap

==== memfd
since 3.17
https://man7.org/linux/man-pages/man2/memfd_create.2.html